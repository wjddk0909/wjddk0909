var store = [{
        "title": "code splitting",
        "excerpt":"Code Splitting   웹사이트를 만들었는데 첫 로드에 시간이 걸린다면 왜 그럴까?  이유는 햔 페이지만 로드하면 되는 첫 시작 페이지에서 필요하지 않은 여러 페이지(프레임워크를 사용하는 경우 import한 컴포넌트 파일)을 로딩하기 때문   webpack은 이러한 문제점에 대한 해결팩으로 코드 스플리팅을 제공한다.   코드 스플리팅은 웹 사이트를 더 빠르게 운영하는데 도움이 되는 주제이다.  페이지에 필요한 컴포넌트만 로드되고, 원한다면 다른 컴포넌트도 함께 로드할 수 있다. 많은 컴포넌트를 작성하고 여러 경로를 설정(라우팅)해 줘야 하는 대형 프로젝트에서 코드 스플리팅을 사용하면 로드 시간을 단축할 수 있다.   경로 설정에 코드 스플리팅 기능을 적용할 것이기 때문에 라우터가 필요하다.   코드를 분할 하는 방법은 세가지가 있다.     Entry Points : entry 설정을 사용하여 코드를 수동으로 분할   Prevent Duplication : Entry dependencies 또는 SplitChunksPlugin을 사용하여 중복 청크를 제거하고 청크를 분할   Dynamic Imports : 모듈 내에서 인라인 함수 호출을 통해 코드 분할   Dynamic Imports 방법(작성중…)   샘플 코드 만들기   npm install –save-dev @babel/plugin-syntax-dynamic-import  ","categories": ["fe-study"],
        "tags": ["splitting"],
        "url": "/fe-study/fe-code-splitting/",
        "teaser": null
      },{
        "title": "Interceptor/Debounce/throttle",
        "excerpt":"Interceptor/Debounce/throttle   인터셉터는 사용자의 요청을 가로채는 역할(서버에 권한이 있는지 확인하는등) 사용자의 요청이 컨트롤러에 가기 전에 가로채고, 서버의 응답이 사용자에게 가기 전에 가로챈다.   Debounce, throttle 자주 사용 되는 이벤트나 함수 들의 실행되는 빈도를 줄여서, 성능 상의 유리함을 가져오기 위한 개념이다.   debounce(입력주기가 끝나면 출력) : scroll, resize event 이런 이벤트가 끝났을때 한번만 실행되게 하고싶을때 throttle : 일정시간동안 한번만 실행   code)  1 &lt;input id=\"search\" type=\"search\" name=\"search\" value=\"\" /&gt;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var debounce = null; var throttle = null; function keyUpFn(el) {   // normal   console.log('normal', el.target.value, new Date().getTime());   // debounce   clearTimeout(debounce);   debounce = setTimeout(() =&gt; {     console.log(       'debounce',       el.target.value, new Date().getTime());   }, 500);   // throttle   if(!throttle) {     setTimeout(() =&gt; {       console.log('throttle', throttle, new Date().getTime());       throttle = null;     }, 500);   }   throttle = el.target.value; } document.getElementById(\"search\").addEventListener('keyup', keyUpFn); // normal h         1583658583270 // normal he        1583658583582 // normal hel       1583658583878 // normal hell      1583658584182 // throttle hell    1583658584271 // 입력이 끝남 // normal hello     1583658584534 // debounce hello   1583658585036 // throttle hello   1583658585536      Input Search Element 에 Keyup Event Listener 를 등록한다.   normal 에서는, 키보드입력 발생하면, 그 즉시 value 를 출력한다.   throttle 에서는 키보드입력 발생하면, 500ms 후에, 가장 최신 value 를 출력하고, 초기화 하여, 키보드 입력이 끝날때까지 반복한다.   debounce 에서는 키보드 입력이 발생하면, 500ms 동안 기다리다, 그 안에 키보드 입력이 발생하면, 시간을 초기화 하고 다시 기다리다, 가장 최신 value 를 출력한다.   Throttle  여러번 발생하는 이벤트를 일정 시간 동안, 한번만 실행 되도록 만드는 개념이다.  위 예제에서 500ms 동안 이벤트 실행을 막고, 한번만 실행 때문에, 잦은 이벤트 발생을 막아 성능상의 유리함을 가져 올 수 있다.  Debounce 와 다른점은 이벤트 발생 시간 이후에 일정 시간 동안 만을 기다리고, 이벤트를 실행 후 재차 기다린 다는 점이다.   Debounce  가장 마지막 이벤트 만을 실행 되도록 만드는 개념이다.  입력이 끝날때, 가장 마지막 이벤트만을 실행하여, 성능성 유리함을 가져올 수 있다.  Throttle 와 다른점은, 마지막 이벤트에서 일정 시간동안 이벤트가 발생한다면, 또 일정 시간을 기다린다는 점이다.   Throttle 와 Debounce 차이점  Throttle 와 Debounce 의 차이점은 이벤트를 언제 발생 시킬지의 시점 차이이다.  Debounce 는 입력이 끝날때까지 무한적으로 기다리지만, Throttle 는 입력이 시작되면, 일정 주기로 계속 실행한다.  Debounce 의 시간을 짧게 가져간다면, Throttle 와 비슷한 효과가 날 수 있지만, 그럼에도 시점에서 차이가 날 수 있다.   대표적인 예로 자동완성 만들 경우,  일정 주기로 자동으로 완성되는 리스트를 보여주는 것에는  사용자 측면에서 Throttle (검색 되는 경험) 가 유리할 수 있지만,  성능상에서는 Debounce (1번만 호출) 가 훨씬 유리할 수 있다.   ","categories": ["fe-study"],
        "tags": ["interceptor"],
        "url": "/fe-study/fe-interceptor/",
        "teaser": null
      },{
        "title": "아키텍처",
        "excerpt":"아키텍처는 무엇으로 이루어지는가?   아키텍처는 일반적인 정의에 따르면 설계자가 원하는 기능을 구조로 표현하는 고수준 결과물이다.  아키텍처는 의도, 규칙, 구성, 대상으로 이루어진다.      아키텍처는 의도를 가져야 한다.            설계자의 생각을 표현허는 과정인 만큼 아키텍처에는 생각, 의도가 담겨있다.           아키텍처는 규칙을 가져야 한다.            기능을 구조로 맵핑하는 설계 결과물       시스템을 구성하는 요소와 요소간의 관계, 요소들을 포함하는 전체 시스템의 경꼐, 시스템과 환경 간의 관계 등을 포함한다.           대상(결과물)을 가져야 한다.            대상(결과물)은 아키텍처를 기초로 만들어질 최종 산출물을 의미           의도 &gt; (표현) &gt; 규칙 &gt; (구체화) &gt; 구성 &gt; (구현) &gt; 대상/결과물      아키텍처란?  옷을 정리하는 것을 상상해보자. 처음에는 옷이 몇개 없어서 아무데나 두어도 크게 상관이 없다.  하지만 옷이 많아지면 옷걸이가 필요하고 더 많아지면 옷장이 필요해진다.   옷걸이와 옷장이 있고 없고의 차이는?  옷이 제대로 보관되지 않아서 옷이 상할 것이고 원할때 필요한 옷을 찾기가 힘들어진다.  그렇다고 옷장에 막무가내로 넣어두기만 하면 어떨까?  옷장의 첫번째 역할인 보관이라는 목적은 충실했지만 필요한 옷을 쉽게 찾아 꺼낸다는 목적은 잃게 된다.  그러니 보관을 하되 잘 꺼낼 수 있도록 잘 넣어두는 방법을 고려해야 한다.   그러려면 일단 잘 넣어두기 위해서 하지 말아야할 규칙을 정한다.  예를 들어 옷을 아무렇게나 섞어서 두면 불편하다, 양말이 짝이 안맞다, 위아래 세트인 옷을 찾기 힘들다 등등..  이 불편함을 제거하기 위한 규칙을 만든다. 일반적으로 비슷한 것끼리 분류해서 모은다.   이러한 과정에서 패턴이 만들어지면 나중에는 이 패턴에 맞는 목적성을 가진 옷장이 등장한다.  처음에는 단순히 통으로 된 옷장이었다면 상의, 하의를 구분하는 칸이 나뉘어져 있다가 양발을 보관하는 칸이 생기고, 외투나 모자, 가방등 각 용도에 맞는 구조로 만들어진다.   그러면 처음의 옷장에 비해서 세부적인 규칙을 잘 몰라도 옷 정리가 한결 편해진다.      아키텍처란 구조화 된 옷장과 비슷하다. 처음 개발할 때에는 규칙없이 그냥 코드를 만들다 보면 프로젝트의 덩치가 커지고 불편함이 생기고 코드 정리가 안되는 시점이 생긴다. 그러니 처음부터 특정한 규칙을 만들어서 개발하는게 좋다는 것을 깨닫고 규칙을 하나씩 만들어가며 개발을 하다보면 이제 특정 패턴이 만들어진다. 이러한 패턴들을 모두가 이해하고 따를 수 있도록 하는 구조를 아키텍처라고 부른다.    결국 소프트웨어 관점에서 봤을때 지속적으로 관리가 잘 되는 코드를 위해서는 좋은 아키텍처가 필요하다는 의미이다.      비유는 엄밀하게는 같은 이야기는 아니다. 옷은 서로 데이터를 주고 받지 않지만 소프트웨어의 각 모듈들은 서로 데이터를 주고 받아야한다. 그러니 아키텍처를 단순히 분류를 넘어 데이터를 주고 받는 인터페이스 설계가 중요하다.       웹 프론트엔드 아키텍처 아키텍처는 좋은 구조를 만드는것. 좋은 구조의 첫번째 조건은 좋은 분류이다.      옷장에서 상의, 하의, 양말 처럼 서로 비슷한 것 끼리 그리고 섞이면 안되는 것끼리 구분을 하는 것이 중요!    ","categories": ["fe-study"],
        "tags": ["architecture"],
        "url": "/fe-study/fe-modular-architecture/",
        "teaser": null
      },{
        "title": "자바스크립트 모듈화",
        "excerpt":"자바스크립트의 모듈화   자바스크립트는 기본적으로 모듈화 기능이 없었다. .js파일로 여러개 쪼개서 모든 파일을 하나씩 &lt;script&gt;&lt;/script&gt; 태그를 이용하여 불러오는 방법이 있긴 했지만 이 방법에는 문제가 있었다.     파일을 불러들이는 순서가 중요   따로 만든 오브젝트들이 모두 글로벌 변수에 저장   변수의 이름이 겹치면 에러 발생   그래서 다른 사람이 만든 코드 불러들여서 사용하기 복잡   모듈(Module)   프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화한다.  코드의 재활용성을 높이고, 유지보수를 쉽게 할 수 있는 다양한 기법들이 사용된다.  그중의 하나가 코드를 여러개의 파일로 분리하는 것이다. 이를 통해서 얻을 수 있는 효과는 아래와 같다.     자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용(함수의 재사용성과 비슷)   코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.   코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다. (파일로 모듈을 쪼개어 놔서)   필요한 로직(파일)만을 로드해서 메모리 낭비를 줄일 수 있다.   모듈화의 중요성은?  모듈화가 중요한 이유는 코딩 작업이 편리해지고 코드의 유지보수가 편해져서이다.  하나의 .js파일에 모든 코드가 다 들어있으면 그것을 뜯어보고 이해하고 고치는데 시간이 많이 걸린다.  하지만 각 기능에 맞춰서 코드를 나누어서 관리하면 코드를 고치거나 업데이트 할 때 해당 부분만 쉽게 찾아서 작업이 가능하다.   방법은?     export default export할 모듈이 하나 밖에 없을 때 이용   1 2 3 4 var a = function() {     console.log('hello') } export default a;      named export export할 모듈이 여러개 있을 때 이용   1 2 3 4 5 6 7 8 9 10 var a = function() {     console.log('hello'); }  var b = function() {     console.log('bye'); }  export const hi = a; export const bye = b;   위 두가지의 차이점은 어떤 export 방식을 택하느냐에 따라서 모듈을 import 하는 방식이 달라진다.      1번 방법으로 export 했을때 import 방법 import 할때 원하는 이름을 임의로 지정할 수 있다.   1 import ABC from './a.js';  export는 a로 했지만 import할 때는 아무 이름이나 사용이 가능하다.  1 import {default as 원하는 이름} from './a.js';   혹이 이런식으로도 가능하다.      2번 방법으로 export 했을 때 import 방법 import 할 때 이름이 export에서 지정한 이름과 같아야 하고 반드시 {}안에 적어야한다.   1 import { hi, bye } from './a.js';  이렇게 원하는 부분만 골라서 불러 올 수 있다. 만약 모든 모듈을 한꺼번에 불러와야한다면 아래와 같은 방법을 사용한다.   1 2 3 4 5 6 import * as say from './a.js'; // say가 아닌 다른 이름도 가능 (임의로 설정한 이름임)  // 사용은 아래와 같이 say.hi(); // 결과 -&gt; hello  ","categories": ["fe-study"],
        "tags": ["Module"],
        "url": "/fe-study/fe-module/",
        "teaser": null
      },{
        "title": "npm install / --save / --save-dev 차이",
        "excerpt":"그냥 install(add)  npm install / yarn add 단순히 ./node_modeuls폴더에 패키지 설치   –save / -P  npm install --save / yarn add --save --save키워드를 통해 우선 ./node_modules폴더에 패키지 설치  ./package.josn의 dependencies 옵션에 해당 패키지 추가되어 다음 install시 해당 패키지가 자동으로 설치됨   –save-dev / -D  npm install --save-dev / yarn add --save-dev ./package.json의 devDependencies옵션에 해당 패키지 추가  ","categories": ["fe-study"],
        "tags": ["npm","yarn","install"],
        "url": "/fe-study/fe-npm-install/",
        "teaser": null
      },{
        "title": "라우팅 - 동적라우팅 / 정적라우팅",
        "excerpt":"라우팅 이란?   네트워크 계층에서 길을 찾아주는 것, 즉 패킷이 목적지에 도달할 최적의 경로를 찾아 전송하는 것 -&gt; 라우팅 테이블을 보고 길을 찾아준다. (라우팅 테이블은 나와 연결된 이쪽 인터페이스쪽으로 가면 목적지가 있겠구나를 알려줌)   정적라우팅(Static Routing) vs 동적라우팅(Dynamic Routing)           정적라우팅 : 목적지 주소까지 어떻게 가야하는지 직접 지정            동적라우팅 : 목적지 주소까지 어떻게 가야하는 자동으로 지정       SPA는 최초 로드시 데이터를 전부 다운로드 하는데 이는 초기 구동시에 필요없는 데이터까지 전부 받기 때문에 오히려 처음 페이지 로드가 느려질 수 가 있다.  그래서 초기 구동 속도 향상을 위해 동적 라우팅(또는 컴포넌트)로 component를 import 하면 (component: () =&gt; import('컴포넌트 경로')) 라우터 진입시에 필요한 데이터를 받아온다.   ","categories": ["fe-study"],
        "tags": ["Routing","Static Routing","Dynamic Routing"],
        "url": "/fe-study/fe-routing/",
        "teaser": null
      },{
        "title": "1 - 개발 환경 설정",
        "excerpt":"1.1 vue 개발 환경 설정      chrome 설치   vs code 설치   node.js LTS 버전 설치   크롬 확장 프로그램 Vue.js devetools 설치   참고 링크     Chrome   vs code   node.js   Vue.js devtools   1.2 수업 소스 코드 안내   깃 업로드 후 추가 예정   1.3 vs code 플러그인 설치     확장버튼 클릭               Vetur   Night Owl   Material Icon Theme   Live Server   ESLint   Prettier   Auto Close Tag  이미지로 첨부한 것 이외에도 추가하면 좋을 확장프로그램 리스트입니다.   Material Icon Theme 적용하는 방법       code &gt; 기본 설정(Preferences) &gt; 파일 아이콘테마(File Icon Theme) 클릭        Material Icon Theme 선택   ","categories": ["vue-lv1"],
        "tags": ["vue","setting"],
        "url": "/vue-lv1/vue-beginner1/",
        "teaser": null
      },{
        "title": "2 - vue.js 소개",
        "excerpt":"2.1 vue는 무엇인가?   MVVM패턴의 뷰모델(ViewModel) 레이어에 해당하는 화면(View)단 라이브러리   View라고 되어 있는 것은 브라우저에서 사용자에게 비춰지는 화면을 의미한다.  즉, 버튼이나 입력박스등이 해당한다.   사용자가 키보드로 입력했을때 이벤트를 중간에 DOM Listener로 view에서 읽게 됩니다. 그런 이벤트를 잡아서 데이터를 바꾸거나 특정 로직에서 실행을 합니다.   자바스크립트의 데이터가 변했을때 Data Bindings를 하게 됩니다. 그리고 Data Bindings를 이용해서 화면에 반영합니다.      2.2 기존 웹 개발 방식(HTML, Javascript)   일반적으로 프레임워크를 쓰지 않고 웹을 개발하는 방법은 HTML, CSS, Javascript를 사용합니다.   1 2 3 4 5 6 7 8 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var str = \"Hello World\";     console.log(div);     div.innerHTML = str; &lt;/script&gt;   이렇게 작성하고 브라우저에서 확인을 하면 브라우저에서 확인 할 수 있습니다.      html은 화면에 나타나는 태그나 돔의 정보를 넣는 것 이고 자바스크립트는 해당 태그나 돔의 내용을 조작하는 것을 알 수 있습니다.   여기에서 str의 값을 바꿀때는 바뀐 문자열의 내용을 다시 넣어줘야 합니다.   1 2 3 4 5 6 7 8 9 10 11 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var str = \"Hello World\";     console.log(div);     div.innerHTML = str;      str = \"Hello World!!!\";     div.innerHTML = str; &lt;/script&gt;   2.3 Reactivity 구현   기존의 개발 방식에서 vue.js의 핵심 기능인 Reactivity를 이용해보겠습니다.   div정보만 받아놓은 상태에서 viewModel이라는 객체를 선언하고  Object.defineProperty()라는 api를 사용해보겠습니다.   Object.defineProperty()가 하는 역할은 객체의 동작을 재정의 하는 api라고 보시면 됩니다.  변수 a에 10을 할당하면 a에 접근 할 수 있습니다. 혹은 a를 20으로 바꿀 수 있습니다. 특정 변수, 객체의 속성 동작을 재정의 하는것이 Object.defineProperty() 입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var viewModel = {};      // Object.defineProperty(대상객체, 객체의 속성, {               // });      Object.defineProperty(viewModel, 'str', {         // 속성의 접근했을 때의 동작을 정의         get: function() {             console.log('접근');         },         // 속성에 값을 할당했을 때의 동작을 정의         set: function(newValue) {             console.log('할당', newValue);         }     }); &lt;/script&gt;   콘솔창에서 확인을 해봅시다.    여기에서 str의 값이 바뀌면 바뀐 값을 화면에 뿌리도록 정의 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var viewModel = {};      Object.defineProperty(viewModel, 'str', {         get: function() {             console.log('접근');         },         set: function(newValue) {             console.log('할당', newValue);             div.innerHTML = newValue;         }     }); &lt;/script&gt;      값을 바꿀 때마다 화면이 바뀌는 것을 확인 할 수 있습니다.  vue의 핵심은 데이터의 변화를 라이브러리에서 감지해서 알아서 화면을 자동으로 그려주는 Reactivity입니다.   2.4 Reactivity 코드 라이브러리화 하기   코드를 라이브러리화 해보겠습니다.  init()이라는 함수안에 Object.defineProperty를 잘라서 넣습니다.  render()함수를 만들어서 div에 텍스트 값을 바꾸는 부분을 옮기고 set에서 render()를 호출해서 새로운 값이 할당 됐을때 render()에 넘겨주도록 합니다.  그리고 최종적으로 즉시실행 함수 안에 넣어줍니다.  즉시실행 함수의 역할은 기본적으로 애플리케이션의 로직에 노출되지 않도록 또다른 유효범위(스코프)에 넣어주는 것입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var viewModel = {};      (function() {         function init() {             Object.defineProperty(viewModel, 'str', {                 get: function() {                     console.log('접근');                 },                 set: function(newValue) {                     console.log('할당', newValue);                     render(newValue)                 }             });         }         function render(value) {             div.innerHTML = value;         }         init();     })(); &lt;/script&gt;   2.5 Hello Vue.js와 뷰 개발자 도구   간단하게 뷰로 Hello Vue.js를 화면에 찍어 보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;div id=\"app\"&gt;      &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             message: 'Hello Vue.js'         }     }) &lt;/script&gt;   코드를 브라우저에서 확인 해봅시다.      크롬 개발자 모드에서 vue탭으로 이동후 data &gt; message: “Hello Vue.js”의 내용을 바꾸면 화면에서 바로 반영이 됩니다.   ","categories": ["vue-lv1"],
        "tags": ["vue"],
        "url": "/vue-lv1/vue-beginner2/",
        "teaser": null
      },{
        "title": "3 - 인스턴스",
        "excerpt":"3.1 인스턴스 소개   뷰에서 첫번째로 알아야 할 개념은 인스턴스 입니다. 인스턴스는 뷰로 개발 할때 필수로 생성해야 할 단위입니다.   인스턴스를 생성하고 나면 변수안에 인스턴스의 내용을 담을 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var vm = new Vue({         el: '#app',         data: {             message: 'hi'         }     }); &lt;/script&gt;   vm이라는 변수에 new Vue라고 인스턴스를 생성합니다.  el: ‘#app” &gt; app이라는 아이디를 가진 태그를 찾아서 인스턴스를 붙이겠다 라는 의미입니다.  이렇게 붙이는 순간 vue의 기능과 속성들이 유효해 집니다.   3.2 인스턴스와 생성자 함수   생성자 함수를 만들고 name과 job을 인자로 받아서 정보들을 인스턴스로 찍어낼 수 있습니다.  함수를 선언하면 객체가 생성됩니다.      뷰를 왜 생성자 함수로 찍어내는지 보겠습니다.   Vue라는 생성자 함수를 이용해서 기능을 편하게 쓰게 하고 싶을때, logText()라는 함수를 미리 정의 해놓습니다.  그럴때 vm으로 new Vue()를 생성할 때마다 logText()함수가 들어가 있습니다. 그래서 매번 함수를 정의하는게 아니라 함수를 가져다 사용할 수 있습니다.      3.3 인스턴스 옵션 속성   1 2 3 4 5 6 7 8 new Vue({     el:,     template:,     data:,     methods:,     created:,     watch:, });   1 2 3 4 5 6 7 8 9 10 11 12 var vm = new Vue({     el: '#app',     data: {         message: 'hi'     },     methods: {              },     created: function() {      } });   ","categories": ["vue-lv1"],
        "tags": ["vue"],
        "url": "/vue-lv1/vue-beginner3/",
        "teaser": null
      },{
        "title": "4 - 컴포넌트",
        "excerpt":"4.1 컴포넌트 소개   vue.js의 컴포넌트에 대해서 알아보겠습니다. 컴포넌트는 화면의 영역을 구분하여 개발할 수 있는 뷰의 기능입니다. 컴포넌트 기반으로 화면을 개발하게 되면 코드의 재사용성이 올라가고 빠르게 화면을 만들 수 있습니다.  컴포넌트는 영역을 구분했을 때 컴포넌트간에 관계가 생깁니다.   4.2 컴포넌트 등록 및 실습   인스턴스를 생성하면 개발자 도구에서 Root컴포넌트로 인식합니다.   컴포넌트를 등록하는 가장 간단한 방법은 전역 컴포넌트로 등록하는 방법입니다. 전역 컴포넌트를 등록하고 인스턴스의 영역에 컴포넌트 태그를 넣어주면 됩니다.  (실제 서비스를 할때는 전역컴포넌트를 등록하는 일은 거의 없을것입니다.)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;x &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     // Vue.component('컴포넌트 이름', 컴포넌트 내용);     // 전역 컴포넌트     Vue.component('app-header', {         template: '&lt;h1&gt;Header&lt;/h1&gt;'     });      new Vue({         el: '#app'     }); &lt;/script&gt;   4.3 지역 컴포넌트 등록   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     // Vue.component('컴포넌트 이름', 컴포넌트 내용);     // 전역 컴포넌트     Vue.component('app-header', {         template: '&lt;h1&gt;Header&lt;/h1&gt;'     });      new Vue({         el: '#app',         components: {             // '컴포넌트 이름': 컴포넌트 내용             'app-footer': {                 template: '&lt;footer&gt;footer&lt;/footer&gt;'             }         }     }); &lt;/script&gt;      4.4 전역 컴포넌트와 지역 컴포넌트의 차이점   지역컴포넌트는 하단에 어떤게 등록되어있는지 알 수 있습니다.  서비스를 구분할 때는 지역컴포넌트를 이용해서 아래에 등록해 나갑니다.   전역은 플러그인이나 라이브러리 형태로 전역으로 사용하는 컴포넌트만 전역으로 등록합니다.   4.5 컴포넌트와 인스턴스와의 관계   새로운 인스턴스를 생성하고 div#app2를 만들어서 인스턴스를 연결하고 전역컴포넌트와 #app에 만들었던 지역컴포넌트 태그를 넣어줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/div&gt; &lt;div id=\"app2\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     // Vue.component('컴포넌트 이름', 컴포넌트 내용);     // 전역 컴포넌트     Vue.component('app-header', {         template: '&lt;h1&gt;Header&lt;/h1&gt;'     });      new Vue({         el: '#app',         components: {             // '컴포넌트 이름': 컴포넌트 내용             'app-footer': {                 template: '&lt;footer&gt;footer&lt;/footer&gt;'             }         }     });      new Vue({         el: '#app2'     }) &lt;/script&gt;   화면에서 확인 하면 app-footer컴포넌트는 #app2에 등록한 지역컴포넌트가 아니기 때문에 보이지 않습니다. 지역컴포넌트는 인스턴스를 생성할 때마다 생성해 줘야 합니다.     ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner4/",
        "teaser": null
      },{
        "title": "5 - 컴포넌트 통신 방법) 기본",
        "excerpt":"5.1 컴포넌트 통신   뷰에서 컴포넌트를 등록했을때 관계가 생깁니다.  예를 들어서 아래 그림과 같이 컴포넌트를 나눴을때를 봅시다.      화면에서 연회색으로 되어있는 3개의 부분으로 나눴을때 그안에 진회색으로 컴포넌트를 나눌때마다 그 컴포넌트가 하위(자식)컴포넌트로 위치합니다.   이 관계의 중요한 점은, 규칙이 생긴다는 것입니다.  컴포넌트는 각각 고유한 데이터 유효 범위를 갖습니다. 따라서 컴포넌트 간에 데이터를 주고 받기 위해선 아래와 같은 규칙을 따라야 합니다.         상위에서 하위로는 데이터를 내려줌, 프롭스 속성   하위에서 상위로는 이벤트를 올려줌, 이벤트 발생   5.2 컴포넌트 통신 규칙이 필요한 이유   예를 들어서 헤더, 컨텐트, 푸터 컴포넌트를 등록하고  그리고 그 컴포넌트 밑에 각각 컴포넌트를 하나씩 등록했다고 합시다.      여기에서 만약 헤더에서 로그인폼으로 데이터를 전달하고, 그 정보를 다시 푸터로 보냅니다.  그리고 푸터에서 다시 네비게이션바로 데이터를 보낸 상황을 가정합니다.  이런식으로 특정 컴포넌트의 변화에 따라서 나머지 컴포넌트가 유기적으로 데이터를 주고받았을때 데이터의 방향을 예측하기가 어려워집니다.  데이터가 바뀌었을떄 그로 인한 버그를 추적하기가 어려운게 n방향 통신의 문제점입니다.   컴포넌트 통신방식을 살펴봅시다.      컴포넌트 통신방식은 데이터가 아래로만 내려갑니다.  데이터의 흐름을 추적할 수 있습니다. 데이터는 항상 내려오고 이벤트는 올라갑니다.   5.3 props 속성   app-header컴포넌트를 만들고 data에 메세지를 정의해주면 Root컴포넌트에 message가 생성됩니다.  이 데이터를 aa-header로 내리려면 props를 사용하면 됩니다.  v-bind:프롭스 속성 이름 = “상위 컴포넌트의 데이터 이름”으로 넣어줍니다.  app-header의 기준으로 상위컴포넌트는 root가 되고 그 데이터 이름은 message입니다.  프롭스 속성 이름은 appHeader라는 변수 안에 정의 해주고 그것을 사용하면 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=\"app\"&gt;     &lt;!-- &lt;app-header v-bind:프롭스속성 이름=\"상위 컴포넌트의 데이터 이름\"&gt;&lt;/app-header&gt; --&gt;     &lt;app-header v-bind:propsdata=\"message\"&gt;&lt;/app-header&gt;     &lt;app-content v-bind:propsdata=\"num\"&gt;&lt;/app-content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;h1&gt;header&lt;/h1&gt;',         props: ['propsdata']              }     new Vue({         el: '#app',         components: {             'app-header': appHeader,         },         data: {             message: 'hi',         }     }) &lt;/script&gt;   뷰 개발자 도구로 확인해 보면 app-header에 propsdata로 들어가 있는 걸 볼 수 있습니다.      5.4 props 속성의 특징   props코드를 등록하면 root컴포넌트(상위컴포넌트)의 message값이 바뀌면 그대로 app-header에도 내려가 반영이 됩니다.  데이터바인딩을 이용하여 상위 컴포넌트의 데이터값이 바뀌면 하위 컴포넌트의 프롭스 속성이 반영되면서 화면에 나타나도록 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &lt;div id=\"app\"&gt;     &lt;!-- &lt;app-header v-bind:프롭스속성 이름=\"상위 컴포넌트의 데이터 이름\"&gt;&lt;/app-header&gt; --&gt;     &lt;app-header v-bind:propsdata=\"message\"&gt;&lt;/app-header&gt;     &lt;app-content v-bind:propsdata=\"num\"&gt;&lt;/app-content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;h1&gt;&lt;/h1&gt;',         props: ['propsdata']              }     var appContent = {         template: '&lt;div&gt;&lt;/div&gt;',         props: ['propsdata']     }     new Vue({         el: '#app',         components: {             'app-header': appHeader,             'app-content': appContent         },         data: {             message: 'hi',             num: 10         }     }) &lt;/script&gt;   5.5 event emit   아래에서 위로 통신하는 법은 이벤트를 올립니다.  이벤트에 대해서 실습해 봅시다.   뷰 인스턴스를 하나 생성하고 app-header컴포넌트를 등록하고 템플릿으로 버튼을 하나 만들어 줍니다.  버튼을 클릭했을때 이벤트를 실행하는 방법은 v-on:click으로 할 수 있습니다.   이 버튼을 클릭했을때 root로 이벤트를 보낼겁니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;button v-on:click=\"passEvent\"&gt;Click me&lt;/button&gt;',         methods: {             passEvent: function() {                 this.$emit('pass');             }         }     }     var vm = new Vue({         el: '#app',         components: {             'app-header': appHeader,         },     }) &lt;/script&gt;   이 상태에서 뷰 개발자 도구로 확인하면 버튼 클릭시 pass 이벤트가 발생합니다.   5.6 event emit으로 콘솔 출력하기   $emit은 뷰에서 제공하는 api(기능)인데 이것을 이용해서 pass라는 이벤트를 발생 시켰습니다.  이것을 위에서 받을 수 있게 컴포넌트 태그에서 조작을 해 보겠습니다.  프롭스 등록과 비슷하게 태그에서 올라온 이벤트를 잡아줘야 합니다.  하위에서 발생한 이벤트 이름은 pass이고 상위 컴포넌트 메서드 이름은 logText로 지정해줍니다.  pass라는 이벤트가 아래에서 올라왔을 때 그게 컴포넌트 태그에서 받아서 logText라는 메서드를 실행합니다.   ++ 추가로 content 넣어보기  똑같이 컴포넌트를 추가해주고, addNumber 이벤트를 추가해봅시다.  add버튼을 클릭했을때 this.$emit으로 이벤트를 올려서 위에 있는 data의 num값을 1씩 증가 시켜보겠습니다.  increase라는 하위 컴포넌트에서 발생한 이벤트 이름을 받아서 상위 컴포넌트의 메서드 increaseNumber를 실행시킵니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 &lt;div id=\"app\"&gt;     &lt;p&gt;&lt;/p&gt;     &lt;!-- &lt;app-header v-on:하위컴포넌트에서 발생한 이벤트 이름=\"상위 컴포넌트 메서드 이름\"&gt;&lt;/app-header&gt; --&gt;     &lt;app-header v-on:pass=\"logText\"&gt;&lt;/app-header&gt;     &lt;app-Content v-on:increase=\"increaNumber\"&gt;&lt;/app-Content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;button v-on:click=\"passEvent\"&gt;Click me&lt;/button&gt;',         methods: {             passEvent: function() {                 this.$emit('pass');             }         }     }     var appContent = {         template: '&lt;button v-on:click=\"addNumber\"&gt;add&lt;/button&gt;',         methods: {             addNumber: function() {                 this.$emit('increase')             }         }     }     var vm = new Vue({         el: '#app',         components: {             'app-header': appHeader,             'app-content': appContent         },         methods: {             logText: function() {                 console.log('hi');             },             increaNumber: function() {                 this.num = this.num + 1             }         },         data: {             num: 10         }     }) &lt;/script&gt;   5.7 뷰 인스턴스에서의 this   obj라는 객체를 생성하고 this를 찍으면 obj를 바라봅니다.   1 2 3 4 5 6 var obj = {     num: 10,     getNumber: function() {         console.log(this.num);     } }  따라서 실습해봤던 코드에서 console.log(vm)을 찍으면 뷰에서 생성한 내용들이 담깁니다.  이것을 펼쳐서 보면 data안에 정의했던 num: 10이 바깥레벨로 나와서 바로 보입니다.  따라서 this.num은 data의 num속성을 가리킵니다.     this 관련글 1  this 관련글 2  ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner5/",
        "teaser": null
      },{
        "title": "vue cli",
        "excerpt":"vue cli로 프로젝트 생성하기   Vue3대신 Vue2를 선택하는 이유는?     안정적이고 무엇보다 Vue3는 explorer를 지원하지 않는다.   manually로 생성하기          default로 생성할때와 다르게 생성할때 정해야할 정책들이 있음       preset : 미리 만들어둔것 가져오기   progressive web app support : 빌드시에 바로가기 아이콘 생성   css pre-proessors : css 전처리기   unit-testing ; 단위 테스팅   E2E testing   class-style component : 클래스 스타일 사용할건지? (사용안함)   history mode : url에 해쉬태그를 없애는 건데 새로고침이나 url을 입력하고 엔터를 치면 404에러가 발생한다.  이유는 vue는 spa인데 이는 router로 페이지 이동할때 페이지 이동처럼 보이지만 서버에 요청해서 받은게 아니고 한페이지에서 컴포넌트만 갈아끼우고 url 변경하는 형식인데 새로고침, 엔터시 에러가 발생하는것은 서버로 get요청을 보내기 때문에 받아올게 없기 때문이다. (cli로 만들면 문제는 없다는듯)   config : 설정파일   core.js : 바벨에서 es5로 전환할때 그냥 할 수 없는 것들이 있음(예를들어 Promise) 이것들은 폴리필이라는 코드조각을 사용해야 하는데 이 코드 조각들의 모음   ","categories": ["vue-study"],
        "tags": ["cli"],
        "url": "/vue-study/fe-vue-cli/",
        "teaser": null
      },{
        "title": "vue intersection observer로 infinite scroll 구현하기",
        "excerpt":"intersection observer   참고페이지1 참고페이지1      사용자가 감시하고자 하는 페이지의 요소가 특정 요소(브라우저의 viewport)와 교차되는 정도를 관찰하고, 설정해둔 비율 이상의 교차가 일어났을 떄 실행되어야 하는 콜백 함수를 등록   1 2 3 4 5 6 7 8 // mdn 예제 코드 let options = {   root: document.querySelector('#scrollArea'),   rootMargin: '0px',   threshold: 1.0 }  let observer = new IntersectionObserver(callback, options);     root 옵션은 null로 지정해두면 기본적으로 브라우저 viewport를 이용   rootMargin은 css margin과 비슷한 속성이며, root 속성의 여백을 의미   threshold는 intersection observer가 observe하는 target이 root옵션에서 지정한 요소(혹은 브라우저 viewport)와 얼마나 교차했을 때 콜백함수를 트리거 하는지 결정하는 옵션(0~1 1은 100%)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //triggerObserver.vue  &lt;template&gt;   &lt;div ref=\"triggerDiv\"&gt;_&lt;/div&gt; &lt;/template&gt;  &lt;script&gt; export default {   data() {     return {       observer: null,       option: {         root: null,         threshold: 1,       },     };   },   methods: {     handleIntersect: function (target) {       if (target.isIntersecting) this.$emit(`triggerFadeIn`);     },   },   mounted() {     this.observer = new IntersectionObserver((entries) =&gt; {       this.handleIntersect(entries[0]);     }, this.option);     this.observer.observe(this.$refs.triggerDiv);   }, }; &lt;/script&gt;  &lt;style scoped&gt; div {   opacity: 0; } &lt;/style&gt;      triggerObserver라는 컴포넌트를 만들고 다른 컴포넌트에서 재활용   intersection observer가 observe할 의미 없는 요소를 하나 생성하기 -&gt; &lt;div ref=\"triggerDiv\"&gt;_&lt;/div&gt;   observe할 요소는 null로 지정하여 브라우저 viewport를 이용   threshold는 1로 지정하여 해당 div 태그가 브라우저에 전부 표시되었을 때 trigger를 발동   이 컴포넌트는 observe만을 위해 존재하므로 애니메이션 발생과 관련한 구체적인 코드는 작성하지 않고, 해당 구현을 부모 컴포넌트에 위임 -&gt; this.$emit(triggerFadeIn); 부모 컴포넌트로 이벤트 emit            handleIntersect 메소드 -&gt; 특정 target이 옵션에 지정된 대로 root 요소와 교차되었을 때 수행하는 행동 정의           observe할 target를 넘겨주는게 중요            observe(this.$refs.triggerDiv)형태로 넘김 -&gt; Vue의 ref를 이용       그냥 document.querySelector를 이용해서 target을 골라서 넘겨줬다면, 재사용을 위해 만들어진 컴포넌트임에도 불구하고 재사용할때마다 선택된 dom요소만 등록되기 때문에 컴포넌트 재사용이 불가능하다.           1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 부모 컴포넌트 &lt;template&gt;   &lt;transition v-on:enter=\"enter\"&gt;     &lt;div v-if=\"show\" ref=\"dreamWrapper\" class=\"dreamWrapper\"&gt;       &lt;h2&gt;MY DREAM&lt;/h2&gt;       &lt;section&gt;         ... (중략) ...         &lt;DreamObserver v-on:triggerFadeIn=\"fadeIn\"&gt;&lt;/DreamObserver&gt;         ... (중략) ...       &lt;/section&gt;     &lt;/div&gt;   &lt;/transition&gt; &lt;/template&gt;  &lt;script&gt; import TriggerObserver from \"./observers/TriggerObserver.vue\"; export default {   name: \"MyDream\",   components: {     DreamObserver: TriggerObserver,   },   data() {     return {       show: false,     };   },   methods: {     enter: function (el) {       el.style.opacity = 0;     },     fadeIn: function () {       this.$refs.dreamWrapper.style = \"transition: opacity 1s\";     },   },   mounted() {     this.show = true;   }, }; &lt;/script&gt;   예제 코드 보러가기 github infinite scroll  ","categories": ["vue-study"],
        "tags": ["vuex","intersection observer","infinite scroll"],
        "url": "/vue-study/fe-vue-infinite-scroll/",
        "teaser": null
      },{
        "title": "vue router - path variable",
        "excerpt":"vue에서 router 이동을 코드로 어떻게 구현하는가      router.push({})로 구현   공지사항 상세보기에서 수정하기 페이지로 이동할때      라우터 설정시에 path: 'edit/:NO_NTC/:isEdit',로 설정해주고(path variable)   url이 notice/edit/0HlVn6NilcOOyBqKFordeg==/true 이런식으로 이동, 그 값을 이용해서 새로고침시에 api를 재호출 시킴   :NO_NTC, :isEdit는 NoticeView.vue에서 아래와 같이 넘겨줌     1 2 3 4 5 6 7 8 9 10 11 12 13 const moveNoticeUpdate = async val =&gt; {   const res = await encrypt(NO_NTC.value as string);   await router.push({       name: 'NoticeEdit',       params: {           NO_NTC: res,           editData: val,           isEdit: 'true',           NM_SITE: selectSiteParam.value.name,           CD_SITE: selectSiteParam.value.code,       },   }); };           새로고침시에 api 재호출은?   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 const createInit = async () =&gt; {     // 리스트에서 진입시 현장명/현장코드 들고오기     if (route.params.editData) { // 처음 수정하기 페이지로 들어왔을때는 route.params.editData값을 가지고 있어서 여기가 실행됨         selectSite.value = { ...selectSite.value, ...route.params };         isEdit.value = !!selectSite.value.isEdit;     } else { // 새로고침하면 params값이 날라가서 여기가 실행됨         const { NO_NTC = '', isEdit: edit = '' } = route.params; // route.params에 비구조화할당으로 NO_NTC와 isEdit에 path variable로 넘어온 값을 넣어줌(isEdit: edit는 isEdit를 edit로 변환 / 그리고  = ''은 값이 없으면 빈문자열을 넣어주라는 default값)         if (edit) { // isEdit가 true면 여기가 실행              const res = await decrypt(NO_NTC);             await API_FN_000032({                 P_NO_NTC: res,             });              if (gettersFN_000032.value) {                 selectSite.value = {                     ...selectSite.value,                     editData: {                         ...gettersFN_000032.value[0],                     },                 };             }              isEdit.value = !!edit;         } else {             selectSite.value = {                 ...selectSite.value,                 NM_SITE: route.params.NM_SITE,                 CD_SITE: route.params.CD_SITE,             };         }     }      await initApi(); };  createInit();   ","categories": ["vue-study"],
        "tags": ["path variable","router"],
        "url": "/vue-study/fe-vue-router1/",
        "teaser": null
      },{
        "title": "vue에서 scss 사용하기",
        "excerpt":"vue에서 scss 사용 기본 설정   scss 패키지 설치  node-sass와 sass-loader 설치   yarn add node-sass -D yarn add sass-loader -D   사용법  간단한 설치만으로도 vue-loader에서 기본으로 설정되어있는 webpack 설정 때문에 패키지 설치 후 컴포넌트 내에서 lang속성을 지정해주면 자동으로 Loader를 사용 할 수 있음   1 2 3 4 5 6 // 컴포넌트 내에 lang속성으로 scss 명시 // 스타일 내부 scss 파일 import하는 방법 // 경로에서 @의 경우 /src와 같은 의미 &lt;style lang=\"scss\"&gt;     @import \"@/asstes/scss/파일명\"; &lt;/style&gt;   전역 스타일 및 변수 설정 변수를 담아둔 scss 파일을 매번 컴포넌트에서 불러와 사용하는 것은 효율적이지 않음  따라서 자주 사용하는 변수나 reset스타일, mixin같은 경우 전역 스타일을 설정해서 사용 가능   설정방법  vue.config.js 파일 생성해서 webpack 설정을 추가   1 2 3 4 5 6 7 8 9 10 11 module.exports = {     css: {         loaderOptions: {             sass: {                 additionalData: `                     @import \"@/assets/scss/abstracts/abstracts.scss\";                 `             }         }     } }   1 2 3 4 5 6 7 8 9 //예시 $TEXT_DEFAULT: #333;  //다른컴포넌트 &lt;style lang=\"scss\"&gt;     p {         color: $TEXT_DEFAULT     } &lt;/style&gt;  ","categories": ["vue-study"],
        "tags": ["scss"],
        "url": "/vue-study/fe-vue-scss/",
        "teaser": null
      },{
        "title": "vuex helper 함수",
        "excerpt":"vuex 기본구조   validation-observer : 전체 범위   validation-provider : 개별   현장명이 하나일때는 필수값 검사를 안해도 됨 -&gt; 값이 바로 들어오기때문에  현장명이 여러개 일때를 validation-provider로 묶어줌  ** 검사해야 될 컴포넌트가 v-model식으로 작동해야함   -&gt; utils &gt; validate.ts에서 required 필수값 내제되어 있음 이 함수를 꺼내와서 메세지를 전달 할 수 있다.   -&gt; main.ts에 임포트 해서 전역으로 사용하도록 함   렌더링원리 공부하기   for문에서 key값을 쓰는 이유? key값이 없으면…   spa가 랜더링이 빠른이유는? 가상돔에서 처리하기때문에  가상돔을 사용하면 빠른이유는? 메모리단계에서 기억하고 계산하기 때문에 빠르다.  ","categories": ["vue-study"],
        "tags": ["vuex","helper","namespace"],
        "url": "/vue-study/fe-vue-validation/",
        "teaser": null
      },{
        "title": "vue.js 프로젝트 구조 : views와 components의 차이",
        "excerpt":"vue.js 프로젝트 구조   views폴더와 components폴더의 차이는  router에서 보여주는 component파일은 views폴더에 넣고, 그 외에는 components폴더에 넣는다.  (폴더 구조는 사실 어떻게 하든 상관없지만, vue cli가 제시하는 예시이다.)   ","categories": ["vue-study"],
        "tags": ["views","components"],
        "url": "/vue-study/fe-vue-views-components/",
        "teaser": null
      },{
        "title": "vuex helper 함수",
        "excerpt":"vuex 기본구조      vuex 흐름      store 생성 : 통합 저장소   1 2 3 4 5 6 7 8 const store = new Vuex.Store({   state: {     count: 0   },   getters: {},   actions: {},   mutations: {} })      Vuex를 Vue 컴포넌트에 가져오기   1 2 3 4 5 6 7 8 9 // 'Counter' 컴포넌트를 만듭니다 const Counter = {   template: `&lt;div&gt;8&lt;/div&gt;`,   computed: {     count () {       return store.state.count     }   } }      getters   Vuex는 getters를 store 안에 정의하는것을 허락 getters는 저장소 state의 값을 기반으로 state의를 계산해야 할 때 사용 computed 속성처럼 getter의 결과는 종속성(dependencies)에 따라 캐쉬되고, 일부 종속성이 변경된 경우에만 다시 재계산   속성유형 접근 방법  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const store = new Vuex.Store({   state: {     todos: [       { id: 1, text: '...', done: true },       { id: 2, text: '...', done: false }     ]   },   getters: {     // 첫 번째 전달 인자로 상태(state)를 받음     doneTodos: state =&gt; {       return state.todos.filter(todo =&gt; todo.done)     },     // state와 다른 getter도 받을 수 있습니다.     doneTodosCount: (state, getters) =&gt; {       return getters.doneTodos.length     }   } })   메소드 유형 접근 방법  함수를 반환하여  getters 에 전달인자로 전달가능  저장소의 배열을 검색할때 특히 유용, 메서드를 통해 접근하는 getter는 호출 할 때마다 실행되며 결과가 캐시되지 않는다는 것을 유의하기  1 2 3 4 5 6 getters: {   // ...   getTodoById: (state) =&gt; (id) =&gt; {     return state.todos.find(todo =&gt; todo.id === id)   } }      map Helper   헬퍼 함수에는 mapState(),  mapGetters(),  mapMutations(), mapActions() 가 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 독립 실행 형 빌드에서 헬퍼가 Vuex.mapState로 노출됩니다. import { mapState } from 'vuex'  export default {   // ...   computed: mapState({     // 화살표 함수는 코드를 매우 간결하게 만들어 줍니다!     count: state =&gt; state.count,      // 문자열 값 'count'를 전달하는 것은 `state =&gt; state.count`와 같습니다.     countAlias: 'count',      // `this`를 사용하여 로컬 상태에 액세스하려면 일반적인 함수를 사용해야합니다     countPlusLocalState (state) {       return state.count + this.localCount     },          // 매핑 된 계산된 속성의 이름이 상태 하위 트리 이름과 같을 때 문자열 배열을 ```mapState```에 전달     'count'   }) }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 저장소 getter를 로컬 computed속성에 매핑합니다. getter를 다른이름으로 매핑하려면 객체를 사용하면 됩니다. import { mapGetters } from 'vuex'  export default {   // ...   computed: {     // getter를 객체 전개 연산자(Object Spread Operator)로 계산하여 추가합니다.     ...mapGetters([       'doneTodosCount',       'anotherGetter',       // ...     ])   } }       mutations   1 2 3 4 5 6 7 8 9 10 11 const store = new Vuex.Store({   state: {     count: 1   },   mutations: {     increment (state) {       // 상태 변이        state.count++     }   } })   commit()  store.commit()에 추가 전달인자를 사용해서 mutations를 호출(동기적 async여야 함) 참고페이지  1 store.commit('increment', 10)      actions   Actions는 Mutation과 유사  상태를 변화시키는 대신 Actions에서 Mutations에 대한 commit()(Mutation내부의 메서드를 실행)을 하는것과,  작업에 임의의 비동기 작업이 포함될 수 있다는 점이 다름   1 2 3 4 5 6 7 8 const store = new Vuex.Store({   ...   actions: {     increment (context) {       context.commit('increment')     }   } })   dispatch()  store.commit()은 동기적이지만 store.dispatch()는 비동기작업도 가능   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... actions: {     // 객체와 함께 디스패치     store.dispatch({       type: 'incrementAsync',       amount: 10     })          // 내부에 또다른 액션을 만들 수 있음     store.dispatch('actionA').then(() =&gt; {         commit('someOtherMutation')     })          // async/await 사용 가능     async actionB({commit){         commit('gotData', await getData())     },     async actionC({ dispatch, commit }) {         await dispatch('actionA')   // actionA가 끝나기를 기다립니다.         commit('gotOtherData', await getOtherData())     } }   Module   여러개의 저장소를 모듈로 나눌 수 있다. 각 모듈은 자체 state, mutation, action, getter 및 모듈을 중첩하여 포함 할 수도 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const moduleA = {   state: { ... },   mutations: { ... },   actions: { ... },   getters: { ... } }  const moduleB = {   state: { ... },   mutations: { ... },   actions: { ... } }  const store = new Vuex.Store({   modules: {     // import 도 가능     a: moduleA,     b: moduleB   } })  store.state.a // -&gt; moduleA'의 상태 store.state.b // -&gt; moduleB'의 상태   네임스페이스   기본적으로 module 내의 actions, mutations, getter 는 전역 네임 스페이스 로 등록   네임스페이스의 getter와 actions 는 지역화된 getters ,  dispatch , commit  을 받습니다. 즉, 동일한 모듈 안에서 접두어 없이 모듈 자산을 사용  모듈이 독립적이거나 재사용되길 원할 경우 namespaced: true 를 설정  만약 큰 프로젝트 작업시 네임스페이스를 사용하는것이 좋다.   1 2 3 4 5 6 const store = new Vuex.Store({   modules: {     ...     namespaced: true   } })   네임스페이스 모듈 내부에서 자산 접근   전역 네임스페이스의 action을 dispatch하거나 mutation을 commit 하려면 dispatch ,  commit  에 3번째 인자로  { root : true }  를 전달   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 modules: {   foo: {     namespaced: true,      getters: {       // `getters`는 해당 모듈의 지역화된 getters       // getters의 4번째 인자를 통해서 rootGetters 사용 가능       someGetter (state, getters, rootState, rootGetters) {         getters.someOtherGetter // -&gt; 'foo/someOtherGetter'         rootGetters.someOtherGetter // -&gt; 'someOtherGetter'       },       someOtherGetter: state =&gt; { ... }     },      actions: {       // 디스패치와 커밋도 해당 모듈의 지역화된 것       // 전역 디스패치/커밋을 위한 `root` 옵션 설정 가능       someAction ({ dispatch, commit, getters, rootGetters }) {         getters.someGetter // -&gt; 'foo/someGetter'         rootGetters.someGetter // -&gt; 'someGetter'          dispatch('someOtherAction') // -&gt; 'foo/someOtherAction'         dispatch('someOtherAction', null, { root: true }) // -&gt; 'someOtherAction'          commit('someMutation') // -&gt; 'foo/someMutation'         commit('someMutation', null, { root: true }) // -&gt; 'someMutation'       },       someOtherAction (ctx, payload) { ... }     }   } }   네임스페이스 모듈에서 전역 액션을 등록하려면, root : true root : true  를 표시하고 handler handler  함수에 액션을 정의하면 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 {   actions: {     someOtherAction ({dispatch}) {       dispatch('someAction')     }   },   modules: {     foo: {       namespaced: true,        actions: {         someAction: {           root: true, // 👀           handler (namespacedContext, payload) { ... } // -&gt; 'someAction'         }       }     }   } }   Helper에서  namespaced가 설정된 module 바인딩   mapState   ,  mapGetters  ,   mapActions   그리고  mapMutations  헬퍼에서 네임스페이스 모듈을 컴포넌트에 바인딩 할 때 조금 장황하게 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 computed: {   // 방법 1   ...mapState({     a: state =&gt; state.some.nested.module.a,     b: state =&gt; state.some.nested.module.b   })      // 단순화된 방법 2   ...mapState('some/nested/module', {   \ta: state =&gt; state.a,     b: state =&gt; state.b   }) }, methods: {   // 방법 1   ...mapActions([     'some/nested/module/foo', // -&gt; this['some/nested/module/foo']()     'some/nested/module/bar'  // -&gt; this['some/nested/module/bar']()   ])      // 단순화된 방법 2   ...mapActions('some/nested/module', [     'foo', // -&gt; this.foo()     'bar' // -&gt; this.bar()   ]) }   네임스페이스가 지정된 모듈에 접근   1 2 3 this.$store.commit('namespace/MUTATION_NAME', payload) this.$store.dispatch('namespace/actionDispatch') this.$store.state.patch.stateLists   createNameSpacedHelpers 를 사용하여 네임스페이스 헬퍼 생성하여 바인딩   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { createNamespacedHelpers } from 'vuex'  const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')  export default {   computed: {     // `some/nested/module`에서 찾음     ...mapState({       a: state =&gt; state.a,       b: state =&gt; state.b     })   },   methods: {     // `some/nested/module`에서 찾음     ...mapActions([       'foo',       'bar'     ])   } }   개발자가 개발한 특정 모듈을 위해서 만든 플러그인을 사용자가 Vuex 저장소에 등록할 때 예측할 수 없는 네임스페이스 오류를 주의해야 함. 플러그인 사용자가 특정 모듈을 네임스페이스 모듈 하위에 추가하면 해당 모듈도 동일한 네임스페이스로 등록됨. 이러한 상황을 피하기 위해서 플러그인 옵션을 통해 네임스페이스 값을 전달받을 수 있어야 함.   동적 모듈 등록   store.registerModule()  메소드로 저장소가 생성 된 후에 모듈을 등록   1 2 3 4 5 6 7 8 9 10 store.registerModule('myModule', {   // ... })  // `nested/myModule` 중첩 모듈 등록 store.registerModule(['nested', 'myModule'], {   // ... })  // 모듈의 상태는 store.state.myModule 와 store.state.nested.myModule 로 노출 됩니다.   store.unregisterModule()  을 사용하여 동적으로 등록 된 모듈을 제거할 수도 있습니다. 이 방법으로는 정적 모듈(저장소 생성시 선언 됨)을 제거 할 수 없다.   새 모듈을 등록할 때 이전 상태를 유지하고자 할 수 있다. preserveState  옵션을 사용하면 그렇게 할 수 있다. store.registerModule('a', module, { preserveState: true})   모듈 재사용   때로는 한 모듈에서 여러 인스턴스를 생성해야 할 수도 있다.   일반 객체를 사용하여 모듈의 상태를 선언하면 상태 객체가 참조에 의해 공유되고 변이 될 때 교차 저장소/모듈의 상태 오염을 일으킨다.   이것은 Vue 컴포넌트 내부의 data와 동일한 문제. 해결책도 역시 동일. 함수를 사용하여 모듈 상태를 선언   1 2 3 4 5 6 const MyReusableModule = {   state: () =&gt; ({     foo: 'bar'   }),   // 변이, 액션, getters... }   ","categories": ["vue-study"],
        "tags": ["vuex","helper","namespace"],
        "url": "/vue-study/fe-vue-vuex-helper/",
        "teaser": null
      },{
        "title": "6 - 컴포넌트 통신 방법) 응용",
        "excerpt":"6.1 같은 컴포넌트 레벨 간의 통신 방법   같은 레벨의 컴포넌트 간의 통신 방법에 대해서 알아 보겠습니다.  Root(인스턴스)에서 appHeader와 appContent라는 컴포넌트를 등록했을때 컨텐트에서 헤더로 10이라는 데이터를 전달해 보겠습니다.      6.2 같은 컴포넌트 레벨 간의 통신 방법 구현   new Vue로 인스턴스를 생성하고 el로 #app에 붙이면 인스턴스가 div태그안에서 유효하게 됩니다.  components라는 속성으로 appHeader와 appContent 컴포넌트를 만들어줍니다.  구조도 처럼 컨텐트에서 헤더로 10을 넘기겠습니다.  content에서 버튼을 넣고 이 버튼을 누르면 신호를 발생 시킬겁니다.  그러면 methods를 정의하고 버튼을 클릭했을때 passNum이라는 이벤트를 발생시키고 함수를 이어줍니다.  this.$emit으로 pass라는 이벤트와 10을 넘겨주고 화면에서 확인하면 뷰 개발자 도구 이벤트탭에서 pass 이벤트가 발생하면서 10이 넘어옵니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-content&gt;&lt;/app-content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;div&gt;header&lt;/div&gt;',     }     var appContent = {         template: '&lt;div&gt;content&lt;button v-on:click=\"passNum\"&gt;pass&lt;/button&gt;&lt;/div&gt;',         methods: {             passNum: function() {                 this.$emit('pass', 10)             }         }     }     new Vue({         el: '#app',         components: {             'app-header': appHeader,             'app-content': appContent         },     }) &lt;/script&gt;      content에서 바로 header로 이벤트를 보낼 수 없기 때문에 content에서 root로 event를 통해서 10을 보내고 root에서 header로 props로 10을 다시 내려야 합니다.      root에서 props를 내리려면 데이터를 선언하여야 합니다.  content에서 passNum이라는 메서드가 실행되면서 this.$emit으로 pass이벤트가 올라왔는데 v-on으로 pass 이벤트를 받을 수 있습니다.  하위 컴포넌트 이벤트를 v-on으로 받아서 상위 컴포넌트 인스턴스에 메서드로 추가한 deliverNum를 연결해 줍니다. pass로 넘어오면서 인자 10도 같이 넘어옵니다. 이 인자 10은 받는 쪽에서 deliverNum(value)로 넣어줍니다.  넘어온 value를 this.num = value로 넣어줄 수 있습니다.  pass 버튼을 눌러서 이벤트가 발생하면 Root의 num이 10으로 바뀝니다.  이렇게 넘어온 데이터를 appHeader로 전달해 주면 됩니다.  v-bind로 props속성을 넣어줍니다.   화면에서 content의 porpsdata가 0이었다 버튼을 클릭하면 10으로 바뀌는 것을 확인 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;div id=\"app\"&gt;         &lt;app-header v-bind:propsdata=\"num\"&gt;&lt;/app-header&gt;         &lt;app-content v-on:pass=\"deliverNum\"&gt;&lt;/app-content&gt;     &lt;/div&gt;     &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;     &lt;script&gt;         var appHeader = {             template: '&lt;div&gt;header&lt;/div&gt;',             props: ['propsdata']         }         var appContent = {             template: '&lt;div&gt;content&lt;button v-on:click=\"passNum\"&gt;pass&lt;/button&gt;&lt;/div&gt;',             methods: {                 passNum: function() {                     this.$emit('pass', 10)                 }             }         }         new Vue({             el: '#app',             components: {                 'app-header': appHeader,                 'app-content': appContent             },             data: {                 num: 0             },             methods: {                 deliverNum: function(value) {                     this.num = value;                 }             }         })     &lt;/script&gt;  ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner6/",
        "teaser": null
      },{
        "title": "7 - 라우터",
        "excerpt":"7.1 뷰 라우터 소개와 설치   뷰 라우터는 뷰 라이브러리를 이용하여 싱글 페이지 애플리케이션을 구현할 때 사용하는 라이브러리입니다.   라우터 공식 문서 링크   위 링크로 접속하여 Installation에서 상단의 CDN주소를 복사해 줍니다.      https://unpkg.com/vue-router/dist/vue-router.js   파일을 만들어 보며 실습해 봅시다.  뷰 라이브러리와 router.js CDN 주소를 넣어주고 기본 골격을 만들어 봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     new VueRouter({      });      new Vue({         el: '#app',     }); &lt;/script&gt;   7.2 뷰 라우터 인스턴스 연결 및 초기 상태 안내   뷰 라우터를 인스턴스에 동작 시켜 보겠습니다.  VueRouter를 router라는 변수에 넣어주고 Vue인스턴스에 연결해 주고 브라우저에서 뷰 개발자 도구로 확인해 보면 Root에 $router가 잡히는 것을 볼 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var router = new VueRouter({      });      new Vue({         el: '#app',         router: router,     }); &lt;/script&gt;   7.3 routes 속성 설명 및 실습 안내   세팅한 코드로 라우터에 대한 정보를 추가 해 보겠습니다.  첫번째로 routes라는 속성입니다.  이 속성에는 페이지 라우팅 정보가 들어갑니다. (어떤 url로 이동했을때 어떤 페이지가 뿌려질지에 대한 정보가 배열로 담깁니다.)  이 배열에 페이지 라우팅 정보를 담아보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var LoginComponent = {         template: '&lt;div&gt;login&lt;/div&gt;'     }     var MainComponent = {         template: '&lt;div&gt;main&lt;/div&gt;'     }     var router = new VueRouter({         routes: [             {                 // url 이름                 path: '/login',                 // 해당 url에서 표시될 컴포넌트                 component: LoginComponent             },             {                 path: '/main',                 component: MainComponent             }         ]     });      new Vue({         el: '#app',         router: router,     }); &lt;/script&gt;   7.4 라우터가 표시되는 영역 및 router-view 태그 설명   페이지 url이 변경 됐을때 그 url에 따라서 뿌려지는 영역을 router-view라는 태그로 정의할 수 있습니다. 뷰 인스턴스에 라우터 인스턴스를 연결해야 사용할 수 있습니다.  router-view를 연결하고 url에 /login을 입력해 보면 login이라는 내용이 화면에 보여집니다.  login이라는 url로 이동했을때 해당하는 컴포넌트를 router-view라는 태그에 보여준 것 입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;div id=\"app\"&gt;     &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var LoginComponent = {         template: '&lt;div&gt;login&lt;/div&gt;'     }     var MainComponent = {         template: '&lt;div&gt;main&lt;/div&gt;'     }     var router = new VueRouter({         routes: [             {                 // url 이름                 path: '/login',                 // 해당 url에서 표시될 컴포넌트                 component: LoginComponent             },             {                 path: '/main',                 component: MainComponent             }         ]     });      new Vue({         el: '#app',         router: router,     }); &lt;/script&gt;   7.5 링크를 이용한 페이지 이동 및 router-link 태그 설명   화면 이동을 url로 할 수 있지만, 사용자 입장에서는 화면에 제공된 링크를 통해 이동합니다.  이럴때 사용하는 것이 router-link입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 &lt;div id=\"app\"&gt;     &lt;div&gt;         &lt;router-link to=\"/login\"&gt;Login&lt;/router-link&gt;         &lt;router-link to=\"/main\"&gt;Main&lt;/router-link&gt;             &lt;/div&gt;     &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var LoginComponent = {         template: '&lt;div&gt;login&lt;/div&gt;'     }     var MainComponent = {         template: '&lt;div&gt;main&lt;/div&gt;'     }     var router = new VueRouter({         // 페이지의 라우팅 정보         routes: [             {                 // 페이지의 url 이름                 path: '/login',                 // 해당 url에서 표시될 컴포넌트                 component: LoginComponent             },             {                 path: '/main',                 component: MainComponent             }         ]     });      new Vue({         el: '#app',         router: router     }); &lt;/script&gt;   7.6 라우터 정리 및 학습 방향 안내   라우터는 페이지를 이동할때 사용하는 라이브러리입니다.   CDN 방식  1 &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  NPM 방식  1 npm install vue-router   뷰 라우터 등록  뷰 라우터를 설치하고 나면 라우터 인스턴스를 생성하고, 인스턴스에 라우터 인스턴스를 등록합니다.  1 2 3 4 5 6 7 8 9 // 라우터 인스턴스 생성 var router = new VueRouter({     // 라우터 옵션 })  // 인스턴스에 라우터 인스턴스 등록 new Vue ({     router: router })   라우터 옵션  routes : 페이지의 정보들이 들어가는 속성 / component는 무조건 하나이기 때문에 s가 붙지 않음 (덧붙여서 인스턴스나 컴포넌트는 여러개가 들어가기때문에 component에 s가 붙음)   뷰 라우터로 특정 URL에 접근할 때 접근을 막는 방법(ex.로그인 전에는 접근 불가하게..)     네비게이션 가드 참고 링크  ","categories": ["vue-lv1"],
        "tags": ["vue","router"],
        "url": "/vue-lv1/vue-beginner7/",
        "teaser": null
      },{
        "title": "8 - HTTP 통신 라이브러리 axios",
        "excerpt":"8.1 HTTP 라이브러리와 Ajax 그리고 Vue Resource   axios는 vue에서 권고하는 HTTP통신 라이브러리 입니다.   Ajax는 비동기 적인 웹애플리케이션의 제작을 위한 기술입니다.  과거에는 서버에 데이터를 요청하면 서버에서 페이지까지 그려서 사용자의 브라우저로 보냈기 때문에 페이지가 깜박거리고 다시 로딩되는 현상이 있었습니다.   하지만 요즘엔 서버에서 데이터만 보내주고 화면에 그리는건 브라우저에서 하기 때문에 데이터가 바뀐 부분만 화면이 바뀌게 되어서 사용자 경험이 훨씬 좋아졌습니다.      원래 vue.js에서 확인할 수 있는 공식 라이브러리로 vue-resource가 있었는데 vue.js를 만든 Evan You가 이제 더이상 공식 라이브러리로 관리 하지 않겠다고 했습니다.  실제로 구현 하다 보면 샘플들이 있을텐데 이 샘플들이 vue-resource로 되어있는 것들이 많을것입니다.  그 샘플들을 오래 됐을 확률이 크기 때문에 그런 부분들을 인지하고 주의해서 구현하는 것이 좋습니다.    axios에 대해 살펴 보겠습니다.   8.2 axios 소개 및 오픈 소스를 사용하기 전에 알아야 할 것들   뷰에서 권고하는 HTTP통신 라이브러리는 Axios입니다. Promise기반의 HTTP통신 라이브러리이며 상대적으로 다른 HTTP통신 라이브러리들에 비해 문서화가 잘되어 있고 API가 다양합니다.   axios github을 검색하여 들어가봅시다.   오픈소스를 사용할때는 제일 먼저 봐야하는것이 Star수를 확인해야 합니다. 그만큼 많은 사람들이 이걸 확인하고 좋아요를 눌렀다는 의미입니다.  대중적인 인지도를 파악하고나면 두번째로 commits기록과 contriutors 숫자를 확인하는것도 중요합니다.  몇명의 사람들이 이 라이브러리를 수정하고 개선하기 위해 동참하고 있는지, 얼마나 많이 업데이트 되어 왔는지를 확인 할 수 있습니다.  마지막으로 각 폴더와 파일이름 옆에 커밋 이력을 보시면 이 라이브러리가 언제 수정되었는지 커밋 이력들을 통해서 이 라이브러리가 활성화 되어있는지 확인하시면 됩니다.      axio의 특징을 볼텐데 Promise based HTTP client for the browser and node.js라고 쓰여 있습니다.  프로미스란 자바스크립트의 비동기 처리 패턴을 의미합니다.   자바스크립트의 비동기 처리 패턴     callback   promise   promise + generator   async  &amp; await   자바스크립트 비동기 처리와 콜백 함수  자바스크립트 promise 이해하기  자바스크립트 async와 await   이 화면을 내려보시면 실제로 axios가 어떤 브라우저에서 호환이 되는지, 예제, 각각의 api에 대한 설명등이 자세하게 되어있습니다.  이런 부분들 때문에 axios를 사용하는 것이 편합니다.   8.3 axios 실습 및 this 설명   axios를 샘플로 돌려보고 어떤식으로 네트워크요청에 대해서 확인하고 데이터를 뿌리는지 살펴보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             getData: function() {                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response);                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   axios는 CDN으로 연결하였습니다.(github 페이지에서 하단에 installing에 cdn 확인 가능)  여기서 제일 중요한것은 버튼을 클릭했을때 getData라는 메서드를 호출하는 것입니다. 메서드의 axios.get에서 참고하는 url로 이동해보면 사용자정보가 담긴 배열을 볼 수 있습니다.      jsonplaceholder라는 것은 REST API 라는 자바스크립트로 api를 요청할때 테스트해볼 수 있는 사이트입니다.  url로 이동했을때 확인 할 수 있는 데이터는 테스트하면서 기능 구현을 해볼 수 있는 샘플이라고 보면 됩니다.   10개의 유저정보를 받아와서 버튼을 눌렀을때 성공하면 then으로 진입하고 실패하면 catch로 진입합니다.   브라우저 콘솔창에서 확인해보도록 하겠습니다.  get user 버튼을 클릭하면 데이터를 받아옵니다. 서버로 요청이 가고 돌아온 응답입니다.  이중에 가장 필요한 부분은 data라는 속성에 들어있는 사용자 정보입니다.      따라서 data만 콘솔창에 찍어보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             getData: function() {                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response);                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   다시 버튼을 클릭해보면 data가 배열로 넘어옵니다.      받아온 data를 div에 뿌려보겠습니다.  그러려면 data라는 속성을 선언하고 users라는 속성에 빈배열을 넣어줍니다.  그리고 this.users = response.data;를 통해서 받아온 data를 users속성에 넣어줍니다.  여기서 확인할것은 this.users가 과연 data안의 users를 말하는가입니다.  페이지로 돌아가서 확인해봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;      &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     this.users = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;      Root컴포넌트에 users데이터가 빈배열로 들어가있고 버튼을 누르면 콘솔창에 10개의 사용자 정보가 찍히지만 users는 계속 빈배열입니다.   this.users의 this는 axios.get()을 호출하기 전의 this와 다릅니다.   1 2 3 4 5 6 7     getData: function() {         this //1번 this         axios.get(url)             .then(function(response) {                 this.users = response.data; //2번 this             })     }   즉, getData() 에서 바로 호출된 1번 this와 axios.get()이 호출된 후 then 메서드에 의해 비동기적으로 실행된 this는 서로 다른것을 가리킵니다.   getData()의 1번 this는 new Vue()로 생성된 인스턴스 Root컴포넌트를 바라보고, axios.get()으로 호출된 callback function안에서의 2번 this는 비동기적으로 실행되면서 실행컨텍스트가 바뀌어 this가 가리키는 대상도 바뀝니다.   click이벤트로 호출되는 함수도 콜백함수(비동기적으로 실행)이지만 이때는 클릭한 대상(해당 컴포넌트)을 실행컨텍스트의 this에 담아가는 반면, axios.get()처럼 비동기적으로 데이터를 받아온후 콜백함수로 실행되는 function은 해당 function을 실행시킨 주체를 따로 담을게 없어서 window(전역객체)를 실행컨텍스트의 this에 담습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;      &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 console.log(this); //1번 this                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     console.log(this) // 2번 this                     this.users = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   1번 this와 2번 this를 구분해서 콘솔로 찍어서 확인해봅시다.      각각 vue 컴포넌트와 window를 가져오는 것을 볼 수 있습니다.   이에 대한 해결책으로 변수에 this를 먼저 담고, 그 변수를 전달하는 것입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;      &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 // vue 인스턴스를 가리키는 this                 var vm = this;                                  axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     vm = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   화살표함수를 사용하면 변수를 따로 지정하는 대신에 바로 this로 연결 할 수 있습니다.   받아온 사용자 정보를 div에 뿌려보도록 하겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;              &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 // vue 인스턴스를 가리키는 this                 var vm = this;                                  axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     vm = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   8.4 웹 서비스에서의 클라이언트와 서버와의 HTTP 통신 구조      브라우저와 서버의 관계를 살펴보겠습니다.  브라우저에서 HTTP(클라이언트와 서버간의 데이터를 주고받기위한 규칙) 요청을 서버로 보냅니다.  axios.get(‘url’)로 요청을 보냈습니다. 그러면 서버에서는 브라우저로 사용자 데이터를 보냅니다.  이렇게 요청을 보내고 받는것이 HTTP라고 보면 됩니다.   브라우저에서 서버가 어떤식으로 HTTP를 주고받는지 보겠습니다.  브라우저가 서버에 요청을 보냅니다. 그랬을때 서버의 로직을 통해서 DB의 값을 꺼내옵니다.  그 결과물이 서버에서 브라우저로 응답으로 돌아갑니다.      8.5 크롬 개발자 도구 네트워크 패널 보는 방법   크롬 개발자 도구에서 네트워크 패널이 있습니다.    All, XHR, JS, CSS … 등이 있는데 XHR을 통해 비동기 통신에 대해 볼 수 있습니다.  여기에서 get user 버튼을 누르면 HTTP Request가 서버로 날라갑니다.      users를 클릭하면 어떤요청이 서버로 갔고 어떤 응답이 왔는지에 대한 정보들이 뜹니다.  이 패널을 자세히 보면 버그를 잡는데 수월합니다.      첫번째로 Headers엔 General, Response Header, Request Header가 있습니다.  HTTP Header를 의미하는데 여기에는 특정 요청에 대한 정보나 응답에 대한 정보가 담겨있습니다.   General을 보면 Request URL과 Request Method를 보실 수 있습니다. url로 get 요청을 보냈다는 것을 알 수 있습니다.  그리고 status 200을 보면 정상적으로 응답을 받았다는 것을 알 수 있습니다.      Response Headers는 서버에서 어떤 응답을 줬는지에 대한 정보를 담고있습니다.   캐싱이나 etag 등 여러가지 정보들을 담고있습니다.      Request Headers는 브라우저 정보들부터 시작해서 현재 브라우저가 받아줄 수 있는 format이나(Accept) 부가적인 정보들이 들어있고, User Agent는 현재 브라우저에 대한 정보입니다.   axios.get()의 get은 정보를 달라는 요청이기 때문에 Response에는 항상 그 정보가 담겨있습니다.  Preview로 보면 어떤식으로 정보가 담겨 오는지 보기 편합니다.      ","categories": ["vue-lv1"],
        "tags": ["vue","axios"],
        "url": "/vue-lv1/vue-beginner8/",
        "teaser": null
      },{
        "title": "9 - 템플릿 문법 : 기본",
        "excerpt":"9.1 템플릿 문법 소개   뷰의 템플릿 문법이란 뷰로 화면을 조작하는 방법을 의미합니다. 데이터 바인딩과 디렉티브로 나뉩니다.   데이터 바인딩   데이터 바인딩은 뷰 인스턴스에서 정의한 속성들을 화면에 표시하는 방법.  가장 기본적인 방법으로 콧수염 괄호 Mustache Tag 입니다.   1 &lt;div&gt;&lt;/div&gt;   1 2 3 4 5 new Vue({     data: {         message: 'Hello Vue.js'     } })   div태그에 콧수염 괄호를 이용해 뷰 인스턴스의 message 속성을 연결했습니다. 코드를 실행하면 화면에 Hello Vue.js가 출력 됩니다.   디렉티브   뷰로 화면의 요소를 더 쉽게 조작하기 위한 문법입니다.  화면의 조작에서 자주 사용되는 방식들을 모아 디렉티브 형태로 제공하고있습니다. 예를 들어 아래와 같이 특정 속성 값에 때라 화면의 영역을 표시하거나 표시하지 않을 수 있습니다.   1 2 3 &lt;div&gt;     Hello &lt;span v-if=\"show\"&gt;Vue.js&lt;/span&gt; &lt;/div&gt;   1 2 3 4 5 new Vue({     data: {         show: false     } })   위의 코드는 show가 false이기 때문에 Vus.js가 보이지 않습니다.   9.2 데이터 바인딩과 computed 속성   데이터 바인딩에 대해 알아보겠습니다.   html파일을 만들고 기본 코드를 작성하고 인스턴스를 생성하여 el: ‘#app’으로 연결해 줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;div id=\"app\"&gt;      &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             str: 'hi'         }     }) &lt;/script&gt;   브라우저에서 확인해 봅시다.      hi가 찍히는것을 볼 수 있고 data의 str값을 바꾸면 화면에도 바로 반영 되는 것을 확인 할 수 있습니다.      이 값이 연결 되는 구간이 데이터 바인딩이라고 보면 됩니다.   이번에는 num을 넣어서 만들어 보겠습니다.  p태그에 num을 넣고 두번째로 doubleNum을 넣습니다.  num을 정의하고 그 값에 두배를 곱해서 doubleNum을 만들수도 있지만 데이터의 값에 따라서 바뀌는 값을 정의할때 computed를 이용할 수 있습니다.  computed에 doubleNum을 정의하고 this.num(data에 선언했던 num) * 2 를 return합니다.  화면상에 나타나는 doubleNum은 computed속성이고 num이 바뀌었을때 같이 바뀌게 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &lt;div id=\"app\"&gt;     &lt;p&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;   화면에서 확인해보면 num에 10, doubleNum에 20이 들어가 있습니다.      이상태에서 num의 값을 바꾸면 doubleNum의 값도 같이 계산되어서 바뀝니다.      9.3 뷰 디렉티브와 v-bind   뷰 디렉티브에 대해서 보겠습니다. 뷰 디렉티브는 v-가 붙는 특수한 속성들을 말합니다.  첫번째 p태그에 아이디를 id=”abc1234”로 부여하고 데이터로 관리하고 싶을때 인스턴스에 uuid: ‘abc1234’로 정의하고 v-bind로 태그에 연결 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=\"app\"&gt;     &lt;p v-bind:id=\"uuid\" v-bind:class=\"name\"&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,             uuid: 'abc1234',             name: 'text-blue'         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;        Root에 uuid가 정의 되어있고 p태그에 id가 부여된것을 볼 수 있습니다.   9.4 클래스 바인딩, v-if, v-show   동일한 방법으로 class도 연결할 수 있습니다.   또 유용한 디렉티브들을 확인해 보겠습니다.  v-if를 이용해 로그인 여부에 따라 보이는 태그를 만들어 봅시다.   처음에는 loading이 true라서 Loading…태그가 보이고 loading의 체크박스를 해제해서 false로 만들면 v-else의 태그가 보이게 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 &lt;div id=\"app\"&gt;     &lt;p v-bind:id=\"uuid\" v-bind:class=\"name\"&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt;     &lt;div v-if=\"loading\"&gt;         Loading...     &lt;/div&gt;     &lt;div v-else&gt;         test user has been logged in     &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,             uuid: 'abc1234',             name: 'text-blue',             loading: true,         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;        다음으로 v-show를 보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &lt;div id=\"app\"&gt;     &lt;p v-bind:id=\"uuid\" v-bind:class=\"name\"&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt;     &lt;div v-if=\"loading\"&gt;         Loading...     &lt;/div&gt;     &lt;div v-else&gt;         test user has been logged in     &lt;/div&gt;     &lt;div v-show=\"loading\"&gt;         Loading...     &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,             uuid: 'abc1234',             name: 'text-blue',             loading: true,         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;   if와 show둘다 loading이 true인 상태에서는 보여집니다.      체크를 풀어서 false가 되면 보이지 않는데 여기서 요소검사를 해보면,      v-if는 v-if속성이 선언된 div태그를 DOM에서 제거해버리고 v-show는 css적으로 display:none으로 육안상 보이지않게만 합니다.   9.5 모르는 문법이 나왔을 때 공식 문서를 보고 해결하는 방법   인풋 박스를 만들고 입력된 값을 p태그에 출력해봅시다.   먼저 인풋 박스를 만들고 그 밑에 p태그를 만듭니다. 일반적으로 document.querySelector로 input에 접근했었습니다.  그러나 이번에는 Vue에서 제공하는 방법을 이용해 보겠습니다.  인풋에 입력하는 내용을 아래 p태그에 써주고 싶지만 그 기능을 모르는 상황일때는 Vue.js 공식문서에서 찾아볼 수 있습니다.      여기서 form input binding으로 가봅시다.  v-model이라는 것을 알려줍니다. 조금 더 내려보면 예시 코드가 있습니다.      input에 v-model로 message를 넣었고 콧수염괄호로 message를 뿌리는 걸로 봐서는 data라는 것을 추측할 수 있습니다. v-model에 message라는 것을 정의 할 수 있게 data에 message 속성을 빈문자열로 추가하고 input에 v-model로 message를 연결해 줍니다.   그리고 이것을 화면에 바로 보일 수 있도록 p태그에 콧수염 괄호로 넣어줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;div id=\"app\"&gt;     &lt;p v-bind:id=\"uuid\" v-bind:class=\"name\"&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt;     &lt;div v-if=\"loading\"&gt;         Loading...     &lt;/div&gt;     &lt;div v-else&gt;         test user has been logged in     &lt;/div&gt;     &lt;div v-show=\"loading\"&gt;         Loading...     &lt;/div&gt;     &lt;input type=\"text\" v-model=\"message\"&gt;     &lt;p&gt;&lt;/p&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,             uuid: 'abc1234',             name: 'text-blue',             loading: true,             message: '',         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;   9.6 methods 속성과 v-on 디렉티브를 이용한 키보드, 마우스 이벤트 처리 방법   메서드와 메서드를 이용한 이벤트 핸들링에 대해 알아보겠습니다.   버튼을 만들고 버튼을 클릭했을때 이벤트를 처리하는것을 보겠습니다.  v-on:click=”메서드이름” 버튼을 클릭하면 메서드이름이 실행됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"logText\"&gt;click me&lt;/button&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             logText: function() {                 console.log('clicked');             }         }     }) &lt;/script&gt;   화면에서 확인하고 버튼을 클릭하면 콘솔창에 clicked가 찍힙니다.      여기에서 추가로 인풋을 넣고 인풋에서 키보드 입력으로 이벤트를 실행해보겠습니다.  v-on:keyup=\"메서드이름\" keyup은 키보드가 눌렸다가 올라오면 메서드가 실행됩니다.  v-on:keyup.enter=\"메서드이름\" 으로 엔터를 눌렀을때 메서드를 실행 시킬 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"logText\"&gt;click me&lt;/button&gt;     &lt;input type=\"text\" v-on:keyup.enter=\"logText\"&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             logText: function() {                 console.log('clicked');             }         }     }) &lt;/script&gt;  ","categories": ["vue-lv1"],
        "tags": ["vue","template syntax"],
        "url": "/vue-lv1/vue-beginner9/",
        "teaser": null
      },{
        "title": "github.io 블로그 minimal-mistake 사이드 카테고리 만들기",
        "excerpt":"사이드바 카테고리 만들기   왼쪽 사이드바 카테고리 만드는 방법   1) 카테고리 모아두기     pages폴더안에 categories폴더 생성후 category-css, category-javascript 등 카테고리 별로 파일을 생성   title, permalink, 하단 assign posts 수정   archive-single.html에서 카테고리, 태그를 모으는 역할을 하지만 커스텀을 위해 archive-single2.html를 따로 만듦      2) 사이드바로 띄우기     _include폴더에 nav_list_main만들기(확장자 없이)   ul 복사해서 category명과 href경로와 제목 수정  ","categories": ["blog"],
        "tags": ["Jekyll","category","sidebar"],
        "url": "/blog/category/",
        "teaser": null
      },{
        "title": "github.io 블로그 시작하기",
        "excerpt":"jekyll 블로그 시작   무료 Jekyll theme 중 가장 많이 사용되고 있는 “minimal-mistakes”를 사용해서 만들기   디자인도 깔끔하고 제작자가 꾸준히 업데이트를 하고있으며, 많이 사용되고 있는 만큼 참고할 자료도 많을 것으로 보인다.   이글의 제목은 github.io 블로그 시작하기 이고, 오늘은 2021-12-03이다. 앞으로 공부하면서 계속해서 정리해서 올려봐야겠다.   ","categories": ["blog"],
        "tags": ["Jekyll","theme"],
        "url": "/blog/firstpost/",
        "teaser": null
      },{
        "title": "마크다운 문법",
        "excerpt":"마크다운 문법에 대하여   제목을 쓸 때는 #을 이용     #h1  ##h2  ###h3  ####h4  #####h5  ######h6    강조는 각각 &lt;em&gt;, &lt;strong&gt;, &lt;del&gt; 사용   html 태그표현  예)     ```html     &lt;div&gt;   &lt;p&gt;Hello, JEKYLL!&lt;/p&gt;  &lt;/div&gt;    ```    결과)          1 2 3 &lt;div&gt;  &lt;p&gt;Hello, JEKYLL!&lt;/p&gt; &lt;/div&gt;   별표시  예)  1 \\*별표이지, 강조가 아닙니다\\*   결과) *별표이지, 강조가 아닙니다*       변수 입력은 `$var = “JEKYLL”;` 이렇게 합니다.    변수 입력은 $var = \"JEKYLL\"; 이렇게 합니다.     자바스크립트          1 2 3 4 function syntaxHighlight(code, lang) {    var foo = 'hi';    var bar = 1234; }    링크  1 2 3 4 5 6 7 8 9 10 11 12 13 14 [GOOGLE](https://google.com) [NAVER](https://naver.com \"title을 입력해주세요\")  문서안에서 [참조링크]를 그대로 사용 할 수 있습니다. [네이버][naver link] [GitHub][github]  [naver link]: https://naver.com [github]: https://github.com [참조링크]: https://google.com \"google로 이동합니다\"  문서 내 꺽쇠 괄호(&lt; &gt;)안의 URL은 자동으로 링크를 사용합니다. 구글 홈페이지: https://google.com 네이버 홈페이지: &lt;https://naver.com&gt;  GOOGLE  NAVER   문서안에서 참조링크를 그대로 사용 할 수 있습니다.  네이버  GitHub   문서 내 꺽쇠 괄호(&lt; &gt;)안의 URL은 자동으로 링크를 사용합니다.   네이버 홈페이지: https://naver.com     이미지  링크와 비슷한데 앞에 !가 붙습니다.  1 2 3 ![logo](/assets/images/logo2.png \"logo 이미지\") 이미지에 링크 추가 [![naver_logo](/assets/images/naver_logo.png)](https://naver.com \"naver로 이동\")    이미지에 링크 추가       코드 강조  숫자 1번키 옆에 `로 감싸주세요.  1 `code`를 강조 할 수 있습니다.  code를 강조 할 수 있습니다.    인용문  1 2 3 4 5 6 7 8 인용문(blockQuote) &gt; 남의 말이나 글에서 직접 또는 간접으로 따온 문장  &gt; 인용문 작성 &gt;&gt; 중첩된 인용문도 만들 수 있다. &gt;&gt;&gt; 중첩1 &gt;&gt;&gt; 중첩2 &gt;&gt;&gt; 중첩3  인용문(blockQuote)     남의 말이나 글에서 직접 또는 간접으로 따온 문장       인용문 작성         중첩된 인용문도 만들 수 있다.             중첩1  중첩2  중첩3            ","categories": ["blog"],
        "tags": ["markdown"],
        "url": "/blog/md/",
        "teaser": null
      },{
        "title": "GitHub 글 쓰기",
        "excerpt":"GitHub 블로그 글 등록하기   첫 글을 등록해보자.   지킬은 정해진 포맷에 맞춰 글을 등록해야 하는데, _posts폴더에 md확장자로 등록한다.   처음에는 _posts폴더가 없으므로 만들어야 한다. _posts폴더를 생성한후 파일명의 형식은 year-month-day-제목.md 로 파일을 생성한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ---  title: \"github.io 블로그 시작하기\"  excerpt: \"GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.\"  last_modified_at: 2021-12-03 categories:      - Blog  tags:      - Jekyll     - theme      - Blog  ---  ## jekyll 블로그 시작   테마는 가장 많이 사용되고 있는 \"minimal-mistakes\"를 사용  디자인도 깔끔하고 제작자가 꾸준히 업데이트를 하고있으며,  많이 사용되고 있는 만큼 참고할 자료도 많을 것으로 보인다.  이글의 제목은 GitHub 글 쓰기 이고, 오늘은 2021-12-03이다. 앞으로 공부하면서 계속해서 정리해서 올려봐야겠다.   이런 형식으로 올리면   이렇게 등록이 된 것을 확인 할 수 있다.   ","categories": ["blog"],
        "tags": ["post"],
        "url": "/blog/post/",
        "teaser": null
      },{
        "title": "공부할 것 들",
        "excerpt":"공부해야 할 것들      vue2   vue3   webpack   vite   javascript   typescript   functional programming   jest (or mocha) test code   vite: 웹팩을 대체하는 속도 빠른 번들링툴 (요즘 뜨는 툴)   제스트: 태스트 코드 작성할때 사용하는 라이브러리  ","categories": ["etc"],
        "tags": ["study","skill"],
        "url": "/etc/study/",
        "teaser": null
      },{
        "title": "10 - 템플릿 문법 : 실전",
        "excerpt":"10.1 watch 속성   인스턴스를 생성하고 num속성을 추가합니다.  이 num을 button을 클릭했을때 1씩 증가 시켜보겠습니다.   메서드에 addNum을 정의하고 버튼에 v-on:click으로 연결해줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &lt;div id=\"app\"&gt;          &lt;button v-on:click=\"addNum\"&gt;increase&lt;/button&gt; &lt;/div&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,         },         methods: {             addNum: function() {                 this.num = this.num + 1;             }         }     }) &lt;/script&gt;   화면에서 버튼을 누르면 누를때마다 숫자가 증가합니다.  여기에 추가로 증가할때마다 콘솔을 찍어보겠습니다.  그러면 data의 변화에 따라서 특정 로직을 실행하는 watch를 이용해보겠습니다.  메서드에 logText를 추가해주고 이것을 watch에 num이 변화했을때 logText를 실행하도록 연결해줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 &lt;div id=\"app\"&gt;          &lt;button v-on:click=\"addNum\"&gt;increase&lt;/button&gt; &lt;/div&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,         },         watch: {             num: function() {                 this.logText();                }         },         methods: {             addNum: function() {                 this.num = this.num + 1;             },             logText: function() {                 console.log('changed');             }         }     }) &lt;/script&gt;   화면에서 확인해보면 버튼을 누를때마다 콘솔창이 찍힙니다.      10.2 watch 속성 vs computed 속성   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &lt;div id=\"app\"&gt;      &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         },         watch: {             num: function(newValue) {                 this.fetchUserByNumber(newValue);             }         },         methods: {             fetchUserByNumber: function(num) {                 console.log(num);             }         }     }) &lt;/script&gt;      data의 num에 10이라는 값이 할당되어 있습니다.   computed에는 doubleNum이라는 함수가 정의되어 있고, 이 함수는 data의 num이라는 속성에 두배의 값을 return합니다.  자연스럽게 vue 내부적으로 계속 계산을 하는 속성이라고 생각하면 됩니다.  기본적으로 data의 의존성(위 doubleNum로직이 실행될 때, 기준이 되는 값이 data의 num값)을 가지고 이 값이 변할 때 마다 computed의 doubleNum이 실행되고 계산됩니다.   watch는 computed와 굉장히 비슷한 느낌인데 watch의 경우도 data의 num이 바뀌었을 때 특정 로직을 실행하기 때문에 computed와 차이가 없어 보입니다.   computed  computed같은 경우는 단순한 값에 대한 계산, 특히 validation vue라이브러리가 있는데 그 내부적으로 구현되어 있는 것들이 computed 속성으로 되어있습니다.  단순한 텍스트 입력을 받아서 거기에 대한 값을 계산하는 것은 computed를 많이 사용합니다.   watch  watch같은 경우는 실제로 무거운 로직들, 매번 실행되기엔 부담스러운 로직입니다.  예를 들어서 data의 num값이 수정되었을 때 this.fetchUserByNumber()가 실행되도록 했는데 브라우저에서 num 값을 증가 시키면 콘솔창에 11이 찍힙니다.      이 부분이 watch에 설정한 함수입니다.   watch의 함수들은 기본적으로 두가지 인자를 받습니다.     첫번째 newValue : 갱신된 값   두번째 oldValue : 이전값      watch는 계속 값의 변화를 추적하고 있기 때문에 이전값과 갱신된 값을 인자로 받습니다.   그래서 새로 갱신된 값을 fetchUserByNumber의 인자로 넘기고 이 함수에서 인자값을 받아서 콘솔에 찍은겁니다.   공식문서 결론      공식문서에서도 웬만하면 computed를 사용하고 watch보다는 computed가 대부분의 케이스에 적합하다고 되어있습니다.  실제로 서비스를 구현할때도 computed로 충분히 가능한데 watch를 사용하면 코드가 지저분해지고 computed가 이미 캐싱이나 이런 내부적인 튜닝이 많이 되어있기때문에 computed를 통해서 값들을 계산하는 것을 추천드립니다.   10.3 computed 속성을 이용한 클래스 코드 작성 방법   computed를 이용한 직관적인 코드 작성과 클래스 바인딩에 대해 알아보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt;     &lt;style&gt;         .warning {             color: red;         }     &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id=\"app\"&gt;         &lt;p v-bind:class=\"errorTextColor\"&gt;Hello&lt;/p&gt;     &lt;/div&gt;     &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;     &lt;script&gt;         new Vue({             el: '#app',             data: {                 // cname: 'blue-text',                 isError: false             },             computed: {                 errorTextColor: function() {                     return this.isError ? 'warning' : null                 }             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;   이렇게 코드를 작성하면 템플릿상에서 { warning: isError }를 넣을 필요 없이 인스턴스안에 깔끔하게 정리 할 수 있습니다.   ","categories": ["vue-lv1"],
        "tags": ["vue","template syntax"],
        "url": "/vue-lv1/vue-beginner10/",
        "teaser": null
      },{
        "title": "11 - 프로젝트 생성 도구 Vue CLI",
        "excerpt":"11.1 최신 Vue CLI 소개   구글에서 vue cli를 검색하면 공식사이트로 들어갈 수 있습니다.   Vue CLI 공식 사이트 링크   CLI란 명령어를 통한 특정 액션을 실행하는 도구입니다.   Get Started를 누르고    Installation을 클릭하고 조금만 내리면 실행 명령어가 보입니다. 이 실행명령어를 이용해서 설치를 진행 할 것입니다.     그 전에 확인 해야 할 것이, 지금까지 vscode에서 live server를 통해서 코드를 브라우저에서 확인했는데 앞으로는 터미널을 이용하겠습니다.   우선 vscode에서 터미널 창을 켜고      node -v 명령어로 노드버전을 확인합니다. 10.대 이상 LTS버전으로 설치해주세요. 두번째로 npm -v 로 npm 버전도 확인하세요. 6.대 버전 이상이면 됩니다.   Vue CLI 공식 사이트에서 확인한 npm install -g @vue/cli 명령어로 Vue CLI를 설치합니다.  (강의에서는 3.x 버전을 설치 하였는데 현재는 5.x 버전)   11.2 Vue CLI 도구 설치할 때 문제점 해결 방법   npm 명령어로 CLI를 설치 중에 에러가 발생하는 경우가 있을것입니다. 이 에러 케이스에 대해서 얘기해보면, 대부분 permision 에러가 뜰것입니다.  이 에러는 npm install로 설치할때 라이브러리가 위치하는 폴더에 쓰기 권한이 없어서 그렇습니다.  이럴때는 sudo를 앞에 붙여서 sudo npm install -g @vue/cli로 설치해주시면 됩니다.      mac과 window의 설치 루트는 위와 같습니다.   11.3 CLI 2.x와 3.x의 차이점 / 프로젝트 생성 및 서버 실행   CLI의 버전 차이에 대해서 알아보겠습니다.   프로젝트를 생성할때  [Vue CLI 2.x]의 경우  vue init ‘프로젝트 템플릿 유형’ ‘프로젝트 폴더 위치’  vue init webpack-simple ‘프로젝트 폴더 위치’   [Vue CLI 3.x]의 경우  vue create ‘프로젝트 폴더 위치’   이런 명령어의 차이가 있습니다.   프로젝트를 생성 해보겠습니다.   vue creat vue-cli로 생성 해봅시다.      여기에서 Vue 2를 선택해주세요.      use yarn / use npm 선택이 나오는데 편한 명령어를 선택하시면 됩니다. 생성이 완료 되면 cd vue-cli로 폴더 이동해서 yarn serve (또는 npm run serve)로 서버를 실행합니다.      실행하면 포트번호 8080으로 로컬서버로 접근 할 수 있게 됩니다.   url로 이동해서 브라우저에서 화면을 확인해 보면 아래와 같은 화면을 확인 할 수 있습니다.      11.4 CLI로 생성한 프로젝트 폴더 구조 확인 및 main.js 파일 설명   vue create명령어로 생성된 vue-cli폴더를 들어가봅시다.  npm run serve 또는 yarn serve는 package.json 파일의 serve에 정의된 명령어를 실행 합니다.   index.html  이때 실행되는 파일은 public 폴더의 index.html를 살펴봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &lt;!DOCTYPE html&gt; &lt;html lang=\"\"&gt;   &lt;head&gt;     &lt;meta charset=\"utf-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;     &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt;     &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;noscript&gt;       &lt;strong&gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;     &lt;/noscript&gt;     &lt;div id=\"app\"&gt;&lt;/div&gt;     &lt;!-- built files will be auto injected --&gt;   &lt;/body&gt; &lt;/html&gt;   이 파일 안에는 app이라는 id를 가진 태그가 있는데, 그 아래의 주석은 빌드된 파일들이 자동으로 추가된다라는 의미입니다.      src폴더 밑에 정의해 놓은 main.js, App.vue등 여러 파일들을 합쳐서 최소한의 파일로 변환해서 추가해 주는 것입니다.(이것을 webpack이 해줌)   main.js   main.js 파일을 살펴봅시다.   1 2 3 4 5 6 7 8 import Vue from 'vue' import App from './App.vue'  Vue.config.productionTip = false  new Vue({   render: h =&gt; h(App), }).$mount('#app')   여기에서 new Vue({...}).$mount('#app')를 다시 써보면  기존에 하던 인스턴스 생성 코드와 동일합니다.   1 2 3 4 5 6 new Vue({ }).$mount('#app')  new Vue({ \tel: '#app', })   여기에서 다시 작성 해보겠습니다.  기존의 코드에서 render만 추가된 형태입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 import Vue from 'vue' import App from './App.vue'  Vue.config.productionTip = false  new Vue({   render: h =&gt; h(App), }).$mount('#app')  new Vue({     el: '#app',     render: h=&gt; h(App), })   render의 역할은 App이라는 컴포넌트, 즉 위의 import한 파일을 불러와서 집어넣고 랜더링 했다고 이해하시면 될 것 같습니다.   App이라는 컴포넌트를 살펴보겠습니다.  import App from './App.vue 코드 대신에 아래와 같이 작성 해 봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import Vue from 'vue' // import App from './App.vue'  Vue.config.productionTip = false  var App = {     template: '&lt;div&gt;app&lt;/div&gt;' }  new Vue({   render: h =&gt; h(App),   components: { // components의 역할과 render 역할이 동일       'app': App   } }).$mount('#app')   위 코드는 지금까지 기초 공부를 하면서 많이 봤던 코드입니다.  변수 App을 정의하고 인스턴스에 components속성에 정의 했었습니다.  components와 render의 역할이 동일합니다.   11.5 싱글 파일 컴포넌트 소개 및 여태까지 배운 내용 적용하는 방법   .vue로 파일을 생성해봅니다.  vue파일에서 vue를 입력하고 엔터를 치면 싱글 파일 컴포넌트 코드가 자동완성 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;template&gt; &lt;!-- html --&gt; &lt;/template&gt;  &lt;script&gt; export default { // javascript } &lt;/script&gt;  &lt;style&gt; /* css */ &lt;/style&gt;   이전에 배웠던 방식으로 코드를 보면  1 2 3 4 5 6 7 8 var appHeader = {   template: '&lt;div&gt;header&lt;/div&gt;',   methods: {     addNum: function() {      }   } }   여기에서 template의 &lt;div&gt;headet&lt;/div&gt;가 &lt;template&gt;안에 들어가게 되고,  methods는 &lt;script&gt;안에 위치하게 됩니다.  인스턴스 옵션이 들어가는 겁니다.   11.6 App.vue와 HelloWorld.vue 설명   App.vue를 살펴보면 &lt;HelloWordl&gt;로 컴포넌트를 등록했습니다.  1 2 3 4 5 components: {     HelloWorld,     'hello-world': HelloWorld,       // 위 두개는 같은 의미입니다.     }   컴포넌트 내용을 들고와서 components에 등록해서 사용하는 것을 확인 할 수 있습니다.   ","categories": ["vue-lv1"],
        "tags": ["vue","cli"],
        "url": "/vue-lv1/vue-beginner11/",
        "teaser": null
      },{
        "title": "12 - 싱글 파일 컴포넌트",
        "excerpt":"12.1 싱글 파일 컴포넌트에 배운 내용 적용하여 개발 시작하기   cli로 생성한 프로젝트에서 어떤식으로 개발을 시작해야 하는지 살펴보겠습니다.   파일을 정리해보겠습니다.  우선 HelloWorld.vue를 삭제합니다.   App.vue도 전체를 지우고 저장한 후에 vue를 입력해서 자동완성을 합니다.  template에서 div태그를 만들어줍니다.  여기서 주의할 점은 가장 상위 태그는 하나여야한다는 것입니다.   1 2 3 4 5 6 7 8 &lt;template&gt;     &lt;div&gt;          &lt;/div&gt;     &lt;div&gt;          &lt;/div&gt; &lt;/template&gt;   이런식으로 최상단에 태그가 여러개가 나열되면 에러가 뜹니다.   1 2 3 4 5 6 7 8 9 10 &lt;template&gt;     &lt;div&gt;         &lt;div&gt;                  &lt;/div&gt;         &lt;div&gt;                  &lt;/div&gt;     &lt;/div&gt; &lt;/template&gt;   이렇게 최상단에는 하나의 태그로 묶어주고 그 안에서 여러개의 태그를 넣어야 합니다. template안에 Root는 한개 요소여야합니다.   div안에 app이라고 입력하고 화면을 확인해봅시다.      화면에서 app이 뜨는것을 볼 수 있고 vue의 Root에 컴포넌트가 뜹니다.   이번에는 app대신 hi라는 텍스트를 vue data에서 정의를 하고 데이터 바인딩으로 엮어보겠습니다.      script부분에 data:{}를 입력하면 빨간줄이 가는것이 보입니다.  여태까지는 new Vue({})안에 data를 선언해서 했는데 cli를 통해서 .vue파일에서는 여러개의 컴포넌트에서 동일한 값을 참조하면 안됩니다.   1 2 3 4 5 6 7 export default {     data: function() {         return {             str: 'hi'         }     } }   이렇게 함수를 연결하고 return을 새객체를 반환해주는 형식으로 사용해야합니다.   12.2 싱글 파일 컴포넌트 체계에서 컴포넌트 등록하기   App.vue파일에서 별도의 컴포넌트를 등록해서 그 컴포넌트로 하위 컴포넌트의 props와 event를 주고받아보겠습니다.  src 폴더밑에 components안에 AppHeader.vue를 생성합니다.   AppHeader.vue에 코드를 작성합니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;template&gt;     &lt;header&gt;         &lt;h1&gt;Header&lt;/h1&gt;     &lt;/header&gt; &lt;/template&gt;  &lt;script&gt; export default {      }; &lt;/script&gt;  &lt;style lang=\"scss\" scoped&gt;  &lt;/style&gt;   그리고 App.vue로 돌아와서 컴포넌트를 등록해봅시다.  script 안에 import를 이용해서 불러옵니다.   컴포넌트를 등록할때는 components로 등록합니다.  등록한 컴포넌트는 template안에서 불러옵니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 &lt;template&gt;   &lt;div&gt;     &lt;app-header&gt;&lt;/app-header&gt;   &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; import AppHeader from './components/AppHeader.vue' // new Vue({ //   data: { //     str: 'hi' //   } // })  export default {   data: function() {     return {       str: 'hi'     };   },   components: {     'app-header': AppHeader   } }; &lt;/script&gt;  &lt;style lang=\"scss\" scoped&gt;  &lt;/style&gt;   12.2 싱글 파일 컴포넌트에서 props 속성 사용하는 방법  ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner12/",
        "teaser": null
      },{
        "title": "Computed Property Name - 객체 key값에 변수 넣기",
        "excerpt":"es6 템플릿 리터럴   es6에서 템플릿 리터럴을 사용하면 내부에 변수값을 사용할 수 있다.   객체 안에서 key값에 변수를 넣는 법도 있다.   Computed Property Name   []를 사용해 넣으면 된다.   1 2 3 4 5 6 let key = \"name\"; let info = {     [key] : \"ellin\" }  // info = { name: \"ellin\" }   변수 외에 함수도 가능   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function func1(a, b) {   return a + b; } function func2() {   return 'hello'; }  let obj = {   [`key${func1(5,8)}`] : 'result is 13',   [func2()] : 'hi' }  // obj = { //    key13: 'result is 13',  //    hello: 'hi' //  } }  ","categories": ["javascript"],
        "tags": ["es6","object","variable"],
        "url": "/javascript/Computed-Property-Name/",
        "teaser": null
      },{
        "title": "디바운싱과 쓰로틀링",
        "excerpt":"디바운싱 기법과 쓰로틀링 기법   디바운싱과 쓰로틀링 모두 웹에서 발생하는 이벤트르 제어하는 방법이다.   스크롤 이벤트의 경우 스크롤 할 때마다 이벤트가 발생해서 스크롤하면 이벤트가 굉장히 많이 중첩된다.  디바운싱과 쓰로틀링을 사용하여 그런 상황을 막을 수 있다.   디바운싱(Debouncing)     연속으로 호출되는 함수들 중에서 마지막에 호출되는 함수(또는 제일 처음 함수)만 실행되도록 하는것  어떤 이벤트가 호출되고 일정시간 안에 같은 이벤트가 다시 발생하면 그전 이벤트는 취소하고 새로 발생한 함수를 백그라운드에 올린다.  연속성을 기준으로 효율화가 이루어짐       이벤트가 발생하면 특정 시간 후에 로직이 실행되도록 예약을 걸어둔다.   예약된 시간이 되기 전에 이벤트가 다시 발생하면 기존 예약을 취소하고 새로운 예약을 건다.   resize시 이벤트가 실행되어야 할때, resize는 브라우저의 크기를 바꾸는 중에 계속 발생하는데 그때마다 로직이 실행되면 성능상 문제가 생길 수 있다.  그때 debounce 기법을 사용한다.   1 2 3 4 5 6 7 8 //Javascript let timer; window.addEventListener('resize', function(){     clearTimeout(timer);     timer = setTimeout(function() {         console.log('resize event!');     },2000) });   이벤트가 발생할 때마다 이전에 설정한 내용을 지우고 다시 새로 timer를 설정한다.  설정한 시간내에 이벤트가 다시 발생하지 않으면 이벤트 발생이 끝난 것으로 보고 코드가 실행된다.      ajax검색에서 디바운싱을 많이 사용한다.   input에서 사용자가 작성하는 텍스트에 따라 연관검색어를 보여주는 기능이 있을때, 한개 한개 칠때마다 연관검색어가 보이기보다는 어느정도 유의미한 단어가 만들어져서 사용자가 타이핑을 멈춰서 연속성이 끊겼을때 1번 ajax요청을 하면 효율적이다.   쓰로틀링 (Throttling)     이벤트에 의한 콜백을 일정시간 뒤에 호출  무조건 일정시간마다 실행, 일정시간안에 발생한 같은 이벤트는 취소시킨다.       이벤트가 발생하면 특정 시간 후에 로직이 실행되도록 예약을 건다.   예약된 시간이 되기전에 이벤트가 발생하면 새로운 예약을 걸지 않고 발생한 이벤트들을 스킵한다.   쓰로틀링은 주로 스크롤 이벤트에서 많이 사용  스크롤 이벤트는 매우 짧은 시간에 여러번 일어난다. 일정 시간안에 일어난 스크롤 이벤트는 단 한번만 콜백함수를 호출 하도록 만들면 효율적이다.   1 2 3 4 5 6 7 8 9 var timerForThrottle; window.addEventListener('scroll', function(e) {   if (!timerForThrottle) {     timerForThrottle = setTimeout(function() {       console.log('scroll event');       timerForThrottle = null;     }, 2000);   } });  ","categories": ["javascript"],
        "tags": ["debounce","throttle"],
        "url": "/javascript/debounce-throttle/",
        "teaser": null
      },{
        "title": "인스턴스",
        "excerpt":"인스턴스란?   인스턴스는 클래스나 프로토타입을 사용해 만든다. 즉, 프로퍼티와 메서드를 상속 받는다.   원래의 객체가 가지고 있던 것을 동일하게 사용하면서, 거기에 확장시켜 추가된 개별속성을 가질 수 있다.   예를 들어, “모자”라는 객체의 인스턴스로 “모자1”을 생성했을때 “모자1”은 “파란 모자”가 될 수 있다.   1 2 3 4 5     cap = function(color){         this.color = color;     };     let cap1 = new cap(blue);     let cap2 = new cap(black);   ✅ 추가 설명 떡볶이 레시피를 가지고 떡볶이를 먹으려면 “떡볶이”를 만들어야 한다.  어제 “떡볶이”를 만들고, 오늘 또 “떡볶이”를 만들었다고 가정 했을때 만들어진 “떡볶이”는 [인스턴스]가 된다. 여기서 두개의 떡볶이는 같은 레시피를 보고 만들었지만 동일한 대상은 아니다.   ","categories": ["javascript"],
        "tags": ["instance","primitive"],
        "url": "/javascript/instance/",
        "teaser": null
      },{
        "title": "Lexical Scope",
        "excerpt":"렉시컬 스코프란?   함수를 어디서 호출하는지가 아니라 어디에(어디서) 선언하였는지에 따라 결정되는 것을 말한다.   즉, 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정한다는 뜻이며, 가장 중요한 점은 함수의 선언에 따라 결정되는 점이다.   다른 말로 정적 스코프(Static scope)라고 한다.   예시 코드를 보고 어떻게 동작하는지 확인해보자   1 2 3 4 5 6 7 8 9 10 11 12 13 var a = 1; // global  function first() {   var a = 10;   second(); }  function second() {   console.log(a); }  first(); second();   결과는 10, 1이 출력될 거라고 생각하기 쉽지만 실제 결과는 1, 1 이 두번 출력된다.   이유는?  자바스크립트에서 코드를 작성할때, 이미 실행 단계에서 코드들의 스코프를 결정한다.     global 범위에 있는 변수 a   first() 함수 안에 있는 변수 a   second() 함수 안에 있는 변수 a   second()의 상위 스코프가 무엇인지에 따라 결정된다.  자바스크립트는 렉시컬 스코프(Lexical Scope)를 따르므로 함수를 선언한 시점에 이미 상위 스코프가 결정된다.  즉, 이말은 함수를 어디서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다는 말이다.  그렇기 때문에 second() 함수가 first() 함수 안에서 호출 된 것과 상관없이 second()함수는 global 범위에 선언되어 있으므로 global 범위에 있는 변수 a의 값이 두번 출력된 것이다.  ","categories": ["javascript"],
        "tags": ["lexical scope"],
        "url": "/javascript/lexical-scope/",
        "teaser": null
      },{
        "title": "데이터 타입 - primitive type / reference type",
        "excerpt":"데이터 타입   데이터 타입은 크게 primitive type과 reference type으로 나눌 수 있다.      Primitive Type(원시타입)은 불변성이다. 숫자, 문자열, boolean, null, undefined, Symbol   Reference Type(참조타입)은 ` Object(array, function, map, set, weakmap, weakset(ES6 추가))`   위 두가지 모두 선언(dclaration)과 할당(assignment)의 과정을 거치는데 차이점은 할당과정에 있다.     선언 : 변수와 주소값을 매칭   할당 : 변수의 주소값에 값을 할당   Primitive Type은 값을 그대로 할당하고, Reference Type은 값이 저장된 주소(참조위치)를 할당한다.   Primitive Type(원시타입)   1 2 3 4 var a = 10 // 위 코드는 아래와 같은 과정으로 나눌 수 있다. var a; // 선언 a = 10; // 할당   변수 a에 매칭할 주소(2000)을 확보하고 주소값에 실제값을 할당 한다.        변수영역                             주소       1000                 데이터       변수명:a  값: @2000              데이터 영역                             주소       2000                 데이터       10           이때 변수 a의 값이 바뀌면, a에 할당된 10이라는 데이터가 바뀌는게 아니고 공간을 새로 확보해서 새 데이터를 할당하고 a변수가 가리키는 주소값을 바꾼다.  그래서 불변성을 띈다고 한다. 변경을 새로 만드는 동작을 통해서 이뤄지고 한번 만들어진 값은 가비지컬렉팅을 당하지 않는 이상 영원히 변하지 않는다.   a = 15;         변수영역                             주소       1000                 데이터       변수명:a  값: @2001              데이터 영역                             주소       2000       2001                 데이터       10       15           변수 복사  새로운 변수 b를 선언하고 b에 a를 할당하면 변수 b의 공간을 확보하고(선언) b의 값이 가리키는 주소값은 a 값이 가리키는 주소값을 공유받는다(할당)  이떄 b와 a는 일치한다.   var b = a;         변수영역                             주소       1000       1001                 데이터       변수명:a  값: @2001       변수명:b  값: @2001              데이터 영역                             주소       2000       2001                 데이터       10       15           b에 새로운 값을 할당하면 b는 새로운 주소값이 할당되고 a에는 변화 없다.   b = 20;         변수영역                             주소       1000       1001                 데이터       변수명:a  값: @2001       변수명:b  값: @2002              데이터 영역                             주소       2000       2001       2002                 데이터       10       15       20           Reference Type(참조타입)   1 2 3 4 var obj = {   a: 10,   b: 'abc' }   참조타입이 원시타입과 다른점은 참조과정을 한번 더 거친다.  우선 변수 obj에 매칭할 주소값(200)을 확보하고, 객체는 데이터를 한번에 다 담을 수 없으니까 해당 주소값에 여러공간을 확보한다.         변수영역                             주소       100                 데이터       변수명:obj  값: @200              데이터 영역                             주소       200                 데이터       @300~           그리고 확보해둔 공간에 각각 객체의 데이터들을 원시타입처럼 선언, 할당한다.         변수영역                             주소       100                 데이터       변수명:obj  값: @200              데이터 영역                             주소       200       201       202                 데이터       @300~301       1       'abc'              객체의 변수 영역                             주소       300       301                 데이터       변수명:a  값: @201       변수명:b  값: @202           객체 내부의 데이터를 변경해도 객체는 주소값은 바뀌지 않고 객체 내부의 데이터의 주소값만 변경된다.   obj.a = 2;         변수영역                             주소       100                 데이터       변수명:obj  값: @200              데이터 영역                             주소       200       201       202       203                 데이터       @300~301       1       'abc'       2              객체의 변수 영역                             주소       300       301                 데이터       변수명:a  값: @203       변수명:b  값: @202           변수복사  새로운 객체 obj2를 만들어서 obj를 할당하면 같은 주소값을 공유하게 된다.   var obj2 = obj;         변수영역                             주소       100       101                 데이터       변수명:obj  값: @200       변수명:obj2  값: @200              데이터 영역                             주소       200       201       202       203                 데이터       @300~301       1       'abc'       2              객체의 변수 영역                             주소       300       301                 데이터       변수명:a  값: @203       변수명:b  값: @202           이렇게 주소값을 공유하고 있기 때문에 obj2의 내부 데이터를 변경하면 obj의 데이터도 영향을 받는다.   obj2.a = 3;         변수영역                             주소       100       101                 데이터       변수명:obj  값: @200       변수명:obj2  값: @200              데이터 영역                             주소       200       201       202       203       204                 데이터       @300~301       1       'abc'       2       3              객체의 변수 영역                             주소       300       301                 데이터       변수명:a  값: @204       변수명:b  값: @202           1 2 3 console.log(obj.a) // 3; console.log(obj2.a) // 3; console.log(obj === obj2) // true;      할당 연산자 = 로 복사했을 때, 기본형 데이터는 깊은 복사가 되고 참조형 데이터는 얕은 복사가 된다.   기본형 데이터를 복사했을 때, 주소값이 바뀌므로 원본은 영향을 받지 않는다.   참조형 데이터는 내부 데이터를 바꿔도 같은 객체를 가리키고 있기 때문에(주소값이 같으므로) 원본이 영향을 받게 된다.   위와 같은 복사는 객체의 불변성을 지키지 못한다. 불변성을 지키기 위해서는 spread operator, concat 등을 통해 깊은 복사가 필요하다.   참조 참조  ","categories": ["javascript"],
        "tags": ["primitive type","reference type"],
        "url": "/javascript/primitive-reference/",
        "teaser": null
      },{
        "title": "Truthy & Falsy",
        "excerpt":"Truty &amp; Falsy   자바스크립트에는 truthy와 falsy가 있다.  if문같이 boolean값으로 판단할때 실제로 true/false값은 아니지만 true/false 값으로 사용되는 값들을 말한다.      Falsy : false, 0, -0, 0n, \"\", null, undefined, NaN   Truthy : true, {}, [], 1, \"0\", \"false\", new Date(), -12, 12n, 3.14, Infinity, -Infinity … falsy가 아닌 다른 모든 값   NaN은 어떤 값과도 동일하지 않고 자기 자신과도 동일하지 않다.  1 2 3 NaN = null // false NaN = undefined //false NaN = NaN // false  ","categories": ["javascript"],
        "tags": ["truthy","falsy"],
        "url": "/javascript/truthy-falsy/",
        "teaser": null
      },{
        "title": "맥북 키보드에서 원화 표시 기호(₩) 대신 백쿼트(`) 표시되게 하기",
        "excerpt":"맥북 키보드 설정 팁      맥북에서 한글 입력상태에서 백쿼트를 사용하려면 option + ₩(백쿼트) 키를 눌러야한다.  매번 이렇게 입력하려니 불편해서 설정해 두는 방법을 찾아보았다.   맥북에서 터미널 창을 열어준다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Library에 KeyBindings 폴더 생성 cd ~/Library mkdir KeyBindings  // KeyBindings로 들어가서 DefaultkeyBinding.dict 파일 생성 cd KeyBindings touch DefaultkeyBinding.dict  // Vim(Text Editor)로 파일 열고 i(입력) 전환 vi DefaultkeyBinding i  // 아래의 { ~ }코드를 복사해서 {     \"₩\" = (\"insertText:\", \"`\"); }  // esc + :wq :wq   이렇게 입력하고 재부팅해주면 한글 입력상태에서 백쿼트 사용이 된다.   *** 원래의 상태로 돌아가려면 rm DefaultkeyBinding.dict  ","categories": ["tips"],
        "tags": ["mac","keyboard"],
        "url": "/tips/mac-keybinding/",
        "teaser": null
      },{
        "title": "github jekyll blog codeblock에 line number 추가하기",
        "excerpt":"코드블럭에 line number 추가를 해봅시다.   마크다운에서 코드블럭을 삽입하려면 역따옴표를 세번 넣어서 사용합니다.  코드블럭으로 코드를 삽입하고 좀 더 보기 쉽게 line number를 추가 하고 싶을때 어떻게 할까?   _config.yml 파일을 열고 kramdown을 검색합니다.   kramdown:      highlighter: rouge      syntax_highlighter_opts:          block:              line_numbers: true   위 코드를 추가 합니다.      _config.yml 파일은 수정후 자동 반영이 안되므로 서버를 내렸다가 다시 동작하여야 반영이 됩니다.   ","categories": ["blog"],
        "tags": ["codeblock","custom"],
        "url": "/blog/codeblock-line-number/",
        "teaser": null
      },{
        "title": "1 - Todo App - 프로젝트 소개 및 구성",
        "excerpt":"개발환경 설정 및 깃헙 리포지토리 클론      vscode 설치    플러그인 설치 vetur, 'tslint(문법오류나 api쫓아가기 유용함)   node.js   Vue.js devtools   git   1.1 뷰 CLI로 프로젝트 생성하기   1 2 3 npm i -g @vue/cli # or yarn global add @vue/cli  cli를 설치하고 vue create 프로젝트이름 명령어를 사용한다.  vue2를 선택하고 세팅하도록 하겠다.      프로젝트가 생성되고 나면 생성한 폴더 안으로 cd 폴더명으로 이동해서 npm run serve or yarn serve로 로컬서버로 실행해서 브라우저에서 확인할 수 있습니다.   App.vue 파일을 살펴보면 HelloWorld라는 컴포넌트를 import를 통해서 가져오는 것을 볼 수 있습니다.   1.2 프로젝트 소 및 컴포넌트 설계 방법   Todo App을 만들어 볼 계획입니다.   구성은 Root 밑에 4개의 컴포넌트로 구성 되어있습니다.      TodoHeader : 앱의 타이틀이 들어간 컴포넌트   TodoInput : 할 일을 입력하는 입력창이 있는 컴포넌트   TodoList : 입력한 내용을 리스트로 뿌려주고 각 리스트를 삭제하고, 체크 기능이 들어간 컴포넌트   TodoFooter : 전체 리스트를 다 없애주는 버튼이 들어가있는 컴포넌트   간단한 예제이지만 event올리기, props 내리기 같은 데이터 통신에 대해 다루고 있기 때문에 공부하기 좋은 예제입니다.   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate1/",
        "teaser": null
      },{
        "title": "2 - Todo App - 프로젝트 구현",
        "excerpt":"2.1 컴포넌트 생성 및 등록하기   컴포넌트를 설계에 맞게 생성하겠습니다.   components 폴더 안에 TodoHeader.vue, TodoInput.vue, TodoList.vue, TodoFooter.vue 파일을 만들고 자동완성으로 기본태그 입력하고 각 파일 template의 div태그 안에 구분해줄 단어들을 아래 예시처럼 입력해서 저장합니다.   1 2 3 4 5 6 7 8 9 10 11 &lt;template&gt;     &lt;div&gt;         Header     &lt;/div&gt; &lt;/template&gt; ... &lt;template&gt;     &lt;div&gt;         Input     &lt;/div&gt; &lt;/template&gt;   App.vue 파일을 열고 필요없는 내용을 다 지워서 정리해줍니다.  그리고 생성한 컴포넌트들을 import로 가져와서 연결하고 template에 넣어줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 &lt;template&gt;   &lt;div id=\"app\"&gt;     &lt;TodoHeader&gt;&lt;/TodoHeader&gt;     &lt;TodoInput&gt;&lt;/TodoInput&gt;     &lt;TodoList&gt;&lt;/TodoList&gt;     &lt;TodoFooter&gt;&lt;/TodoFooter&gt;   &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; import TodoHeader from './components/TodoHeader.vue' import TodoInput from './components/TodoInput.vue' import TodoList from './components/TodoList.vue' import TodoFooter from './components/TodoFooter.vue'  export default {   components: {     'TodoHeader': TodoHeader,     'TodoInput': TodoInput,     'TodoList': TodoList,     'TodoFooter': TodoFooter,   } } &lt;/script&gt;      2.2 파비콘, 아이콘, 폰트, 반응형 태그 설정하기   모바일 웹에서도 잘 보이도록 반응형 태그를 추가하고 아이콘이나 파비콘을 추가하겠습니다.   크롬창에서 meta viewport를 검색해서 복사해서 public 폴더안에 index.html meta태그 영역에 붙여넣습니다.  다음으로 파비콘도 추가합니다. 크롬에서 favicon generator 사이트에서 원하는 이미지로 파비콘을 생성하면 링크도 같이 생성 되니 그걸 복붙하면 됩니다.  (cli로 생성시 자동으로 들어가있어서 따로 추가 할 필요 없는듯)   마지막으로 awesome아이콘을 추가합니다.   폰트어썸 업데이트하면서 부터인지 vue에서 사용하려면 메일로 무료키트 사용 링크를 받아야한다.  fontawsome.com/start로 접속 &gt; 이메일 입력 &gt; 확인, 설정 버튼 클릭 &gt; 폰트어썸 로그인 후 무료키트 링크 카피해서 index.html 헤드에 추가      구글 폰트도 미리 설정하겠습니다.   크롬에서 google font를 검색해서 접속한 후 ubuntu를 검색합니다.  원하는 weight를 선택해서 생성된 링크를 index.html에 추가합니다.      1 2 3 4 5 6 7 8  &lt;head&gt;     &lt;meta charset=\"utf-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;     &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt;     &lt;link href=\"https://fonts.googleapis.com/css2?family=Ubuntu&amp;display=swap\" rel=\"stylesheet\"&gt;     &lt;title&gt;To do App&lt;/title&gt;   &lt;/head&gt;   2.3 TodoHeader 컴포넌트 구현   header는 header태그 안에 h1태그를 이용해서 정체성을 나타내겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &lt;template&gt;     &lt;header&gt;         &lt;h1&gt;To Do it!&lt;/h1&gt;     &lt;/header&gt; &lt;/template&gt;  &lt;script&gt; export default { }; &lt;/script&gt;  &lt;style scoped&gt; h1 {     color: #2f3b52;     font-weight: 900;     margin: 2.5rem 0 1.5rem; } &lt;/style&gt;   App.vue에도 스타일을 넣어줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 body {   text-align: center;   background-color: #F6F6F8; } input {   border-style: groove;   width: 200px; } button {   border-style: groove; } .shadow {   box-shadow: 5px 10px 10px rgba(0, 0, 0, 0.03) }   2.4 TodoInput 컴포넌트의 할 일 저장 기능 구현   두번째 컴포넌트를 작성하겠습니다.   인풋박스를 만들어서 텍스트를 입력하면 그 값을 로컬스토리지에 저장합니다.  우선 인풋박스를 만들어 줍시다. 여기에 입력된 값을 스크립트에서 인식하려면 v-model이라는 디렉티브를 사용합니다.  v-model의 역할을 인풋에 입력된 텍스트 값을 동적으로 바로 뷰 인스턴스 안에 매핑을 합니다.  v-mode을 사용하는 방법은 data에 newTodoItem이라고 이름 지어주고 v-model에 연결해줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;template&gt;     &lt;div&gt;         &lt;input type=\"text\" v-model=\"newTodoItem\"&gt;     &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; export default {     data: function() {         return {             newTodoItem: \"\"         }     } }; &lt;/script&gt;   이렇게 연결하고 화면에서 어떻게 반영되는지 보면, TodoInput컴포넌트 data쪽에 newTodoItem이 생기고 인풋박스에 텍스트를 입력하면 newTodoItem의 내용도 바뀌는 것을 볼 수 있습니다.    이어서 v-model에 있는 값을 들고와야합니다.  아래에 버튼을 만들고 v-on:click으로 클릭했을때 동작할 메서드명을 넣어주고 script에 메서드를 정의해줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;template&gt;     &lt;div&gt;         &lt;input type=\"text\" v-model=\"newTodoItem\"&gt;         &lt;button v-on:click=\"addTodo\"&gt;add&lt;/button&gt;     &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; export default {     data: function() {         return {             newTodoItem: \"\"         }     },     methods: {         addTodo: function() {             console.log(this.newTodoItem)         }     } }; &lt;/script&gt;   여기서 this는 TodoInput컴포넌트를 가리키고 그 안의 newTodoItem을 가져옵니다.  화면에서 인풋에 텍스트를 입력하고 add버튼을 눌러보면, 콘솔창에 입력값을 가져와서 출력하는 것을 볼 수 있습니다.      여기서 한가지 기능을 추가해서 버튼을 클릭하면 인풋박스를 비우도록 해봅시다.   1 2 3 4 addTodo: function() {     console.log(this.newTodoItem);     this.newTodoItem = ''; }      addTodo메서드 저장하는 로직 추가   localStorage.setItem(‘key’, ‘value’)로 추가            diff check            2.5 TodoInput 컴포넌트 코드 정리 및 UI스타일링      this.clearInput(); // 같은 인스턴스안에 있는 메서드라서 this로 접근 가능            diff check            2.6 TodoInput 컴포넌트의 할 일 목록 표시 기능 구현      created(인스턴스가 생성되자마자 호출되는 라이프사이클 훅), mounted, update, destroy   for문으로 localStorage를 가져옴            diff check            2.7 TodoList 컴포넌트 할 일 삭제 기능 구현      localStorage.removeItem(todoItem); // key랑 value를 똑같이 넣어놔서 todoItem으로 지우면 됨   this.todoItems.splice(index, 1); // localStorage를 지우고 배열도 지워줘야 브라우저에 반영됨 splice -&gt; index번째에서 1개 지움            diff check            2.8 TodoList 컴포넌트의 할 일 완료 기능 구현      var obj = {completed: false, item: this.newTodoItem}; // item : text값, completed : boolean값을 넣어서 객체에 저장   obj를 stringify 않고 넣으면 할일을 추가했을때 localStorage에서 확인하면 key에는 잘 들어가는데 value에 [object Object]로 들어가서 객체 안에 어떤값이 들어있는지 확인 불가능   stringify : 객체를 string으로 변환해서 넣기때문에 객체 안에 어떤값이 있는지 확인 가능   v-bind:class=”{checkBtnCompleted: todoItem.completed}” -&gt; v-bind로 엮어서 class값을 동적으로 바꿔줌   todoList에 뿌릴떄는 TodoInput에서 stringify로 변환해서 넣은 값을 다시 객체로 변환(JSON.parse)해서 가져옴            diff check            2.9 TodoFooter 컴포넌트 구현      localStorage.clear(); // localStorage 지우는 api            diff check           ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate2/",
        "teaser": null
      },{
        "title": "3 - Todo App - 애플리케이션 구조 개선하기",
        "excerpt":"3.1 현재 앱 구조의 문제점 진단 및 개선된 앱 구조 소개      localStorage.clear();            localStorage 지우는 api           이렇게 작성하면(삭제 뿐만 아니라 todoInput쪽 할일 추가 부분도) localStorage에서는 지워지지만(추가되지만 브라우저는 새로고침해야 반영) TodoList컴포넌트와 분리되어 있기 때문에 list에는 영향이 없다.   그래서 하위 컴포넌트(todoFooter, todoInput)에서는 event로 상위(App)에 보내고 상위에서는 해당 내용을 props로 내려줍니다.      diff check    3.2 [리팩토링] 할 일 목록 표시 기능   App.vue     하위로 props 내리기            v-bind:내려보낼 프롭스 속성 이름=”현재위치의 컴포넌트 데이터 속성”           TodoList.vue     props: [‘propsdata’],   App.vue에서 v-bind:propsdata=”todoItems”로 내려준 프롭스 속성 이름 propsdata      diff check    3.3 [리팩토링] 할 일 추가 기능   App.vue     하위에서 올린 이벤트버스 받기            v-on:하위 컴포넌트에서 발생시킨 이벤트 이름=”현재 컴포넌트의 메서드 명”           하위 TodoInput에서 추가 버튼 addTodo메서드가 실행되면 $emit으로 App.vue로 addTodoItem을 올려 주고 인자로 this.newTodoItem을 보낸다. 그러면 App.vue에서는 addTodoItem에 연결된 현재 컴포넌트의 메서드 addOneItem을 실행한다.   TodoInput에서 newTodoItem을 인자로 받아왔으니 여기에도 todoItem으로 인자를 넣어줌   TodoInput.vue     this.$emit(‘이벤트이름’, 인자1, 인자2 …)   addTodo가 실행되면 addTodoItem을 발생시켜서 상위 컴포넌트로 올려준다.      diff check    3.4 [리팩토링] 할 일 삭제 기능   App.vue     localStorage.removeItem(todoItem.item);            removeItem(todoItem); 으로 삭제하면 객체를 지우는거라서 localStorage에서 삭제가 안됨 todoItem.item으로 삭제해줘야 함           TodoList.vue     removeItem을 실행해서 todoItem, index 인자를 보낸다.      diff check    3.5 [리팩토링] 할 일 완료 기능   App.vue     localStorage.removeItem(todoItem.item);            removeItem(todoItem); 으로 삭제하면 객체를 지우는거라서 localStorage에서 삭제가 안됨 todoItem.item으로 삭제해줘야 함           기존 complete toggle시키는 부분 문제점   todoItem.completed = !todoItem.completed;            todoItems라는 배열을 todoList에 propsdata가 props로 내려가서 props로 받아서 그걸로 접근하는 형태인데, 여기서 이벤트버스로 todoItem을 넘겨줬음. 즉, props에서 접근된 데이터를 다시 위로 올림, 다시 올려서 바꾸는 것은 좋지 않은 패턴(안티패턴), 이것보다는 App.vue라는 파일이 컨테이너의 성격을 가지고 있기 때문에 todoItems에 접근해서 조작하는 것이 좋음       this.todoItems[index].completed = !this.todoItems[index].completed;              diff check    3.6 [리팩토링] 할 일 모두 삭제 기능   App.vue     v-on:clearAll=”clearAllItems”   this.todoItems = [] -&gt; 빈배열로 만들어서 브라우저에서도 삭제되도록      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate3/",
        "teaser": null
      },{
        "title": "4 - Todo App - 사용자 경험 개선",
        "excerpt":"4.1 모달 컴포넌트 등록   TodoInput.vue     vuejs.org 공식 사이트 Learn &gt; examples에서 Modal Component 참고   components: ModalBox: ModalBox      diff check    4.2 모달 컴포넌트의 slot 소개   TodoInput.vue     slot : 특정 컴포넌트의 일부 ui들을 재사용 할 수 있음   ModalBox.vue에서 default로 넣어둔 부분을 여기에서 커스텀 할 수 있음      diff check    4.3 slot 및 모달 컴포넌트 기능 구현   TodoInput.vue     v-on:click=”” -&gt; 축약형 @click=””      diff check    4.4 트랜지션 소개 및 구현      vuejs.org 공식문서 사이트엣 Transition Animation &gt; List Transition 참고   v-enter : 처음 active가 시작됐을때   v-enter-to : 시작되고 끝날때 상태   v-leave : 이펙트가 나오기 직전   v-leave-to : 이펙트가 끝난 시점   일반적으로 v-enter-to와 v-leave 같이 쓰고, v-enter와 v-leave-to 같이 씀      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate4/",
        "teaser": null
      },{
        "title": "5 - ES6 for Vue.js - const & let",
        "excerpt":"ES6 배경과 Babel 소개   es6(ECMAScript 2015)     2015년은 ES5(2009년)이래로 진행한 첫 메이저 업데이트가 승인된 해   최신 Front-End Framework인 React, Angular, Vue에서 권고하는 언어 형식   ES5에 비해 문법이 간결해져서 익숙해지면 코딩을 훨씬 편하게 할 수 있음   Babel     구 버전 브라우저 중에서는 ES6의 기능을 지원하지 않는 브라우저가 있으므로 tranpiling이 필요   ES6의 문법을 각 브라우저의 호환 가능한 ES5로 변환하는 컴파일러   5.1 const &amp; let 소개      블록 단위 {} 로 변수의 범위 제한   const : 한번 선언한 값에 대해서 변경 불가능(상수개념)   let : 한번 선언한 값에 대해서 다시 선언할 수 없음   5.2 [ES5의 주요 특징]변수 스코프와 호이스팅   변수의 Scope     기존의 ES5는 {}에 상관없이 스코프가 설정됨   1 2 3 4 5 6 var sum = 0; for (var i = 1; i &lt;= 5; i++) {     sum = sum + i; } console.log(sum); // 15 console.log(i) // 6   for문을 벗어나도 i에 접근이 가능   Hoisting     함수나 변수를 해석기가 가장 상단으로 끌어올림   js 해석기는 코드의 라인 순서와 관계 없이 함수선언식과 변수를 위한 메모리 공간을 먼저 확보한다.   함수표현문과 const, let 은 호이스팅이 일어나지 않는다.   5.3 const와 let 추가 설명 및 정리      {}단위로 변수의 범위가 제한   1 2 3 4 5 6 let sum = 0; for (let i = 1; i &lt;= 5; i++) {     sum = sum + i; } console.log(sum); // 15 console.log(i) // Uncaught ReferenceError: i is not defined   for문이 끝나면 i에 접근 불가      const로 지정한 값 변경 불가능   객체나 배열의 내부는 변경할 수 있다.   1 2 3 4 5 6 7 const a = {}; a.num = 10; console.log(a); // {num:10}  const b = []; b.push(20); console.log(b); // [20]   5.4 [리팩토링] const와 let      var -&gt; const, let으로 변환      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate5/",
        "teaser": null
      },{
        "title": "6 - ES6 for Vue.js - 화살표 함수",
        "excerpt":"6.1 화살표 함수 소개 및 설명      함수를 정의할 때 function이라는 키워드를 사용하지 않고 =&gt; 로 대체   흔히 사용하는 콜백 함수의 문법을 간결화   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ES5 함수 정의 방식 var sum = function(a, b) {     return a + b; };   // ES6 함수 정의 방식 var sum = (a, b) =&gt; {     return a + b; }  sum(10, 20);  // ES5 var arr = [\"a\", \"b\", \"c\"]; arr.forEach(function(value) {     console.log(value); // a, b, c });  // ES6 var arr = [\"a\", \"b\", \"c\"]; arr.forEach(value =&gt; console,log(value)); // a, b, c   Babel 온라인 에디터 링크  ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate6/",
        "teaser": null
      },{
        "title": "7 - ES6 for Vue.js - Enhanced Object Literals",
        "excerpt":"7.1 속성 메서드의 축약 특징 설명   향상된 객체 리터럴     객체의 속성을 메서드로 사용할 때 function 예약어를 생략 가능   1 2 3 4 5 6 7 8 9 10 11 var dictionary = {     words: 100,     // ES5     lookup: function() {         console.log(\"find words\");     },     // ES6     lookup() {         console.log(\"finde words\");     } }   7.2 [리팩토링] 속성 메서드의 축약 특징 리팩토링      diff check    7.3 속성명의 축약 특징 설명      객체의 속성명과 값 명이 동일할 떄 아래와 같이 축약 가능   1 2 3 4 5 var figures = 10; var dictionary = {     // figures: figures,     figures }   7.4 [리팩토링] 속성명의 축약 특징 리팩토링      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate7/",
        "teaser": null
      },{
        "title": "8 - ES6 for Vue.js - Modules",
        "excerpt":"8.1 Modules   자바스크립트 모듈화 방법     자바스크립트 모듈 로더 라이브러리(AMD, Commons JS)기능을 js 언어 자체에서 지원   호출되기 전까지는 코드 실행과 동작을 하지 않는 특징이 있음   1 2 3 4 5 6 7 8 9 // libs/math.js export function sum(x, y) {     return x + y; } export var pi = 3.141593;  // main.js import { sum } from 'libs/math.js'; sum(1, 2);   자바스크립트는 모듈화 방법이 없었기 때문에 모듈 로더 라이브러리를 사용함   모듈 : 특정기능을 수행하는 한 단위, 묶음 모듈화 이유 : 재사용성이 뛰어난 기능을 묶어서 다시 가져다 쓰기 위해서   Vue.js에서 가장 많이 보이는 export default   1 2 3 4 5 6 7 8 9 10 11 12 13 14 // util.js export default function(x) {     return console.log(x); }  // main.js import util from 'util.js'; console.log(util); // function (x) { return console.log(x); } util('hi');  // app.js import log from 'util.js'; console.log(log); log('hi');  ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate8/",
        "teaser": null
      },{
        "title": "9 - Vuex - 소개",
        "excerpt":"9.1 Vuex 소개   Vuex - 상태 관리 라이브러리      복잡한 애플리케이션의 컴포넌트들을 효율적으로 관리하는 Vuex라이브러리 소개   Vuex 라이브러리의 등장 배경인 Flux 패턴 소개   Vuex 라입러리의 주요 속성인 state, getters, mutations, actions 학습   Vuex를 더 쉽게 코딩할 수 있는 방법인 Helper 기능 소개   Vuex로 프로젝트를 구조화하는 방법과 모듈 구조화 방법 소개   React에서는 Flux 패턴으로 복잡한 앱에서 야기되는 관리 문제점을 해결 하고 있어서 Vuex에 도입했다.   9.2 Flux와 MVC 패턴 소개 및 Flux 등장 배경   Vuex란?     복잡하고 많은 컴포넌트의 데이터를 관리하기 위한 상태 관리 패턴이자 라이브러리   React의 Flux패턴에서 기인   Flux란?     MVC패턴의 복잡한 데이터 흐름 문제(페이스북같이 복잡한 컴포넌트에서 하나의 데이터가 바뀌었을때 다른 컴포넌트에서 추적하기가 어려움)를 해결하는 개발 패턴   Action -&gt; Dispatcher -&gt; Model -&gt; View  Action에서 View까지 항상 한방향으로 흐름(unidirectional data flow)      action : 화면에서 발생하는 이벤트 또는 사용자의 입력   dispatcher : 데이터를 표시하는 방법, 메서드(모델(data)을 바꾸기 위한 역할)   model : 화면에 표시할 데이터   view : 사용자에게 비춰지는 화면(action을 호출해서 계속해서 단방향으로 이동)   사용자가 화면에서 클릭같은 조작(action)을 하면 메서드가 발생해서 데이터를 변경(dispatcher) 하면 store(model)가 변경이 되고 그것이 화면(view)에 반영이 되고 다시 화면에서 action을 호출함   프롭스가 내려갈것이고 하위에서 올릴때는 이벤트로 올린다 등의 예측이 가능함   +MVC패턴 : Controller -&gt; Model &lt;-&gt; View (양방향)  ㄴ view : 화면 / Model : 데이터 / Controller : view와 model을 제어   9.3 Vuex가 필요한 이유, Vuex 컨셉, Vuex 구조      복잡한 애플리케이션에서 컴포넌트의 개수가 많아지면 컴포넌트 간에 데이터 전달이 어려워진다.   하위에서 루트로 보낼때 이밴트버스로 해결할 수 있지만 어디서 이벤트를 보냈는지 알기 어려움(컴포넌트 간 데이터 전달이 명시적이지 않음)   Vuex로 해결할 수 있는 문제     MVC패턴에서 발생하는 구조적 오류   컴포넌트 간 데이터 전달 명시   여러 개의 컴포넌트에서 같은 데이터를 업데이트 할 때 동기화 문제   Vuex 컨셉     State : 컴포넌트 간에 공유하는 데이터 data() - 데이터프로퍼티라고 보면 됨   View : 데이터를 표시하는 화면 template - template속성   Action : 사용자의 입력에 따라 데이터를 변경하는 methods - 메서드   화면(template)에서 버튼을 클릭하면 버튼은 v-on:click=”addTodo”를 발생시키는데 이게 action, action이 data를 변경하는데 이 data가 state   Vuex 구조  컴포넌트 -&gt; 비동기 로직 -&gt; 동기 로직 -&gt; 상태   컴포넌트에서 비동기로직(actions)에서 처리하고(setTimeout, apiCall등) 데이터는 바꾸지 않고 데이터를 바꿀 수 있는 mutations를 콜하고 mutations(동기 로직)만 state를 바꿈  ","categories": ["vue-lv2"],
        "tags": ["vue","vuex","store"],
        "url": "/vue-lv2/vue-intermediate9/",
        "teaser": null
      },{
        "title": "DOM",
        "excerpt":"DOM 소개   javascript를 공부하면서 DOM을 빼놓고 이야기 할 수 없다.   DOM이란 무엇인가? 그전에 BOM에 대해서 알아보자.      BOM이란 무엇인가?    브라우저를 바탕으로 웹서비스가 실행이 되는데, 이와 관련된 객체들의 집합을 브라우저객체모델(Browser Object Model)이라고 한다.      웹브라우저와 관련된 객체의 집합   window객체가 최상위 객체   웹브라우저가 제공하는 기능      DOM의 정의(MDN참조)    DOM은 Document Object Model의 약자이다.     HTML, XML 문서의 프로그래밍 인터페이스   문서의 구조화된 표현을 제공하고, 프로그래밍 언어가 DOM구조에 접근할 수 있는 방법을 제공해서 문서구조, 스타일, 내용등을 변경할 수 있게 한다.   웹페이지를 스크립트 또는 프로그래밍 언어들에서 사용되도록 연결해준다.   DOM이 무엇인가…     내가 html에 쓴 파일이 DOM은 아니다. 그러나 브라우저에 의해서 파싱이 된다면 DOM이 된다.   view source에서 보이는것도 DOM이 아니다.   dev Tools(개발자 도구)에서 보여주는 것이 DOM이다.   DOM은 웹페이지의 객체 지향 표현이고, 자바스크립트와 같은 스크립트 언어로 DOM을 수정할수 있다.   ","categories": ["javascript"],
        "tags": ["DOM"],
        "url": "/javascript/dom/",
        "teaser": null
      },{
        "title": "10 - Vuex - 주요 기술 요소",
        "excerpt":"10.1 Vuex 설치 및 등록   Vuex 설치하기 vuejs 공식 문서   NPM  1 2 // npm install vuex@next --save // 공식문서에 써있는 걸로 설치하면 Vue3를 기준으로 설치 되므로 코어 라이브러리는 버전을 명시해줘야함 npm i vuex@3.4.0   Yarn  1 2 // yarn add vuex@next --save yarn add vuex@3.4.0 // yarn을 사용하면 yarn으로 설치해야 함   components 폴더랑 같은 레벨에 stor 폴더 만들기      diff check    10.2 state와 getters 소개   Vuexa 기술 요소     state : 여러 컴포넌트에 공유되는 데이터 data   getters : 연산된 state 값을 접근하는 속성 computed   mutations : state 값을 변경하는 이벤트 로직, 메서드 methods   actions : 비동기 처리 로직을 선언하는 메서드 async methods   State란?     여러 컴포넌트 간에 공유할 데이터 - 상태   1 2 3 4 5 6 7 8 9 // vue data: {     message: 'Hello Vue.js' }  // vuex state: {     message: 'Hello vue.js }  1 2 3 4 5 6 7 8  &lt;!-- Vue --&gt; &lt;p&gt;{{ message }}&lt;/p&gt;   &lt;!-- Vuex --&gt; &lt;p&gt;{{ this.$store.state.message }}&lt;/p&gt;    getters란?     state 값을 접근하는 속성이자 computed() 처럼 미리 연산된 값을 접근하는 속성   1 2 3 4 5 6 7 8 9 10 11 12 // store.js state: {     num: 10 }, getters: {     getNumber(state) {         return state.num;     },     doubleNumber(state) {         return state.num * 2;     } }  1 2 3 4  &lt;p&gt;{{ this.$store.getters.getNumber }}&lt;/p&gt; &lt;p&gt;{{ this.$store.getters.doubleNumber }}&lt;/p&gt;    10.3 [리팩토링] state 속성 적용   store.js     const storage 변수를 설정하고 fetch() 함수에 기존 App.vue에서 created로 가져오던 localStorage에 담긴 배열을 뿌려주는 로직을 옮기기   state에서 todoItems: storage.fetch()로 todoItems에 storage변수의 fetch() 함수 연결   TodoList.vue v-for=\"(todoItem, index) in propsdata\" propsdata에서 반복문을 돌리던 것을 v-for=\"(todoItem, index) in this.$store.state.todoItems로 수정      diff check    10.4 mutations와 commit() 형식 소개   mutations란?     state의 값을 변경할 수 있는 유일한 방법이자 메서드   뮤테이션은 commit() 으로 동작시킨다.   1 2 3 4 5 6 7 8 9 10 // store.js state: { num: 10 }, mutations: {     printNumbers(state) {         return state.num     },     sumNumbers(state, anotherNum) {         return state.num + anotherNum;     } }  1 2 this.$store.commit('printNumbers'); this.$store.commit('sumNumbers', 20);   mutations의 commit() 형식     state를 변경하기 위해 mutations를 동작시킬 때 인자(payload)를 전달할 수 있음   1 2 3 4 5 6 7 8 // store.js state: { storeNum: 10 }, mutations: {     modifyState(state, payload) {         console.log(payload.str)         return state.storeNum += payload.num;     } }  1 2 3 4 this.$store.commit('modifyState' {     str: 'passed from payload',     num: 20 });   두번째 인자로 값을 넘길 수 있음, 여러개를 보낼때는 객체형태로 보내면 된다.   10.5 [리팩토링&amp;퀴즈] mutations 적용 및 퀴즈 안내   Store.js     App.vue의 methods에 있던 addOneItem을 store.js의 mutations로 옮기기   addOneItem의 첫번째 인자로 state에 접근하기 위해서 state 넣기   TodoInput.vue에서 입력된 값을 this.newTodoItem에 넣어서 보내는데 이것을 받기 위해서 두번째 인자에 todoItem 넣기   TodoInput.vue     기존에 $emit으로 넘기던 이벤트를 this.$store.commit('addOneItem', this.newTodoItem);로 store의 mutations 동작시킴      diff check    10.6 [리팩토링&amp;퀴즈] mutations 퀴즈 풀이 및 할 일 지우기 기능 구현      removeOneItem은 두번째 인자를 여러개를 받아야해서 객체 형태로 보내기   TodoList.vue에 const obj = {todoItem, index}로 변수에 객체로 넣어주고 store.js에서 두번째 인자로 payload를 넣어주고 안에서 payload.todoItem 으로 접근   매번 객체를 변수에 담아주기가 번거로우니 바로 commit()의 두번째 인자에 this.$store.commit('removeOneItem', {todoItem, index}); 객체를 넣어줌   10.7 [리팩토링] mutations로 할 일 추가, 완료, 모두 삭제 구현      App.vue 필요없는 부분 정리      diff check    10.8 왜 mutations로 상태를 변경해야 하는가?      여러 개의 컴포넌트에서 아래와 같이 state 값을 변경하는 경우 어느 컴포넌트에서 해당 state를 변경했는지 추적하기 어렵다.   1 2 3 methods: {     increaseCounter() { this.$store.state.counter++;} }      특정 시점에 어떤 컴포넌트가 state를 접근하여 변경한 건지 확인하기 어렵기 때문   따라서, 뷰의 반응성을 거스르지 않게 명시적으로 상태 변화를 수행. 반응성, 디버깅, 테스팅 혜택   state는 여러개의 컴포넌트에서 공유하고 있기 때문에 특정 컴포넌트에서 변경했을때 추적을 해야한다. 10개의 컴포넌트에서 변경한다고 했을때 어느시점에 어느 컴포넌트에서 변경했는지 알기가 어려움, mutations를 거쳐야 뷰 개발자 도구에서 추적이 가능하다.(어떻게…?)   10.9 actions 소개 및 예제   actions란?     비동기 처리 로직을 선언하는 메서드, 비동기 로직을 담당하는 mutations   데이터 요청, Promise, ES6 async와 같은 비동기 처리는 모두 actions에 선언      Promise 이해하기 자바스크립트 비동기 처리 이해하기    1 2 3 4 5 6 7 8 9 10 11 12 13 14 // store.js state: {     num: 10 }, mutations: {     doubleNumber(state) {         state.num * 2;     } }, actions: {     delayDoubleNumber(context) { // context로 store의 메서드와 속성 접근         context.commit('doubleNumber');     } }  1 2 // App.vue this.$store.dispatch('delayDoubleNumber');   actions 비동기 코드 예제1   1 2 3 4 5 6 7 8 9 10 11 // store.js mutations: {     addCounter(state) {         state.counter++     }, }, actions: {     delayedAddCounter(context) {         setTimeout(() =&gt; context.commit('addCounter'), 2000);     } }  1 2 3 4 5 6 // App.vue methods: {     incrementCounter() {         this.$store.dispatch('delayedAddCounter');     } }      mutations는 commit이라는 api로 호출하고 actions는 dispatch라는 api로 호출   actions 비동기 코드 예제2   1 2 3 4 5 6 7 8 9 10 11 12 // store.js mutations: {     setData(state, fetchedData) {         state.product = fetchedData     }, }, actions: {     fetchProductData(context) {         return axios.get('https://domain.com/products/1')                     .then(response =&gt; context.commit('setData', response));     } }  1 2 3 4 5 6 // App,vue methods: {     getProduct() {         this.$store.dispatch('fetchProductData');     } }      getProduct()메서드를 실행하면 actions의 fetchProductData를 실행   axios가 get이라는 http 요청을 서버에 보낸다.   받아오면 then이라는 Promise 콜백으로 응답을 받아서 응답을 setData() mutations를 실행해서 응답을 인자로 넘긴다.   mutations에서 state의 product에 접근해 서버에서 받아온 응답값(response)을 fetchedData에 넣어준다.   10.10 왜 actions에 비동기 로직을 선언해야 하는가?      언제 어느 컴포넌트에서 해당 state를 호출하고, 변경했는지 확인하기가 어려움            여러개의 컴포넌트에서 mutations로 시간차를 두고 state를 변경하면 값의 변화를 추적하기 어렵기 때문에 mutations 속성에는 동기 처리 로직만 넣어야 한다.          ","categories": ["vue-lv2"],
        "tags": ["vue","vuex","store"],
        "url": "/vue-lv2/vue-intermediate10/",
        "teaser": null
      },{
        "title": "11 - Vuex - 헬퍼 함수",
        "excerpt":"11.1 헬퍼 함수 및 ES6 Spread 연산자 소개   각 속성들을 더 쉽게 사용하는 방법 - Helper   store에 있는 아래 4가지 속성들을 간편하게 코딩하는 방법     state -&gt; mapState   getters -&gt; mapGetters   mutations -&gt; mapMutations   actions -&gt; mapActions   헬퍼의 사용법     헬퍼를 사용하고자 하는 vue 파일에서 해당 헬퍼를 로딩   1 2 3 4 5 6 7 8 9 10 // App.vue import { mapState } from 'vuex' import { mapGetters } from 'vuex' import { mapMutations } from 'vuex' import { mapActions } from 'vuex'  export default {     computed() { ...mapState(['num']), ...mapGetters(['countedNum']) },     methods: { ...mapMutations(['clickBtn']), ...mapActions(['asyncClickBtn']) } }   11.2 mapState, mapGetters 소개 및 ES6 Spread 연산자 쓰는 이유   mapState     Vuex에 선언한 state 속성을 뷰 컴포넌트에 더 쉽게 연결해주는 헬퍼   1 2 3 4 5 6 7 8 9 10 11 12 // App.vue import { mapState } from 'vuex'  computed() {     ...mapState(['num'])     // num() { return this.$store.state.num; } }  // store.js state: {     num: 10 }  1 2 &lt;!-- &lt;p&gt;{{ this.$store.state.num }}&lt;/p&gt; --&gt; &lt;p&gt;{{ this.num }}&lt;/p&gt;   mapGetters     Vuex에 선언한 getters 속성을 뷰 컴포넌트에 더 쉽게 연결해주는 헬퍼   1 2 3 4 5 6 7 8 9 10 11 12 13 // App.vue import { mapGetters } from 'vuex'  computed() {      ...mapGetters(['reverseMessgae'])  }  // store.js getters: {     reversMessage(state) {         return state.msg.split('').reverse().join('');     } }  1 2 &lt;!-- &lt;p&gt;{{ this.$store.getters.reversMessage }}&lt;/p&gt; --&gt; &lt;p&gt;{{ this.reversMessage }}&lt;/p&gt;   11.3 [리팩토링] getters와 mapGetters 적용하기   store.js     getters에 storedTodoItems변수 지정하고 state의 todoItmes에 접근   TodoList.vue     computed에 todoItmes() 메서드에 this.$store.getters.storedTodoItems; 리턴 시켜주기      diff check       diff check    11.4 mapMutations, mapActions 소개 및 헬퍼의 유연한 문법   mapMutations     Vuex에 선언한 mutations 속성을 뷰 컴포넌트에 더 쉽게 연결해주는 헬퍼   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // App.vue import { mapMutations } from 'vuex'  methods: {     ...mapMutations(['clickBtn']),     authLogin() {},     displayTable() {} }  // store.js mutations: {     clickBtn(state) {         alert(state.msg);     } }  1 &lt;button @click=\"clickBtn\"&gt;popup message&lt;/button&gt;   mapActions     Vuex에 선언한 actions 속성을 뷰 컴포넌트에 더 쉽게 연결해주는 헬퍼   1 2 3 4 5 6 7 8 9 10 11 12 13 // App.vue import { mapActions } from 'vuex'  methods: {     ...mapActions(['delayClickBtn']), }  // store.js actions: {     delayClickBtn(context) {         setTimeout(() =&gt; context.commit('clickBtn'), 2000);     } }  1 &lt;button @click=\"delayClickBtn\"&gt;delay popup message&lt;/button&gt;   헬퍼의 유연한 문법     Vuex에 선언한 속성을 그대로 컴포넌트에 연결하는 문법     1 2 3 4 5 // 배열 리터럴 ...mapMutations([   'clickBtn', // 'clickBtn': clickBtn   'addNumber' // addNumber(인자) ])           Vuex에 선언한 속성을 컴포넌트의 특정 메서드에다가 연결하는 문법     1 2 3 ...mapMutations({   popupMsg: 'clickBtn' // 컴포넌트 메서드 명: Store의 뮤테이션 명 })           11.5 [리팩토링 &amp; 퀴즈] mapMutations 적용 및 퀴즈      헬퍼 함수들은 인자를 선언하지 않아도 함수를 호출하는 시점에 인자를 넘기면 그대로 가져온다.      diff check    11.6 [리팩토링 &amp; 퀴즈] mapMutations 퀴즈 풀이      diff check    11.7 헬퍼 함수가 주는 간편함      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue","vuex","store","helper"],
        "url": "/vue-lv2/vue-intermediate11/",
        "teaser": null
      },{
        "title": "12 - Vuex - 프로젝트 구조화 및 모듈화",
        "excerpt":"12.1 스토어 속성 모듈화 방법   프로젝트 구조화와 모듈화 방법1   아래와 같은 store 구조를 어떻게 모듈화 할 수 있을까?   1 2 3 4 5 6 7 8 9 10 // store.js import Vue from 'vue' import Vuex from 'vuex'  export const store = new Vuex.Store({     state: {},     getters: {},     mutations: {},     actions: {} })   힌트! Vuex.Store({})의 속성을 모듈로 연결 모듈이라고 하면 각각의 속성의 내용들을 별도의 파일로 분리해서 파일들을 불러와서 담아주기      ES6의 Import &amp; Export를 이용하며 속성별로 모듈화   1 2 3 4 5 6 7 8 9 10 11 12 import Vue from 'vue' import Vuex from 'vuex' import * as getters from 'store/getters.js' import * as mutations from 'store/mutations.js' import * as actions from 'store/actions.js'  export const store = new Vuex.Store({     state: {},     getters: getters,     mutations: mutations,     actions: actions })      diff check    12.2 스토어 모듈화 방법   프로젝트 구조화와 모듈화 방법2     앱이 비대해져서 1개의 store로는 관리가 힘들 때 modules 속성 사용   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // store.js import Vue from 'vue' import Vuex from 'vuex' import todo from 'models/todo.js'  export const store = new Vuex.Store({     modules: {         moduleA: todo, // 모듈 명칭 : 모듈 파일명         todo // todo: todo     } });  // todo.js const state = {} const getters = {} const mutations = {} const actions = {}      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue","vuex","store","module"],
        "url": "/vue-lv2/vue-intermediate12/",
        "teaser": null
      },{
        "title": "call/apply/bind 함수의 차이점",
        "excerpt":"call/apply/bind 함수의 차이점은?   예제를 보고 확인해보자.      예)    1 2 3 4 5 6 7     const obj = {name:'maru'};     const live = function(city){         console.log(`Hi my name is ${this.name}, I live in ${city}`);     };     live('korea'); // Hi my name is , I live in korea     live.call(obj, 'korea'); // Hi my name is maru, I live in korea     live.apply(obj, ['korea']); // Hi my name is maru, I live in korea   call과 apply는 함수를 호출하는 함수  첫번째 인자인 “obj”로 this를 변경하고 함수를 실행한다.  (apply는 파라미터를 배열로 넣어야 한다.)      예)    1 2 3 4 5 6     const obj = {name:'maru'};     const live = function(city){         console.log(`Hi my name is ${this.name}, I live in ${city}`);     };     const bound = live.bind(obj)     bound('korea'); // Hi my name is maru, I live in korea   bind함수는 함수를 실행하지 않는다.   ","categories": ["javascript"],
        "tags": ["function","call","apply","bind"],
        "url": "/javascript/call-apply-bind/",
        "teaser": null
      },{
        "title": "api",
        "excerpt":"api에 대해 알아보자   “API(Application Progtamming Interface, 응용프로그램 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.” -위키백과   api는 프로그램이 서로 상호작용하는 것을 도와주는 매개체라고 볼 수 있다.  프로그램이 주문하도록 명령을 정리하고, 그 명령을 받아서 응용프로그램과 상호작용하여 요청된 명령에 대한 값을 전달한다.      서버와 데이터베이스의 출입구 역할을 한다.   애플리케이션과 기기가 원활하게 통신하도록 한다.   모든 접속을 표준화 한다.   개발자들이 어플리케이션 코드 작성을 표준화 해서 빠르고 간단히 프로세스 처리가 가능하다.  또한 개발자들간의 협업도 용이해진다.   즉, api는 어떠한 응용프로그램에서 데이터를 주고받기 위한 방법이다.  특정 사이트에서 데이터를 공유할때 어떤 방식으로 요청해야 하는지, 어떤 데이터를 제공 받을수 있는지에 대한 규격들을 말한다.   ","categories": ["javascript"],
        "tags": ["api"],
        "url": "/javascript/api/",
        "teaser": null
      },{
        "title": "호이스팅(Hoisting)",
        "excerpt":"hoisting에 대해 알아보자      자바스크립트에서 호이스팅(Hoisting)이란, 인터프리터가 변수와 함수의 공간을 선언전에 미리 할당 하는 것을 의미한다.    실행컨텍스트의 처리 순서를 살펴보면,     선언 단계(Declaration phase) : 변수, 함수선언문 설정   초기화 단계(Initialization phase) : 변수 이름 바인딩 (값은 undefined로 초기화)   할당 단계(Assignment phase)   위 순서로 처리가 된다.   이때, let변수는 호이스팅 되지 않는다.(사실상 호이스팅은 되지만 안되는것과 비슷하다.) var 변수는 선언단계와 초기화단계가 동시에 진행되어 변수이름을 바인딩하면서 값이 undefined로 초기화되는 반면,  let 변수는 선언단계와 초기화단계가 따로 진행된다.  그래서 실행컨텍스트에 변수가 등록이 되었지만 메모리가 할당이 되어있지 않기 때문에 ReferenceError가 발생한다.   여기서 TDZ가 무엇인지 알고 가자.  TDZ란 “temporal dead zone” 일시적인 사각지대 라고 직역할 수 있다.  TDZ는 스코프의 시작지점 부터 초기화 단계 직전까지의 구간이다.   즉, let변수는 TDZ구간에 의해 메모리가 할당이 되지 않기 때문에 참조에러(ReferenceError)가 발생한다.      예)    1 2 3 4 5     console.log(`스포츠: ${sports}`); // 스포츠: undefined     var sports = '축구';      console.log(`스포츠: ${sports}`); // ReferenceError: sports is not defined     let sports = '축구';  ","categories": ["javascript"],
        "tags": ["hoisting"],
        "url": "/javascript/hoisting/",
        "teaser": null
      },{
        "title": "REST",
        "excerpt":"REST에 대해 알아보자   REST에 대해 알아보기전에 api에 대해 다시 한번 확인해보자.  api에 대한 포스팅이 따로 있지만 여기에서는 비유를 통해 간단히 설명한다.   좋아하는 드라마의 본방사수를 위해서 집에 서둘러 들어와 티비를 켜고 원하는 채널을 틀어야 하는 상황일때 이러한 과정이 필요하다.  티비 리모컨의 전원 버튼을 눌러 티비를 켜고 채널 버튼을 눌러 원하는 채널로 돌려야 한다.  나 &gt; 리모컨 &gt; 티비 이러한 순서로 볼 수 있다.   즉 API는 리모컨 처럼 애플리케이션과 운영체게 사이의 ‘상호작용’을 돕는다.   웹 API의 역할      권한을 가진 사람만 서버와 데이터베이스안의 리소스에 접근이 가능하게 해준다.   모든 요청(request)와 응답(response)를 표준화 해준다.   REST의 구성요소      자원(Resource) : HTTP UIR 를 통한 자원 명시   자원에 대한 행위(Verb) : HTTP Method(post, get put, delete)   자원에 대한 행위의 내용(Representations) : HTTP Message Pay Load   REST API   REST API란 REST의 원리를 따르는 API를 의미한다. 리소스(HTTP URI)로 어떠한 행위(HTTP Method + Pay Load)를 하겠다는 것을 구조적으로 표현하는 방법이다.   REST API의 설계 가이드를 살펴보자.      URI는 명사, 소문자를 사용한다.   마지막에 슬래시를 포함하지 않는다.   언더바 대신 하이픈을 사용한다.   URI에 파일확장자는 포함하지 않는다.   RESTful 이란?   RESTful이란 REST API의 설계 가이드를 올바르게 지킨 시스템을 RESTful 하다고 말할 수 있다. RESTful하게 만들면 그자체로 API의 목적이 무엇인지 명확하게 알 수 있다.  ","categories": ["javascript"],
        "tags": ["api","REST"],
        "url": "/javascript/rest/",
        "teaser": null
      },{
        "title": "some vs every / foreach vs map 반복문 차이",
        "excerpt":"반복문의 차이점      some : 하나라도 true면 true   every : 모두 true여야 true   다른 메소드와의 차이는? 조건에 충족하면 반복을 멈춘다.  즉, 최단시간에 최대 효과를 추구 (필요없는 반복을 하지 않음)      foreach : 반환값이 없다. (순환만)        map : 배열을 반환 (새배열 생성 가능)       filter는 map과 비슷한데, 대신 조건을 걸 수 있다. (조건에 부합하는 것만 배열로 반환)  ","categories": ["javascript"],
        "tags": ["some","every","foreach","map"],
        "url": "/javascript/some-every/",
        "teaser": null
      },{
        "title": "LocalStorage 데이터 저장은 string",
        "excerpt":"LocalStorage에 데이터 저장해서 사용하기   개요     공지사항 상세보기 페이지에서 수정하기로 넘어 갈때 기존에는 라우터에 params에 데이터(현장코드, 분류, 내용 등등) 넣어서 넘김   수정하기 페이지에서 받을때도 this.$route.params.isEdit로 받아서 객체 안의 데이터를 화면에 뿌려줌   문제는 params 정보는 상세보기 페이지에서 넘겨주는 정보라서 수정하기 페이지에서 새로고침시 정보가 초기화 돼서 수정하기 화면의 데이터가 초기화 됨   해결 방법     상세보기 페이지에서 데이터를 LocalStorage에 setItem으로 저장   수정하기 페이지에서 getItem으로 받아오기   주의할 점     LocalStorage에 Object값과 Boolean값 저장   데이터 타입 로그를 찍어보면 둘다 string으로 나옴   string으로 넣고 getItem으로 가져올때 원본 타입으로 가져오기      Object   1 2 3 4 5 6 7 8 9 // 로컬스토리지에 저장해야 하는 파일(NoticeView.vue) localStorage.setItem('editData', JSON.stringify(this.gettersFN_000032[0]));  // 객체 &gt; 스트링으로 변환해서 저장   // 로컬스토리지에서 가져와야 하는 파일(NoticeWrite.vue) this.selectSite.editData = JSON.parse(localStorage.getItem('editData') as string);  // 다시 스트링 &gt; 객체로 변환해서 가져오기 // as string: 에러메시지 'null 또는 string 타입 인자는 string 타입의 파라미터에 할당 될 수 없다. null타입은 string타입에 할당될 수 없다.'가 떠서 string으로 선언      Boolean   1 2 3 4 5 6 7 8 // 로컬스토리지에 저장해야 하는 파일(NoticeView.vue) data() {     isEdit: true; } localStorage.setItem('isEdit', this.isEdit); // 로컬스토리지를 거치면 타입이 string이 됨  // 로컬스토리지에서 가져와야 하는 파일(NoticeWrite.vue) this.getIsEdit = localStorage.getItem('isEdit') === 'true'; // 값을 Boolean형태로 반환하도록   +추가) 공지사항 새로고침 이슈   신규등록   NoticeList.vue     localStorage.removeItem &gt; isEdit(수정하기인지 확인하는 boolean값), editData(공지사항 수정하기 데이터) 삭제   const obj에 NM_SITE, CD_SITE 속성 추가   로컬스토리지에 저장 localStorage.setItem('params', JSON.stringify(obj));   등록하기 페이지 들어오면 this.selectSite = JSON.parse(localStorage.getItem('params') as string);로 로컬스토리지 가져와서 selectSite에 객체 넣어줌   selectSite의 각 속성 가져와서 화면에 뿌려줌 ``   수정등록   NoticeView.vue     created 됐을때 localStorage.setItem('editData', JSON.stringify(this.gettersFN_000032[0]));로 로컬스토리지 저장   data에 isEdit: true 정의   moveNoticeUpdate 수정하기 클릭하면 localStorage.setItem('isEdit', this.isEdit);로 로컬스토리지에 isEdit: true 저장 NoticeWrite.vue   data에 getIsEdit: false 정의   this.getIsEdit = localStorage.getItem('isEdit') === 'true'; 로컬스토리지에서 boolean값 가져오기(true)   if (this.getIsEdit)일때 this.isEdit = true; isEdit가 false로 넘어와서 true로 바꿔주기   this.selectSite.editData = JSON.parse(localStorage.getItem('editData') as string); 로컬스토리지에서 editData에 넣어둔 공지사항 데이터 가져오기   selectSite.editData의 각 속성 가져와서 화면에 뿌려줌 ``   ","categories": ["javascript"],
        "tags": ["localstorage"],
        "url": "/javascript/localstorage/",
        "teaser": null
      },{
        "title": "Vue에서 Fontawesome 사용하기",
        "excerpt":"Vue에서 Fontawesome 사용하기   폰트어썸 업데이트하면서 부터인지 vue에서 사용하려면 메일로 무료키트 사용 링크를 받아야한다.  fontawsome.com/start로 접속 &gt; 이메일 입력 &gt; 확인, 설정 버튼 클릭 &gt; 폰트어썸 로그인 후 무료키트 링크 카피해서 index.html 헤드에 추가  ","categories": ["vue-lv2"],
        "tags": ["fontawesome"],
        "url": "/vue-lv2/fontawesome/",
        "teaser": null
      },{
        "title": "git commit 메세지 수정",
        "excerpt":"마지막 commit 메세지 수정하기      git commit –amend -m “바꿀 메세지”  or  git commit –amend  까지 입력후 vi 에서 i(수정모드)로 변경하고 수정 후 esc 누르고 :wq로 저장    이전 commit 메세지 수정하기   rebase 명령어를 사용  rebase 명령어는 branch의 base를 다시 설정하여 master브랜치와 merge commit생성을 방지하여 깔끔한 커밋을 남길 수 있도록 도와주는 명령어      git rebase -i HEAD~3    rebase에서 -i 옵션을 주면 rebase명령을  대화형으로 수행하여 여러 커밋들의 순서를 바꾸거나 커밋 히스토리를 변경 또는 삭제할 때 사용  HEAD~3 은 최근 커밋 메시지중 3개만 불러온다는 뜻   입혁하면 최근 커밋 메시지 3개를 불러오는데      pick 커밋번호 커밋메시지    형식으로 출력   이때 수정하고 싶은 commit 내역의 pick을 reword로 바꾸고 :wq로 저장 종료  종료가 되면 선택한 commit 메시지에 대한 화면이 다시 터미널에 호출  위와 동일하게 vi 에서 i(수정모드)로 변경하고 수정 후 esc 누르고 :wq로 저장   원격에 이미 Push 했을 때   commit이 이미 원격에 push 되었다면 커밋 메시지를 수정하고      git push origin master(혹은 브랜치명) -f    로 강제 덮어씌우기   *** 개인 레포지토리나 개인 브랜치가 아닌 협업 마스터 브랜치에는 위험할 수 있음  ","categories": ["git"],
        "tags": ["commit"],
        "url": "/git/git-commit-edit/",
        "teaser": null
      },{
        "title": "git branch",
        "excerpt":"git branch 생성하고 사용하는 방법      git init : git 저장소 생성(초기화)   git remote add origin {link} : link에 생성한 레포지토리 url복사해서 넣기   git branch : 깃 브랜치 확인   git branch -v : 마지막 커밋메세지 확인   git branch ‘브랜치명’ : 브랜치 생성   git checkout ‘브랜치명’ : 선택한 브랜치로 이동   git branch -d ‘브랜치명’ : 브랜치 삭제하기   git merge ‘합칠 브랜치명’ : 현재위치한 브랜치에 합칠 브랜치에서 작업한 내용 가져와서 병합   git add . : 변경한 파일을 저장   git commit -m “커밋메세지” : 커밋메세지 입력        git push origin ‘브랜치명’ : 원격저장소 브랜치에 push 하기       git clone -b ‘브랜치명’ –single-branch ‘저장소url’ : 특정 브랜치만 clone 하기   git remote remove origin : 기존 리포지토리 remote 제거   git config –unset user.name : git config –list 삭제  ","categories": ["git"],
        "tags": ["branch"],
        "url": "/git/gitbranch/",
        "teaser": null
      },{
        "title": "flex에 대해서",
        "excerpt":"flex에 대한 정리   ","categories": ["css"],
        "tags": ["css","flex","grow","shirink"],
        "url": "/css/flex/",
        "teaser": null
      },{
        "title": "상단 박스 height 유동적일때 하단 박스 oveflow scroll 시키기(feat. flex)",
        "excerpt":"상단 컨텐츠의 높이값이 유동적으로 바뀌고 하단 박스만 overflow scroll 하는 법   스크롤시 상단 컨텐츠는 고정, 하단 컨텐츠만 overflow-y: auto 시켜야 하는 레이아웃 구현하기   레이아웃 상세 상단 컨텐츠 : 상단 컨텐츠는 내용에 따라서 height값 유동적  하단 컨텐츠 : 리스트를 보여주며 디바이스에서 상단 컨텐츠 height를 뺀 만큼 보이고 overflow 되는 부분은 scroll   코드 보기           1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt;     * {         margin: 0;         padding: 0;     }     .container {         display: flex;         flex-direction: column;         min-height: 100vh;     }     .topBox {         flex: 0;         background: rgb(174, 101, 177);         color: #fff;         padding: 1.2rem      }     .bottomBox {         position: relative;         flex: 1;     }     .scrollBox {         position: absolute;         left: 0; top: 0; right: 0; bottom: 0;         overflow-y: auto;     }     li {         list-style: none;         width: 100%;         height: 150px;         border-bottom: 1px solid #ddd;         align-items: center;         justify-content: center;         display: flex;     }   &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;div class=\"container\"&gt;         &lt;div class=\"topBox\"&gt;헤더 자리&lt;/div&gt;             &lt;div class=\"bottomBox\"&gt;                 &lt;div class=\"scrollBox\"&gt;                     &lt;ul&gt;                         &lt;li&gt;&lt;span&gt;리스트1&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트2&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트3&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트4&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트5&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트6&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트7&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트8&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트9&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트10&lt;/span&gt;&lt;/li&gt;                     &lt;/ul&gt;                 &lt;/div&gt;             &lt;/div&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;      topBox와 bottomBox를 전체 container박스로 묶는다.   bottomBox안에 리스트 박스를 넣는다.   스타일 적용            전체 박스에 display: flex; flex-direction: column; min-height: 100vh;       topBox에 flex: 0;       bottomBox에 position: relative; flex: 1;       리스트 박스에 position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow-y: auto;           적용 예시)        참고 링크   ","categories": ["css"],
        "tags": ["css","flex","overflow","scroll"],
        "url": "/css/flexbox_scroll/",
        "teaser": null
      },{
        "title": "vuex",
        "excerpt":"vuex 소개      복잡한 애플리케이션의 컴포넌트들을 효율적으로 관리하는 vuex 라이브러리   React의 Flux패턴에서 기인함   vue.js 중고급 개발자로 성장하기 위한 필수 관문   Flux란?      MVC 패턴의 복잡한 데이터 흐름 문제를 해결하는 개발 패턴            action : 화면에서 발생하는 이벤트 또는 사용자의 입력       dispatcher : 데이터를 변경하는 방법, 메서드       model : 화면에 표시할 데이터       view : 사용자에게 비춰지는 화면           MVC패턴과 Flux패턴 비교              view : 보고있는 화면       model : 데이터       controller : model과 view 제어                    Flux패턴은 action에서 view까지 단방향으로 일어남 반면 MVC패턴은 model과 view가 서로 데이터를 주고받아서 양방향으로 일어남                            MVC패턴의 문제점              기능 추가 및 변경에 따라 생기는 문제점을 예측할 수 없음.       앱이 복잡해지면서 생기는 업데이트 루프           Flux패턴의 단방향 흐름              데이터의 흐름이 여러 갈래로 나뉘지 않고 단방향으로만 처리           vuex가 왜 필요할까?   복잡한 애플리케이션에서 컴포넌트의 개수가 많아지면 컴포넌트간에 데이터 전달이 어려워진다.      vuex로 해결할 수 있는 문제            MVC 패턴에서 발생하는 구조적 오류       컴포넌트 간 데이터 전달 명시       여러 개의 컴포넌트에서 같은 데이터를 업데이트 할 때 동기화 문제           이벤트 버스로 해결?  어디서 이벤트를 보냈는지 혹은 어디서 이벤트를 받았는지 알기 어려움  1 2 3 4 5 6 7 8 // Login.vue eventBus.$emit('fetch', loginInfo);  // List.vue eventBus.$on('display', data =&gt; this.displayOnScreen(data));  // Chart.vue eventBus.$emit('refreshData', chartData);  컴포넌트 간 데이터 전달이 명시적이지 않음   vuex 컨셉      State : 컴포넌트 간에 공유하는 데이터 data()   View : 데이터를 표시하는 화면 template   Mutations: state값을 변경하는 이벤트 로직, 메서드 methods   Action : 사용자의 입력에 따라 데이터를 변경하는 (비동기 처리 로직을 선언) aysnc methods   흐름 설명 : 화면(view)에서 버튼을 클릭 하면 버튼이 action을 발생시킴 &gt; action이 발동하면 데이터(state)를 변경   vuex 구조   컴포넌트 -&gt; 비동기 로직 -&gt; 동기 로직 -&gt; 상태   action : 비동기 로직  mutations : 동기 로직   자바스크립트 비동기 처리와 콜백함수 참고 링크  ","categories": ["vue-lv2"],
        "tags": ["vuex","store"],
        "url": "/vue-lv2/vuex/",
        "teaser": null
      },{
        "title": "1 - 소개 및 설계",
        "excerpt":"1.1 소개 및 설계   해커뉴스 사이트 제작  해커뉴스 공식사이트   API를 호출해서 화면에 표시하고 링크 연결하거나 정보등 페이지로 넘어가게 제작 해커뉴스 API 문서   1.2 애플리케이션 라우터 설계   사이트 설계 : 기획서를 토대로 컴포넌트 기반으로 설계를 해야함 news, ask, jobs 라는 리스트를 표시하는 페이지 3개를 라우터로 설계  각 페이지에서 리스트를 클릭했을때 넘어가는 뷰 페이지와 사용자 정보를 보여주는 페이지까지 총 다섯개   1.3 비공개 리포지토리 소개 및 뷰 cli 설명   vue create 프로젝트폴더이름   1.4 Vue CLI 2.x vs Vue CLI 3.x   vue CLI 사이트 webpack-simple 템플릿 깃헙 주소   명령어     2.x : vue init ‘프로젝트 템플릿 이름’ ‘파일위치’ vue init webpack-simple new-project   3.x : vue create ‘프로젝트 이름’ vue create new-project   웹팩 설정 파일     2.x : 노출 O   3.x : 노출 X 웹팩이 복잡하기 때문에 그 설정 파일을 사용자들에게 노출시키지않고 라이브러리 내부에서 알아서 처리하겠다 라는 것.  2점대에서 웹팩에 대한 이해도가 높으면 어떤걸 설정해야될 때, webpack.config.js에 바로 옵션들을 추가하는식으로 했지만,  3점대 이상에서는 웹팩 설정을 추가해야될 때, 별도의 내용들을 추가해야됨. 그 내용들을 vue cli 사이트 가서 webpack을 검색해보면 추가 설정 관련 설명이 나옴     1 2 3 4 5 6 7 8 // vue.config.js module.exports = { configureWebpack: {   plugins: [     new MyAwesomeWebpackPlugin()   ] } }          위와 같이 configureWebpack이라는 설정들을 추가해서 plugins라던지 기타 설정들을 추가할 수 있다.       프로젝트 구성     2.x : 깃헙의 템플릿 다운로드            vuejs-templates       vuejs-templates/webpack-simple 템플릿 다운로드를 통해 정해진 템플릿을 사용한다.           3.x : 플러그인 기반으로 기능 추가 vue plugin이라는 강력한 기능을 사용  이 기능을 이용해서 원하는 기능들 (라우터, Vuex …) 플러그인 형식으로 추가할 수 있도록 뷰에서 제공.   ES6 이해도     2.x : 필요 X   3.x : 필요 O   ","categories": ["vue-lv3"],
        "tags": ["vue"],
        "url": "/vue-lv3/vue-advanced1/",
        "teaser": null
      },{
        "title": "2 - 프로젝트 셋업",
        "excerpt":"2.1 Vue CLI로 프로젝트 생성 및 ESLint 로그 확인   vue create vue-news로 프로젝트 생성   Vue 2선택후 완료 되면 폴더 경로 들어가서 서버 실행하기   2.2 ESLint 도구 소개와 사용해야 하는 이유?   ESLint : javascript 문법 검사기(보조도구) javascript에서 ;(세미콜론)을 찍지 않더라도 자바스크립트 해석기에서는 마지막에 세미콜론을 넣어줌  여기서 ESLint는 세미콜론을 찍게 유도함  예를들어서   1 2 3 4 5 6 7 // 이런식이면 문제 없지만 if(a === 10){   console.log('a는 10'); }  // 자바스크립트 해석기가 어디서 세미콜론을 찍어야 할지 모를때 if(a === 10) console.log('a는 10') b() c()   ","categories": ["vue-lv3"],
        "tags": ["vue"],
        "url": "/vue-lv3/vue-advanced2/",
        "teaser": null
      },{
        "title": "3 - 라우터 기본",
        "excerpt":"3.1 라우터 설치 및 라우터 구현   yarn add vue-router@3.2.0로 설치하기(vue2는 vue-router3 버전사용, vue3는 vue-router4 버전사용)   package.json의 dependencies에 추가됨(배포할때도 포함 되어야 하는 라이브러리들)   라우터 설정을 main.js에 할 수도 있지만, main.js는 기본적으로 애플리케이션의 설정들(플러그인, 라이브러리, 구조들을 파악)의 청사진으로 보면 됨  그래서 라우터는 따로 폴더를 빼줌   3.2 router-view를 이용한 라우팅 컴포넌트 표시   App.vue에 &lt;router-view&gt;&lt;/router-view&gt;로 라우터 컴포넌트 보여줌      diff check    3.3 redirect 속성과 router-link   첫 화면에서 빈화면이 나오는데 redirect속성으로 원하는 라우터로 연결 가능  라우터 이동 링크 버튼도 추가   컴포넌트 등록할때는 스크립트단에서는 단어마다 첫글자 대문자로 연결  컴포넌트를 태그에서 등록할때는 단어사이에 하이픈으로 연결      diff check    3.4 ToolBar의 라우터 링크 스타일링   vue cli scss 설정      diff check    3.5 라우터 폴더 작명 팁과 라우터 mode 안내   mode: ‘history’, // 해쉬값 제거      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","router"],
        "url": "/vue-lv3/vue-advanced3/",
        "teaser": null
      },{
        "title": "4 - API 구현",
        "excerpt":"4.1 axios를 이용한 api 호출   해커뉴스 api      views 폴더에는 페이지 라우팅에 관련된 정보들만 들어가는게 좋다.   설계가 바뀌거나 할때 유연하게 대처하려면 데이터를 불러온다던지 비즈니스 로직들은 별도의 컴포넌트로 등록하는게 좋다.   우선 views안에 바로 넣고 나중에 수정할 예정      diff check    4.2 axios의 api 함수 구조화 방법 및 실습 안내      라이브러리를 각각의 파일에서 불러와야하고, 공통된 로직들이 계속 파일마다 불러와야 하는데 공통화시켜서 사용   data를 요청할때는 created나 beforeMount에서 많이 함 - 마운트 되고나서 데이터를 요청하면 데이터를 받아와서 데이터 배열에 넣으면 뷰의 리액티비티 시스템때문에 화면이 다시 그려짐   return axios.get = return new Promise가 같은 말이고 이것은 promise가 떨어진다는건데 -&gt; 뒤에 .then()을 연결할 수 있다는 뜻   api/index.js     정의한 함수를 다른데서 import로 쓸 수 있도록 export해줘야 함      diff check    4.3 자바스크립트 this 4가지와 화살표 함수의 this   this 가장 최상단에는 window가 있는데 콘솔창에 this를 그냥 찍어보면 window를 가리킨다.  함수안에 console.log(this)를 선언하고 함수를 실행하면 window를 가리킨다. 기본적으로 this는 전역을 향한다.  1 2 3 4 5 function sum(a, b) {     console.log(this); // 전역을 가리킴     return a + b; } sum(10, 20) // window객체와, 30이 찍힘   생성자 함수로 인스턴스를 생성했을 때는  1 2 3 4 5 function Vue(el) {     console.log(this); // 함수 자체를 가리킴     this.el = el; } new Vue('#app'); // Vue{}, Vue{el: '#app'} 이 찍힘   비동기 처리에서의 this     호출 전에는 VueComponent   호출 후에는 undefined   기본적으로 비동기 호출 자체는 호출되는 시점에서 기존에 있었던 this를 벗어난 새로운 this가 생김  그래서 함수밖과 함수안의 this가 다르기 때문에 함수 밖에서 변수에 this를 담아서 바인딩 해줘야 한다.  그러나 화살표 함수를 사용하면 this가 호출되는 위치의 this를 가져온다.      diff check    4.4 자바스크립트 비동기 처리(1) - Callback   Callback 어떤 특정 함수나 기능이 종료되는 시점에 실행 되는 함수  자바스크립트는 함수를 인자로 넘길 수 있는데 인자로 전달되는 함수를 보통 콜백함수라고 표현      diff check    4.5 자바스크립트 비동기 처리(2) - Promise   새로운 비동기 처리 패턴 promise      프로미스 쉽게 이해하기      diff check    ","categories": ["vue-lv3"],
        "tags": ["vue","api","axios","arrow function","비동기처리"],
        "url": "/vue-lv3/vue-advanced4/",
        "teaser": null
      },{
        "title": "5 - 스토어 구현",
        "excerpt":"5.1 Vuex 설치 및 Vuex가 적용된 앱 구조 소개      vuex를 적용해서 api에서 바로 불러오는게 아니고 vuex의 state에 api를 담아서 화면에 표시   yarn add vuex@3.4.0로 vuex 라이브러리 설치   5.2 Vuex 모듈화 및 state 적용      store폴더 생성후 그안에 작성   vuex는 플러그인 형태로 제공 되기 때문에 Vue.use(Vuex);로 사용   vuex는 상태관리 라이브러리이다. 상태라는 것은 여러 컴포넌트간에 공유되는 데이터 속성   NewsView가 users라는 데이터를 다른 컴포넌트에 아직 공유하고 있지 않은 상태인데 만약 다른 컴포넌트에서 users를 뿌려줘야 하는 상황이라면 공유해서 사용해야 한다.      diff check    5.3 NewsView에 actions와 mutations 적용      비동기 호출은 전부 action에서 하고 받아온 데이터를 mutations를 통해서 state에 넣어주게 구분되어 있다.   actions에서 비동기 호출을 하고 첫번째 인자로 context를 주면 mutations에 접근 할 수 있다.   context.commit(‘SET_NEWS’, response.data)   mutations에서는 첫번째 인자로 state를 넣어주고 두번째 인자에는 actions에서 넘겨준 response.data값이 들어간다.   컴포넌트에서 actions에 접근은 dispatch로 한다.      diff check    5.4 JobView에 스토어 적용      Destructuring 사용해서 넣어보기   Dstructuring 설명      diff check    5.5 map 헬퍼 함수를 이용한 AskView 풀이      mapState와 mapGetters는 computed 속성에서 사용   this.$store.state.ask; 이렇게 가져오는것은 더 길어지면 파악하기 힘들기 때문에 헬퍼 함수를 사용하면 편함      diff check    5.6 스토어 속성 모듈화      프로젝트가 커질 수록 store가 길어지니까 모듈화해서 나눠놓는게 좋다.      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","store","vuex"],
        "url": "/vue-lv3/vue-advanced5/",
        "teaser": null
      },{
        "title": "6 - 라우터 실전",
        "excerpt":"6.1 동적 라우트 매칭 원리 및 적용   Dynamic Route Matching     파라미터에 값을 넘겨주고 그 정보를 가지고 페이지를 이동한다.   router에 UserView.vue 컴포넌트 추가   아이디를 클릭했을때 그 값을 어떻게 넘겨서 각 회원 상세페이지를 보여줄까..? path에 /user/:id   router-link를 사용한다.      diff check    6.2 라우터 params을 이용한 User 상세 페이지 구현   news라우트에서 user 이름 클릭시 user 정보 상세페이지 구현     동적라우트 매칭으로 params를 받아왔고 그것을 이용해서 api를 호출   UserView.vue에서 user정보 가져오는 api를 호출 할 수도 있지만 스토어를 사용      api/index.js &gt; fetchUserInfo에 user정보 가져오는 로직 넣기   NewsView에서 클릭한 user이름으로 /user/${item.user} router-link를 통해서 이동   router/index.js에 라우트 등록해주기   UserView에서는 $route안의 params.id값을 const userName에 넣어주고 this.$store.dispatch를 통해서 actions에 있는 FETCH_USER에 접근하고 두번째 인자로 클릭한 username을 넘겨준다.   actions(비동기처리)에서 context를 첫번째 인자로 넘겨서 mutations에 접근할 수 있도록 하고 UserView에서 넘겨받은 username을 받도록 두번째 인자에 name을 넣어준다.   user정보 가져오는 함수 fetchUserInfo를 실행하고 인자로 name을 넘겨준다.   commit으로 SET_USER를 실행한다.   mutations에서 state에 접근해서 user에 비동기로 받아온 데이터를 넣어서 state를 바꾼다.   UserView에서 화면에 데이터를 뿌려준다.      diff check    6.3 질문 상세 페이지 실습 풀이 및 오류 디버깅      ItemView.vue 생성하고 router/index.js에 라우트 등록   AskView.vue에 router-link등록하기 &gt; /item/${item.id}   ItemView에 created에서 itemId 변수에 this.$route.params.id를 넣어준다.(콘솔로 itemId를 찍어봐서 잘 들어오는지 확인해보기)   actions에 FETCH_ITEM 선언하고 이 액션을 호출했을때 불러올 api함수(fetchItemInfo)를 api/index.js에 선언해준다.   api에 선언한 함수(fetchItemInfo)를 acions상단에 import해주고 FETCH_ITEM안에 실행시켜준다.   ItemView에서 created 됐을때 dispatch로 actions의 FETCH_ITEM에 연결해서 api를 호출하도록 하고, 두번째 인자로 params.id를 넣은 변수 itemId를 넣어준다.   다시 actions의 FETCH_ITEM에 ItemView에서 넘겨준 itemId를 여기서는 id(두번째 인자)로 받는다.   actions에 실행한 api함수(fetchItemInfo)가 프로미스 객체이므로 then, catch문을 받을 수 있다.   then에서 commit으로 SET_ITEM(mutations)을 연결한다.   mutations에서 SET_ITEM을 선언하고 첫번째 인자로 state를 넣고 actions에서 비동기처리로 데이터를 data에 받아와서 mutations의 두번째 인자에 item이라고 정의해서 넣어준다.   mutations에서 두번째 인자로 item을 넣었는데 이를 받아줄 item을 store/index.js의 state에서 정의 하지 않았으므로 가서 정의해준다.      diff check    6.4 질문 상세 페이지 스타일링 및 v-html 디렉티브 사용법 소개   불러온 데이터를 화면에 표시      화면에 뿌려주는 항목들을 mapGetters 헬퍼함수를 이용해서 뿌리기   mapGetters를 import한다.   store/index.js에 getter추가   ItemView로 돌아와서 computed 속성에 …mapGetters([‘fetchedItem’]) 정의하고 템플릿영역에서 fetchedItem으로 뿌려줌   content부분이 html태그를 그대로 들고와서 화면에 태그가 노출됨 &gt; v-html=”fetchedItem.content”   v-html API 문서   v-html과 데이터 바인딩 차이점 문서      diff check    6.5 라우터 트랜지션   특정 링크로 이동할때 바로 화면이 바뀌는데 뷰 내부적으로 제공하는 트랜지션 api로 부드러운 화면 전환하기     라우터 트랜지션 문서   뷰 트랜지션 문서   라우터 뷰를 트랜지션 태그로 감싸면 트랜지션 이펙트 사용 가능      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","router"],
        "url": "/vue-lv3/vue-advanced6/",
        "teaser": null
      },{
        "title": "7 - 리스트 아이템 컴포넌트 공통화",
        "excerpt":"7.1 컴포넌트 공통화 리팩토링      각 view페이지 스타일링      diff check    7.2 공통 컴포넌트 ListItem 제작 및 실습 안내      components폴더에 ListItem.vue파일 생성 : 각각의 페이지 컴포넌트가 들고있는 데이터 패치와 스타일링등을 다 들고옴   NewsView.vue에 ListItem.vue import해서 컴포넌트로 넣어줌      diff check    7.3 공통 컴포넌트 구현(1) - 페이지별 데이터 분기      라우터에 있는 정보들로 분기처리 가능   router/index.js에 각 라우트 속성에 name값 정의   ListItem.vue에서 각 라우트 name으로 들어올때 actions의 비동기처리 실행      diff check    7.4 공통 컴포넌트 구현(2) - computed 속성      computed 사용해서 각 페이지 api 뿌리기      diff check    7.5 공통 컴포넌트 구현(3) - template 속성과 v-if 디렉티브 활용      &lt;template v-if=\"\"&gt;&lt;/template&gt; 가상의 태그를 넣고 태그가 vue 내부적으로 분기처리를 해서 v-if안에 해당되는 조건이 있으면 뿌려줌   태그 안에 바로 v-if, v-else 사용 가능      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","공통화"],
        "url": "/vue-lv3/vue-advanced7/",
        "teaser": null
      },{
        "title": "8 - 사용자 프로필 컴포넌트 공통화",
        "excerpt":"8.1 사용자 프로필 컴포넌트 소개 및 등록      사용자 정보 공통 컴포넌트      diff check    8.2 사용자 컴포넌트 데이터 흐름 처리 1      UserView에서 UserProfile로 데이터 넘기기   vuex사용해서 UserProfile에서 바로 접근      diff check    8.3 사용자 컴포넌트 데이터 흐름 처리 2      UserView.vue에서 UserProfile.vue로 :info=\"userInfo\"로 데이터를 넘기고   UserProfile.vue에서 props: { info: Object }로 데이터 받기      diff check    8.4 2가지 데이터 처리 흐름 비교           UserProfile에서 computed로 접근  UserView -&gt; actions에서 api 호출해서 받아오기 -&gt; mutations 호출 -&gt; state변경 -&gt; UserProfile에서 computed로 접근해서 데이터 넘김            UserView에서 props로 전달  UserView -&gt; actions에서 api 호출해서 받아오기 -&gt; mutations 호출 -&gt; state변경 -&gt; UserView에서 props로 UserProfile로 내려줌       8.5 slot을 이용한 사용자 프로필 컴포넌트 구현      slot: 하위컴포넌트에서 미완성으로 넣어둔 부분을 상위에서 하위컴포넌트를 등록할때 그부분을 채워줌      diff check    8.6 코드 정리      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","공통화"],
        "url": "/vue-lv3/vue-advanced8/",
        "teaser": null
      },{
        "title": "9 - Mixin과 하이 오더 컴포넌트",
        "excerpt":"9.1 컴포넌트 재활용 방법 및 재활용할 포인트 소개      dispatch를 분기처리 하기 위해 ListItem에 있던 dispatch를 각각의 view파일로 옮김      diff check    9.2 이벤트 버스를 이용한 스피너 컴포넌트 구현      export 스타일에 따라서 import하는 방법이 달라진다.   1 2 3 4 5 6 7 8 9 10 // default의 경우는 아무 이름이나 정의해서 사용할 수 있다. // bus.js export default new Vue(); // App.vue import bus from './bus.js' // bus나 bus1 이나 아무거나 가능  // bus.js export const bus = new Vue(); // App.vue import { bus } from './bus.js' // 먼저 정의해준 변수명을 {}안에 넣어서 사용      diff check    9.3 스피너 실행 및 종료 시점 알아보기      actions.js에서 response를 return 하면 NewsView에서 dispatch에 .then으로 프로미스 체이닝이 가능      diff check    9.4 하이 오더 컴포넌트(HOC) 소개 및 구현   컴포넌트의 로직을 재사용하기 위한 기술 하이 오더 컴포넌트     CreateListView.js가 하이오더컴포넌트   기존에 있었던 컴포넌트의 위에 하나의 컴포넌트가 더 생성됨      diff check    9.5 하이 오더 컴포넌트에서 사용할 ListView 컴포넌트 구현      diff check    9.6 하이 오더 컴포넌트가 적용된 앱 구조 설명 및 흐름 정리      router/index.js에서 component: createListView('NewsView'),으로 pagename을 넘기고   CreateListView에서 name으로 받고 재사용하는 로직들을 created()에 넣어줌   spinner를 켜고 끄는 로직까지 같이 넣어줌      diff check    9.7 Mixin의 개요와 활용처 그리고 HOC와의 차이점   Mixins     여러 컴포넌트간에 공통으로 사용하고 있는 로직 기능들을 재사용하는 방법   믹스인안에 정의할 수 있는 재사용 로직은 data, methods, created 등과 같은 컴포넌트 옵션   hoc는 중간에 컴포넌트가 하나 더 생기므로 레벨이 깊어져서 통신에 불편함이 생김   1 2 3 4 5 6 7 var HelloMixins = {     // 컴포넌트 옵션 (data, methods, created 등)\\ };  new Vue({     mixins: [HelloMixins] })  위와 같이 믹스인을 주입할 컴포넌트에 mixins 속성을 선언하고 [] 배열안에 주입할 믹스인들을 추가   예시  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var DialogMixin = {     data() {         return {             dialog: false         }     },     methods: {         showDialog() {             this.dialog = true;         },         closeDialog() {             this.dialog = false;         }     } }  DialogMixin에 다이얼로그의 표시 상태를 나타내는 dialog데이터와 다이얼로그를 열거나 닫는 메서드 showDialog(), closeDialog() 정의   재사용  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &lt;!-- LoginForm.vue --&gt; &lt;script&gt;     import { DialogMixin } from './mixins.js';      export default {         mixins: [ DialogMixin ],         methods: {             submitForm() {                 axios.post('login', {                     id: this.id,                     pw: this.pw                 })                 .then(() =&gt; this.closeDialog())                 .catch((error) =&gt; new Error(error));             }         }     } &lt;/script&gt;   9.8 Mixin 적용 후 HOC 구조와 비교      hoc는 AskView와 ListItem 사이에 ListView 컴포넌트가 생성되어 레벨이 더 깊어짐   mixins는 새로 생성되는 컴포넌트가 없음      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","mixin","hoc"],
        "url": "/vue-lv3/vue-advanced9/",
        "teaser": null
      },{
        "title": "10 - 데이터 호출과 UX",
        "excerpt":"10.1 UX를 고려한 데이터 호출 시점   데이터 호출 시점     컴포넌트 라이프 사이클 훅            created : 인스턴스(컴포넌트)가 생성되자 마자 호출되는 로직들, 화면에 내용들이 붙은 상태는 아님           라우터 네비게이션 가드            라우터로 특정 url에 접근할때 그 전에 동작들을 정의하는 속성(함수)           네비게이션가드가 라이프사이클훅 보다 먼저 호출 됨  컴포넌트가 생성되고 나서 데이터를 호출 할건지 라우팅 상태에서 호출할건지에 따라 선택   created 라이프 사이클 훅 API 문서  네비게이션 가드 블로그  네비게이션 가드 뷰 라우터 공식 문서   10.2 라이프 사이클 훅을 이용한 데이터 호출 방법의 문제와 비동기 처리 코드 수정   actions.js     FETCH_LIST에서 fetchList api 호출에 return 해줘야함   return을 해줘야 fetchList에 대한 결과가 프로미스로 체이닝 돼서 FETCH_LIST가 ListMixin에서 .then이 될 수 있게 함      diff check    10.3 라우터 네비게이션을 이용한 데이터 호출 방법   beforeEnter  1 2 3 4 5 6 beforeEnter: (to, from, next) =&gt; {     console.log('to', to);     console.log('from', from);     console.log('next', next);     next(); }     to : 이동할 URL의 라우팅 정보   from : 현재위치의 URL 라우팅 정보   next : function, next();를 호출 해줘야지 이동할 URL로 이동할 수 있음      diff check    10.4 라우터 네비게이션 가드 실습 및 스피너 종료 시점 변경      데이터를 불러오고 나서도 로딩스피너가 바로 꺼지지 않음   LinstMixin.js에서 데이터 호출 로직을 router/index.js로 옮기기   그리고 bus.$emit('end:spinner');를 뷰페이지의 mounted()에 넣어줘서 마운트 되면 꺼지도록 수정      diff check       각 뷰페이지에 mounted에서 end:spinner가 중복되므로 이것을 다시 재활용 가능   LinstMixin.js을 다시 이용해서 데이터 호출 로직은 지우고 그안에 mounted()를 넣어서 재활용      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue"],
        "url": "/vue-lv3/vue-advanced10/",
        "teaser": null
      },{
        "title": "11 - async & await를 이용한 비동기 처리",
        "excerpt":"11.1 자바스크립트 비동기 처리 패턴의 발전 과정   비동기 처리에 대해서 모르고 자바스크립트로 어떤 데이터를 받아와서 처리하려고 할때 일반적인 사고라면 아래와 같이 작성할 것이다.   1 2 3 4 var id = $.get('domain.com/id'); // #1 domain.com/id 로 get 요청을 보내서 결과값을 id에 담고 if (id === 'john') { // #2 그 id가 john이면     var products = $.get('domain.com/products'); // #3 domain.com/products 로 get 요청을 받아서 결과값을 products에 담아라 }   그러나 위와 같이 코드를 짠다면 var id = $.get('domain.com/id'); 여기서 데이터 요청을 보내고 받아오기 전에 아래줄이 실행이 되기때문에, 이것에 대해 콜백 처리가 필요하다.   1 2 3 4 5 6 7 $.get('domain.com/id', function(id) {// domain.com/id 결과를 받아서 콜백함수 function(id) 실행     if (id === 'john') { // id가 john이면         $.get('domain.com/products', function(products) { // domain.com/products 결과를 받아서 콜백함수 function(products) 실행             console.log(products);         });     } });   이것을 Promise를 적용해보면,(대충 아래같은 식으로 코드 작성)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // $.get('domain.com/id', function(id) { //     if (id === 'john') { //         $.get('domain.com/products', function(products) { //             console.log(products); //         }); //     } // }); function getId() { // getId()는 Promise를 리턴하니까 .then() 메소드 체이닝 가능     return new Promise(function(resolve reject) {         $.get('domain.com/id', function(id) {             resolve(id);         })     }) } function getProduct() {     if (id === 'john') {         $.get('domain.com/products', function(products) {             return new Promise(...)         });     } } function logProduct(products) {     console.log(products) } getId() // #1 id를 가져오면     .then(getProduct()) // #2 product를 가져오고     .then(logProduct()) // #3 콘솔에 product를 찍기 -&gt; 코드의 흐름이 보기 쉽다.     .catch()   11.2 async &amp; await 문법 소개   async &amp; await는 자바스크립트 비동기 처리 패턴의 최신 문법.  Promise와 Callback에서 주는 단점들을 해결 하고 자바스크립트의 비동기전 사고 방식에서 벗어나 동기적(절차적)으로 코드를 작성할 수 있게 도와준다.   기본문법   1 2 3 async function fetchData() {     await getUserList(); }  async함수는 함수의 앞에 async를 붙여주고 함수의 내부 로직 중 비동기 처리 로직 앞에 await를 붙여주면 된다.  좀 더 정확하게 말하면 Promise객체를 반환하는 API 호출 함수 앞에 await를 붙인다.   예제를 좀 더 살펴보면  1 2 3 4 5 6 7 8 9 10 11 12 13 14 function fetchData() {     var list = getUserList();     console.log(list); } function getUserList() {     return new Promise(function(resolve, reject) {         var userList = ['user1', 'user2', 'user3'];         resolve(userList);     }); }  fetchData() // Promise {&lt;fulfilled&gt;: Array(3)} // undefined   여기에 async await를 적용하면  1 2 3 4 5 6 7 8 9 10 11 12 13 14 async function fetchData1() {     var list = await getUserList1();     console.log(list); } function getUserList1() {     return new Promise(function(resolve, reject) {         var userList = ['user1', 'user2', 'user3'];         resolve(userList);     }); }  fetchData() // (3) ['user1', 'user2', 'user3'] // Promise {&lt;fulfilled&gt;: Array(3)}   11.3 async &amp; await 예제 소개      로그인 버튼을 클릭하면 user id가 1인 api를 호출하고 .then 메소드체이닝으로 결과의 id가 1이면 todos를 get 요청 보내기      diff check    11.4 async await 예제 실습      함수 앞에 async 붙이고 함수 안의 로직중 promise 비동기 처리 앞에 await를 붙여준다.      diff check    11.5 async await 에러 처리 방법과 공통화 함수 작성 방법      try / catch 문으로 에러 처리      diff check    11.6 async 함수를 이용한 코드 리팩토링      promise를 반환하는 함수나 api앞에 await를 붙여줌, const response -&gt; promise방식에서 then의 response를 받는것과 같음      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","async","await","promise","callback"],
        "url": "/vue-lv3/vue-advanced11/",
        "teaser": null
      },{
        "title": "12 - 외부 라이브러리 모듈화 방법(차트)",
        "excerpt":"12.1 라이브러리 모듈화의 이유와 배경   Chart.js State of JS 2018      외부 라이브러리 모듈화            이유 : Vue.js 관련 라이브러리가 없을 때 일반 라이브러리를 결합할 수 있어야 함       종류                 차트       데이트피커       테이블       스피너           12.2 차트 라이브러리 설치 및 차트 그리기      chart.js라이브러리 설치 yarn add chart.js@2   chart.js 공식사이트에서 예제 코드 복사해서 붙여넣기      diff check    12.3 BarChart 컴포넌트화 작업      차트 -&gt; 컴포넌트화 : 차트에 해당하는 코드들을 컴포넌트에 만들기   컴포넌트의 플러그인화   컴포넌트 통신을 이용한 차트 컴포넌트 기능 결합      diff check    12.4 LineChart 제작 및 차트 충돌 문제 해결   line chart      diff check    12.5 Vue에서 DOM을 접근하는 방법인 ref 속성 소개   ref     각각의 컴포넌트에서만 접근할 수 있는 접근자   document.getElementById의 경우는 어떤 컴포넌트에서 사용하든 화면에서 그려진 돔에 전부 접근하기때문에 충돌날 확률이 높음   1 2 3 4 5 6 7 8 &lt;div ref=\"app\" id=\"app\"&gt;hello&lt;/div&gt;  &lt;script&gt;     var divElement = document.getElementById('app');     var divElement = document.querySelector('#app');     var divElement = $('#app');     var divElement = this.$refs.app; &lt;/script&gt;      diff check    12.6 Vue.js 플러그인 소개 및 차트 플러그인 제작   plugin 문서      chart.js를 각 컴포넌트마다 불러와서 사용하면 차트의 종류가 많아질수록 라이브러리를 컴포넌트마다 불러오는 불필요한 로직이 생김   플러그인     인스턴스가 생성됐을때 모든 컴포넌트에서 사용하고 싶은 기능을 정의   Vue.use(ChartPlugin)      diff check    12.7 결합력 높은 차트 컴포넌트 모듈 제작 방법      컴포넌트 통신을 이용한 차트 컴포넌트 기능 결합      diff check    ","categories": ["vue-lv3"],
        "tags": ["vue","chart"],
        "url": "/vue-lv3/vue-advanced12/",
        "teaser": null
      },{
        "title": "13 - 컴포넌트 디자인 패턴",
        "excerpt":"13.1 Component Design Patterns   컴포넌트 디자인 패턴     Common : 기본적인 컴포넌트 등록과 컴포넌트 통신   Slot : 마크업 확장이 가능한 컴포넌트   Controlled : 결합력이 높은 컴포넌트   Renderless : 데이터 처리 컴포넌트   13.2 Common Approach      컨테이너 컴포넌트 개념으로 appHeader와 appContent에 데이터를 내려주는 app.vue가 컨테이너 컴포넌트가 됨   내려준 데이터를 가지고 표현으로 하고 조작을 하면 이벤트로 올리는 기본적인 컴포넌트 설계방식      diff check    13.3 Component with Slots - Slot vs Props           아이템1     컴포넌트 안에 텍스트가 들어가 있는 형태       Item.vue에서 slot을 지우고 ‘item1’이라고 텍스트를 고정시켜 놓으면 화면에는 item1이 다섯개 찍힘(상위 App.vue에서 정의해준 내용이 소용없게됨)            diff check            기존의 props 방식            diff check\\            13.4 Component with Slots 구현 방법과 활용처      slot을 사용하면서 App.vue에서 데이터에 배열로 값을 넣고 그 데이터를 v-for로 뿌려주면 하위 Item.vue 컴포넌트는 데이터 의존성이 없어진다 -&gt; 데이터는 App.vue에서 가지고 있기 때문에 하위에서는 단지 표현만 해줌            diff check            slot을 사용하면 정의하는 곳에서 다시 돔구조와 스타일 정의등이 가능하다            diff check            13.4 Controlled Component - Input 박스를 다룰 때 생기는 문제점      checked: false로 정의하고 이것을 props로 App.vue에서 CheckBox.vue에 내려주고 체크박스에서 v-model로 연결   화면에서 체크박스를 클릭하면 오류가 뜸 -&gt; 오류메세지의미 : prop을 하위에서 바꾸지 마라는 의미   컴포넌트의 n방향 통신을 방지하기 위해 위에서 내리고 아래에서 이벤트를 올리는데 여기서는 하위에서 checked: false로 내려온것을 클릭할때 true로 바꾸게 되면서 뜨는 오류이다.            diff check            13.5 Controlled Component - 구현 방법과 활용처      App.vue에서 하위 컴포넌트로 v-model로 값을 내린다.   체크박스에서 관리하던 데이터값이 상위에서 관리가 됨      diff check    13.6 Renderless Component - 소개      표현을 하지 않는 컴포넌트 -&gt; Renderless Component   13.7 Renderless Component - Render Function      main.js에서 render 속성이 정의된 부분을 보면 h=&gt;h(App)이 있다.     1 2 3 4 // 기본 표현 render: function(createElement) {   return createElement(App); }           내부적으로 createElement라는 함수를 파라미터로 받고 이 함수에 App을 넘겨줘서 element를 생성한다. 여기서 createElement는 단지 변수명이기 때문에 h로 바꾸면     1 2 3 4 // h는 hyperscript의 약자로 virtual DOM에서 관용적으로 사용되는 표현, HTML구조를 생성하는 스크립트라는 의미 render: function(h) {   return h(App); }           위 표현을 화살표 함수로 적으면     1 render: (h) =&gt; {return h(App)}           좀 더 간단히 적을 수 있다.     1 2 3 new Vue({   render: h =&gt; h(App); }).$mount('#app')           13.8 Renderless Component - 구현 방법과 활용처      FetchData.vue의 데이터(response와 loading)을 접근할 수 있는게 $scopedSlots      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","component","design pattern"],
        "url": "/vue-lv3/vue-advanced13/",
        "teaser": null
      },{
        "title": "14 - 서비스 배포 환경 구성",
        "excerpt":"14.1 서비스 배포를 위한 명령어 소개 및 실습   배포명령어 npm run build  yarn build   CLI로 생성한 프로젝트를 서비스에 배포하려면 제일 먼저 위 명령어를 실행.  실행하고 나면 호스팅 할 수 있는 형태(dist폴더)의 HTML, CSS, Javascript, 이미지 등의 파일 생성.  이렇게 생성된 자원을 빌드된 자원이라고 부름   14.2 Netlify를 이용한 배포 실습   Netlify 공식 사이트 주소      github으로 signup   deploy site   14.3 base 디렉토리 설정 및 배포 완료      deploy failed가 나오면 deploy setting으로 돌아가서   base directory를 설정해줘야 한다.   폴더 경로에 맞게 수정해주기   14.4 SPA 호스팅시에 서버에 추가해줘야 하는 설정 안내   Vue CLI 배포 설명 페이지   14.5 env 환경 변수 파일을 이용한 옵션 변경 방법      코드를 서버에 배포할때 특정 옵션들을 담아 놓는 파일   브라우저에 어떤 값을 노출 하고 싶지 않은 코드를 넣음   .env 로 파일 생성   변수=값 형식으로 작성   .env  APP_TITLE=HELLO   App.vue created() {    console.log(process.env.APP_TITLE)  }   이렇게 넣고 실행해보면 콘솔창에 undefined가 뜬다.   .env  VUE_APP_TITLE=HELLO   App.vue created() {    console.log(process.env.VUE_APP_TITLE)  }   VUE_를 붙이면 접근 가능해진다.   vue news site 보러가기  ","categories": ["vue-lv3"],
        "tags": ["vue","deploy"],
        "url": "/vue-lv3/vue-advanced14/",
        "teaser": null
      },{
        "title": "Function 오브젝트",
        "excerpt":"1.1 function 형태, function 오브젝트 생성, 오브젝트 저장, 생각의 전환   function 형태     빌트인 Function 오브젝트 Function.prototype.call()   function 오브젝트            function book(){…}       var book = function() {…}       인스턴스이지만, new 연산자로 생성한 인스턴스와 구분하기 위해 function 오브젝트로 표기           function 인스턴스            new Book()처럼 new연산자를 사용하여 Book.prototype에 연결된 메소드로 생성           function 오브젝트 생성     var book = function() {…};   엔진이 function 키워드를 만나면 빌트인 Function 오브젝트의 prototype에 연결된 메소드로 function 오브젝트 생성   생성한 오브젝트를 book 변수에 할당   book() 형태로 호출            function 오브젝트이므로 호출 가능           오브젝트 저장     함수를 호출하려면 생성한 function 오브젝트를 저장해야한다.   function 오브젝트 저장형태            {name: value} 형태로 저장       {book: 생성한 function 오브젝트} 형태           함수를 호출하려면            저장된 오브젝트에서 함수 이름(book)으로 검색       value 값을 구하고       value가 function 오브젝트면 호출           함수가 호출되면 엔진은 함수의 변수와 함수를 {name: value} 형태로 실행 환경을 설정하고 함수 코드를 실행한다.  {name: value} 형태로 생각을 전환해야 JS의 아키텍처와 메커니즘을 쉽게 이해할 수 있다.  function(){…} 코드를 보면 함수의 변수와 함수가 {name: value} 형태로 연상되어야 한다.   1.2 function 오브젝트 생성 과정, function 오브젝트 구조   function 오브젝트 생성 과정      function sports(){…} 형태에서 function 키워드를 만나면   오브젝트를 생성하고 저장            {sports: {…}}       sports는 function 오브젝트 이름       오브젝트 {…}에 프로퍼티가 없는 상태 -&gt; 이제부터 빈 오브젝트에 프로퍼티를 채운다.           ㄴsports 오브젝트 형태   1 2 3 4 5 6 7 8 9 10 11 12 13 14 var sports = function(){}; /* 1. 생성한 오브젝트가 sports에 할당된다. -&gt; 오브젝트를 생성하는 시점에는 빈 오브젝트 2. Local의 sports를 펼치면 arguments: (...) caller: (...) length: 0 name: \"sports\" prototype: {   construnctor: ƒ ()   __propto__: Object // 빌트인 오브젝트에 관련된 메소드들이 설정되어있음(6개) } __proto__: ƒ () // apply, bind, call 빌트인 function 오브젝트의 prototype에 연결되어 있는 메소드들이 설정됨 */      sports 오브젝트에 prototype 오브젝트 첨부   prototype에 constructor 프로퍼티 첨부            prototype.contructor가 sports 오브젝트 참조           prototype에 __proto__ 오브젝트 첨부   1 2 3 4 5 6 sports = {   prototype: {     constructor: sports     __proto__: {}   } }     빌트인 Object.prototype의 메소드로 Object 인스턴스를 생성하여 prototype.__proto__에 첨부   sports 오브젝트에 __proto__ 오브젝트 첨부 -&gt; sports.__proto__ 구조가 된다.   빌트인 Function.prototype의 메소드로 function 인스턴스를 생성해서 sports.__proto__에 첨부   sports 오브젝트 프로퍼티에 초기값 설정 - arguments, caller, length, name 프로퍼티   1 2 3 4 5 6 7 8 9 10 11 sports = {   arguments: {},   caller: {},   length: 0,   name: \"sports\",   prototype: {     constructor: sports,     __propto__: Object.prototype   },   __proto__: Function.prototype }      function 오브젝트에 prototype이 있으며 constuctor가 연결된다.   __proto__가 연결되어 있으며 Object인스턴스가 연결된다.   function 오브젝트에 __proto__가 있으며 Function 인스턴스가 연결된다.   Array면 Array인스턴스가 연결되고 String이면 String 인스턴스가 연결된다.   1.3 함수 실행 환경 인식, 함수 실행 환경 저장, 내부 프로퍼티   함수 실행 환경 인식이 필요한 이유?     함수가 호출되었을 때 실행될 환경을 알아야 실행 환경에 맞추어 실행할 수 있기 때문   실행 환경 설정 시점     엔진이 function 키워드를 만나 function 오브젝트를 생성할 때   설정하는 것     실행 영역(함수가 속한 스코프 - 렉시컬스코프)   파라미터, 함수 코드 등   함수 실행 환경 저장     function 오브젝트를 생성하고 바로 실행하지 않으므로 함수가 호출 되었을때 사용할 수 있도록 환경을 저장   어디에?     생성한 functio 오브젝트에 저장   인식한 환경을 function 오브젝트의 내부 프로퍼티에 설정 -&gt; {name: value} 형태로   ","categories": ["js-advanced"],
        "tags": ["function","object"],
        "url": "/js-advanced/js-advanced1/",
        "teaser": null
      }]
