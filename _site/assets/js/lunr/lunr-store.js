var store = [{
        "title": "1 - 개발 환경 설정",
        "excerpt":"1.1 vue 개발 환경 설정      chrome 설치   vs code 설치   node.js LTS 버전 설치   크롬 확장 프로그램 Vue.js devetools 설치   참고 링크     Chrome   vs code   node.js   Vue.js devtools   1.2 수업 소스 코드 안내   깃 업로드 후 추가 예정   1.3 vs code 플러그인 설치     확장버튼 클릭               Vetur   Night Owl   Material Icon Theme   Live Server   ESLint   Prettier   Auto Close Tag  이미지로 첨부한 것 이외에도 추가하면 좋을 확장프로그램 리스트입니다.   Material Icon Theme 적용하는 방법       code &gt; 기본 설정(Preferences) &gt; 파일 아이콘테마(File Icon Theme) 클릭        Material Icon Theme 선택   ","categories": ["vue-lv1"],
        "tags": ["vue","setting"],
        "url": "/vue-lv1/vue-beginner1/",
        "teaser": null
      },{
        "title": "2 - vue.js 소개",
        "excerpt":"2.1 vue는 무엇인가?   MVVM패턴의 뷰모델(ViewModel) 레이어에 해당하는 화면(View)단 라이브러리   View라고 되어 있는 것은 브라우저에서 사용자에게 비춰지는 화면을 의미한다.  즉, 버튼이나 입력박스등이 해당한다.   사용자가 키보드로 입력했을때 이벤트를 중간에 DOM Listener로 view에서 읽게 됩니다. 그런 이벤트를 잡아서 데이터를 바꾸거나 특정 로직에서 실행을 합니다.   자바스크립트의 데이터가 변했을때 Data Bindings를 하게 됩니다. 그리고 Data Bindings를 이용해서 화면에 반영합니다.      2.2 기존 웹 개발 방식(HTML, Javascript)   일반적으로 프레임워크를 쓰지 않고 웹을 개발하는 방법은 HTML, CSS, Javascript를 사용합니다.   1 2 3 4 5 6 7 8 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var str = \"Hello World\";     console.log(div);     div.innerHTML = str; &lt;/script&gt;   이렇게 작성하고 브라우저에서 확인을 하면 브라우저에서 확인 할 수 있습니다.      html은 화면에 나타나는 태그나 돔의 정보를 넣는 것 이고 자바스크립트는 해당 태그나 돔의 내용을 조작하는 것을 알 수 있습니다.   여기에서 str의 값을 바꿀때는 바뀐 문자열의 내용을 다시 넣어줘야 합니다.   1 2 3 4 5 6 7 8 9 10 11 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var str = \"Hello World\";     console.log(div);     div.innerHTML = str;      str = \"Hello World!!!\";     div.innerHTML = str; &lt;/script&gt;   2.3 Reactivity 구현   기존의 개발 방식에서 vue.js의 핵심 기능인 Reactivity를 이용해보겠습니다.   div정보만 받아놓은 상태에서 viewModel이라는 객체를 선언하고  Object.defineProperty()라는 api를 사용해보겠습니다.   Object.defineProperty()가 하는 역할은 객체의 동작을 재정의 하는 api라고 보시면 됩니다.  변수 a에 10을 할당하면 a에 접근 할 수 있습니다. 혹은 a를 20으로 바꿀 수 있습니다. 특정 변수, 객체의 속성 동작을 재정의 하는것이 Object.defineProperty() 입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var viewModel = {};      // Object.defineProperty(대상객체, 객체의 속성, {               // });      Object.defineProperty(viewModel, 'str', {         // 속성의 접근했을 때의 동작을 정의         get: function() {             console.log('접근');         },         // 속성에 값을 할당했을 때의 동작을 정의         set: function(newValue) {             console.log('할당', newValue);         }     }); &lt;/script&gt;   콘솔창에서 확인을 해봅시다.    여기에서 str의 값이 바뀌면 바뀐 값을 화면에 뿌리도록 정의 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var viewModel = {};      Object.defineProperty(viewModel, 'str', {         get: function() {             console.log('접근');         },         set: function(newValue) {             console.log('할당', newValue);             div.innerHTML = newValue;         }     }); &lt;/script&gt;      값을 바꿀 때마다 화면이 바뀌는 것을 확인 할 수 있습니다.  vue의 핵심은 데이터의 변화를 라이브러리에서 감지해서 알아서 화면을 자동으로 그려주는 Reactivity입니다.   2.4 Reactivity 코드 라이브러리화 하기   코드를 라이브러리화 해보겠습니다.  init()이라는 함수안에 Object.defineProperty를 잘라서 넣습니다.  render()함수를 만들어서 div에 텍스트 값을 바꾸는 부분을 옮기고 set에서 render()를 호출해서 새로운 값이 할당 됐을때 render()에 넘겨주도록 합니다.  그리고 최종적으로 즉시실행 함수 안에 넣어줍니다.  즉시실행 함수의 역할은 기본적으로 애플리케이션의 로직에 노출되지 않도록 또다른 유효범위(스코프)에 넣어주는 것입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var viewModel = {};      (function() {         function init() {             Object.defineProperty(viewModel, 'str', {                 get: function() {                     console.log('접근');                 },                 set: function(newValue) {                     console.log('할당', newValue);                     render(newValue)                 }             });         }         function render(value) {             div.innerHTML = value;         }         init();     })(); &lt;/script&gt;   2.5 Hello Vue.js와 뷰 개발자 도구   간단하게 뷰로 Hello Vue.js를 화면에 찍어 보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;div id=\"app\"&gt;      &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             message: 'Hello Vue.js'         }     }) &lt;/script&gt;   코드를 브라우저에서 확인 해봅시다.      크롬 개발자 모드에서 vue탭으로 이동후 data &gt; message: “Hello Vue.js”의 내용을 바꾸면 화면에서 바로 반영이 됩니다.   ","categories": ["vue-lv1"],
        "tags": ["vue"],
        "url": "/vue-lv1/vue-beginner2/",
        "teaser": null
      },{
        "title": "3 - 인스턴스",
        "excerpt":"3.1 인스턴스 소개   뷰에서 첫번째로 알아야 할 개념은 인스턴스 입니다. 인스턴스는 뷰로 개발 할때 필수로 생성해야 할 단위입니다.   인스턴스를 생성하고 나면 변수안에 인스턴스의 내용을 담을 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var vm = new Vue({         el: '#app',         data: {             message: 'hi'         }     }); &lt;/script&gt;   vm이라는 변수에 new Vue라고 인스턴스를 생성합니다.  el: ‘#app” &gt; app이라는 아이디를 가진 태그를 찾아서 인스턴스를 붙이겠다 라는 의미입니다.  이렇게 붙이는 순간 vue의 기능과 속성들이 유효해 집니다.   3.2 인스턴스와 생성자 함수   생성자 함수를 만들고 name과 job을 인자로 받아서 정보들을 인스턴스로 찍어낼 수 있습니다.  함수를 선언하면 객체가 생성됩니다.      뷰를 왜 생성자 함수로 찍어내는지 보겠습니다.   Vue라는 생성자 함수를 이용해서 기능을 편하게 쓰게 하고 싶을때, logText()라는 함수를 미리 정의 해놓습니다.  그럴때 vm으로 new Vue()를 생성할 때마다 logText()함수가 들어가 있습니다. 그래서 매번 함수를 정의하는게 아니라 함수를 가져다 사용할 수 있습니다.      3.3 인스턴스 옵션 속성   1 2 3 4 5 6 7 8 new Vue({     el:,     template:,     data:,     methods:,     created:,     watch:, });   1 2 3 4 5 6 7 8 9 10 11 12 var vm = new Vue({     el: '#app',     data: {         message: 'hi'     },     methods: {              },     created: function() {      } });   ","categories": ["vue-lv1"],
        "tags": ["vue"],
        "url": "/vue-lv1/vue-beginner3/",
        "teaser": null
      },{
        "title": "4 - 컴포넌트",
        "excerpt":"4.1 컴포넌트 소개   vue.js의 컴포넌트에 대해서 알아보겠습니다. 컴포넌트는 화면의 영역을 구분하여 개발할 수 있는 뷰의 기능입니다. 컴포넌트 기반으로 화면을 개발하게 되면 코드의 재사용성이 올라가고 빠르게 화면을 만들 수 있습니다.  컴포넌트는 영역을 구분했을 때 컴포넌트간에 관계가 생깁니다.   4.2 컴포넌트 등록 및 실습   인스턴스를 생성하면 개발자 도구에서 Root컴포넌트로 인식합니다.   컴포넌트를 등록하는 가장 간단한 방법은 전역 컴포넌트로 등록하는 방법입니다. 전역 컴포넌트를 등록하고 인스턴스의 영역에 컴포넌트 태그를 넣어주면 됩니다.  (실제 서비스를 할때는 전역컴포넌트를 등록하는 일은 거의 없을것입니다.)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;x &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     // Vue.component('컴포넌트 이름', 컴포넌트 내용);     // 전역 컴포넌트     Vue.component('app-header', {         template: '&lt;h1&gt;Header&lt;/h1&gt;'     });      new Vue({         el: '#app'     }); &lt;/script&gt;   4.3 지역 컴포넌트 등록   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     // Vue.component('컴포넌트 이름', 컴포넌트 내용);     // 전역 컴포넌트     Vue.component('app-header', {         template: '&lt;h1&gt;Header&lt;/h1&gt;'     });      new Vue({         el: '#app',         components: {             // '컴포넌트 이름': 컴포넌트 내용             'app-footer': {                 template: '&lt;footer&gt;footer&lt;/footer&gt;'             }         }     }); &lt;/script&gt;      4.4 전역 컴포넌트와 지역 컴포넌트의 차이점   지역컴포넌트는 하단에 어떤게 등록되어있는지 알 수 있습니다.  서비스를 구분할 때는 지역컴포넌트를 이용해서 아래에 등록해 나갑니다.   전역은 플러그인이나 라이브러리 형태로 전역으로 사용하는 컴포넌트만 전역으로 등록합니다.   4.5 컴포넌트와 인스턴스와의 관계   새로운 인스턴스를 생성하고 div#app2를 만들어서 인스턴스를 연결하고 전역컴포넌트와 #app에 만들었던 지역컴포넌트 태그를 넣어줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/div&gt; &lt;div id=\"app2\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     // Vue.component('컴포넌트 이름', 컴포넌트 내용);     // 전역 컴포넌트     Vue.component('app-header', {         template: '&lt;h1&gt;Header&lt;/h1&gt;'     });      new Vue({         el: '#app',         components: {             // '컴포넌트 이름': 컴포넌트 내용             'app-footer': {                 template: '&lt;footer&gt;footer&lt;/footer&gt;'             }         }     });      new Vue({         el: '#app2'     }) &lt;/script&gt;   화면에서 확인 하면 app-footer컴포넌트는 #app2에 등록한 지역컴포넌트가 아니기 때문에 보이지 않습니다. 지역컴포넌트는 인스턴스를 생성할 때마다 생성해 줘야 합니다.     ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner4/",
        "teaser": null
      },{
        "title": "5 - 컴포넌트 통신 방법) 기본",
        "excerpt":"5.1 컴포넌트 통신   뷰에서 컴포넌트를 등록했을때 관계가 생깁니다.  예를 들어서 아래 그림과 같이 컴포넌트를 나눴을때를 봅시다.      화면에서 연회색으로 되어있는 3개의 부분으로 나눴을때 그안에 진회색으로 컴포넌트를 나눌때마다 그 컴포넌트가 하위(자식)컴포넌트로 위치합니다.   이 관계의 중요한 점은, 규칙이 생긴다는 것입니다.  컴포넌트는 각각 고유한 데이터 유효 범위를 갖습니다. 따라서 컴포넌트 간에 데이터를 주고 받기 위해선 아래와 같은 규칙을 따라야 합니다.         상위에서 하위로는 데이터를 내려줌, 프롭스 속성   하위에서 상위로는 이벤트를 올려줌, 이벤트 발생   5.2 컴포넌트 통신 규칙이 필요한 이유   예를 들어서 헤더, 컨텐트, 푸터 컴포넌트를 등록하고  그리고 그 컴포넌트 밑에 각각 컴포넌트를 하나씩 등록했다고 합시다.      여기에서 만약 헤더에서 로그인폼으로 데이터를 전달하고, 그 정보를 다시 푸터로 보냅니다.  그리고 푸터에서 다시 네비게이션바로 데이터를 보낸 상황을 가정합니다.  이런식으로 특정 컴포넌트의 변화에 따라서 나머지 컴포넌트가 유기적으로 데이터를 주고받았을때 데이터의 방향을 예측하기가 어려워집니다.  데이터가 바뀌었을떄 그로 인한 버그를 추적하기가 어려운게 n방향 통신의 문제점입니다.   컴포넌트 통신방식을 살펴봅시다.      컴포넌트 통신방식은 데이터가 아래로만 내려갑니다.  데이터의 흐름을 추적할 수 있습니다. 데이터는 항상 내려오고 이벤트는 올라갑니다.   5.3 props 속성   app-header컴포넌트를 만들고 data에 메세지를 정의해주면 Root컴포넌트에 message가 생성됩니다.  이 데이터를 aa-header로 내리려면 props를 사용하면 됩니다.  v-bind:프롭스 속성 이름 = “상위 컴포넌트의 데이터 이름”으로 넣어줍니다.  app-header의 기준으로 상위컴포넌트는 root가 되고 그 데이터 이름은 message입니다.  프롭스 속성 이름은 appHeader라는 변수 안에 정의 해주고 그것을 사용하면 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=\"app\"&gt;     &lt;!-- &lt;app-header v-bind:프롭스속성 이름=\"상위 컴포넌트의 데이터 이름\"&gt;&lt;/app-header&gt; --&gt;     &lt;app-header v-bind:propsdata=\"message\"&gt;&lt;/app-header&gt;     &lt;app-content v-bind:propsdata=\"num\"&gt;&lt;/app-content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;h1&gt;header&lt;/h1&gt;',         props: ['propsdata']              }     new Vue({         el: '#app',         components: {             'app-header': appHeader,         },         data: {             message: 'hi',         }     }) &lt;/script&gt;   뷰 개발자 도구로 확인해 보면 app-header에 propsdata로 들어가 있는 걸 볼 수 있습니다.      5.4 props 속성의 특징   props코드를 등록하면 root컴포넌트(상위컴포넌트)의 message값이 바뀌면 그대로 app-header에도 내려가 반영이 됩니다.  데이터바인딩을 이용하여 상위 컴포넌트의 데이터값이 바뀌면 하위 컴포넌트의 프롭스 속성이 반영되면서 화면에 나타나도록 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &lt;div id=\"app\"&gt;     &lt;!-- &lt;app-header v-bind:프롭스속성 이름=\"상위 컴포넌트의 데이터 이름\"&gt;&lt;/app-header&gt; --&gt;     &lt;app-header v-bind:propsdata=\"message\"&gt;&lt;/app-header&gt;     &lt;app-content v-bind:propsdata=\"num\"&gt;&lt;/app-content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;h1&gt;&lt;/h1&gt;',         props: ['propsdata']              }     var appContent = {         template: '&lt;div&gt;&lt;/div&gt;',         props: ['propsdata']     }     new Vue({         el: '#app',         components: {             'app-header': appHeader,             'app-content': appContent         },         data: {             message: 'hi',             num: 10         }     }) &lt;/script&gt;   5.5 event emit   아래에서 위로 통신하는 법은 이벤트를 올립니다.  이벤트에 대해서 실습해 봅시다.   뷰 인스턴스를 하나 생성하고 app-header컴포넌트를 등록하고 템플릿으로 버튼을 하나 만들어 줍니다.  버튼을 클릭했을때 이벤트를 실행하는 방법은 v-on:click으로 할 수 있습니다.   이 버튼을 클릭했을때 root로 이벤트를 보낼겁니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;button v-on:click=\"passEvent\"&gt;Click me&lt;/button&gt;',         methods: {             passEvent: function() {                 this.$emit('pass');             }         }     }     var vm = new Vue({         el: '#app',         components: {             'app-header': appHeader,         },     }) &lt;/script&gt;   이 상태에서 뷰 개발자 도구로 확인하면 버튼 클릭시 pass 이벤트가 발생합니다.   5.6 event emit으로 콘솔 출력하기   $emit은 뷰에서 제공하는 api(기능)인데 이것을 이용해서 pass라는 이벤트를 발생 시켰습니다.  이것을 위에서 받을 수 있게 컴포넌트 태그에서 조작을 해 보겠습니다.  프롭스 등록과 비슷하게 태그에서 올라온 이벤트를 잡아줘야 합니다.  하위에서 발생한 이벤트 이름은 pass이고 상위 컴포넌트 메서드 이름은 logText로 지정해줍니다.  pass라는 이벤트가 아래에서 올라왔을 때 그게 컴포넌트 태그에서 받아서 logText라는 메서드를 실행합니다.   ++ 추가로 content 넣어보기  똑같이 컴포넌트를 추가해주고, addNumber 이벤트를 추가해봅시다.  add버튼을 클릭했을때 this.$emit으로 이벤트를 올려서 위에 있는 data의 num값을 1씩 증가 시켜보겠습니다.  increase라는 하위 컴포넌트에서 발생한 이벤트 이름을 받아서 상위 컴포넌트의 메서드 increaseNumber를 실행시킵니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 &lt;div id=\"app\"&gt;     &lt;p&gt;&lt;/p&gt;     &lt;!-- &lt;app-header v-on:하위컴포넌트에서 발생한 이벤트 이름=\"상위 컴포넌트 메서드 이름\"&gt;&lt;/app-header&gt; --&gt;     &lt;app-header v-on:pass=\"logText\"&gt;&lt;/app-header&gt;     &lt;app-Content v-on:increase=\"increaNumber\"&gt;&lt;/app-Content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;button v-on:click=\"passEvent\"&gt;Click me&lt;/button&gt;',         methods: {             passEvent: function() {                 this.$emit('pass');             }         }     }     var appContent = {         template: '&lt;button v-on:click=\"addNumber\"&gt;add&lt;/button&gt;',         methods: {             addNumber: function() {                 this.$emit('increase')             }         }     }     var vm = new Vue({         el: '#app',         components: {             'app-header': appHeader,             'app-content': appContent         },         methods: {             logText: function() {                 console.log('hi');             },             increaNumber: function() {                 this.num = this.num + 1             }         },         data: {             num: 10         }     }) &lt;/script&gt;   5.7 뷰 인스턴스에서의 this   obj라는 객체를 생성하고 this를 찍으면 obj를 바라봅니다.   1 2 3 4 5 6 var obj = {     num: 10,     getNumber: function() {         console.log(this.num);     } }  따라서 실습해봤던 코드에서 console.log(vm)을 찍으면 뷰에서 생성한 내용들이 담깁니다.  이것을 펼쳐서 보면 data안에 정의했던 num: 10이 바깥레벨로 나와서 바로 보입니다.  따라서 this.num은 data의 num속성을 가리킵니다.     this 관련글 1  this 관련글 2  ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner5/",
        "teaser": null
      },{
        "title": "6 - 컴포넌트 통신 방법) 응용",
        "excerpt":"6.1 같은 컴포넌트 레벨 간의 통신 방법   같은 레벨의 컴포넌트 간의 통신 방법에 대해서 알아 보겠습니다.  Root(인스턴스)에서 appHeader와 appContent라는 컴포넌트를 등록했을때 컨텐트에서 헤더로 10이라는 데이터를 전달해 보겠습니다.      6.2 같은 컴포넌트 레벨 간의 통신 방법 구현   new Vue로 인스턴스를 생성하고 el로 #app에 붙이면 인스턴스가 div태그안에서 유효하게 됩니다.  components라는 속성으로 appHeader와 appContent 컴포넌트를 만들어줍니다.  구조도 처럼 컨텐트에서 헤더로 10을 넘기겠습니다.  content에서 버튼을 넣고 이 버튼을 누르면 신호를 발생 시킬겁니다.  그러면 methods를 정의하고 버튼을 클릭했을때 passNum이라는 이벤트를 발생시키고 함수를 이어줍니다.  this.$emit으로 pass라는 이벤트와 10을 넘겨주고 화면에서 확인하면 뷰 개발자 도구 이벤트탭에서 pass 이벤트가 발생하면서 10이 넘어옵니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-content&gt;&lt;/app-content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;div&gt;header&lt;/div&gt;',     }     var appContent = {         template: '&lt;div&gt;content&lt;button v-on:click=\"passNum\"&gt;pass&lt;/button&gt;&lt;/div&gt;',         methods: {             passNum: function() {                 this.$emit('pass', 10)             }         }     }     new Vue({         el: '#app',         components: {             'app-header': appHeader,             'app-content': appContent         },     }) &lt;/script&gt;      content에서 바로 header로 이벤트를 보낼 수 없기 때문에 content에서 root로 event를 통해서 10을 보내고 root에서 header로 props로 10을 다시 내려야 합니다.      root에서 props를 내리려면 데이터를 선언하여야 합니다.  content에서 passNum이라는 메소드가 실행되면서 this.$emit으로 pass이벤트가 올라왔는데 v-on으로 pass 이벤트를 받을 수 있습니다.  하위 컴포넌트 이벤트를 v-on으로 받아서 상위 컴포넌트 인스턴스에 메서드로 추가한 deliverNum를 연결해 줍니다. pass로 넘어오면서 인자 10도 같이 넘어옵니다. 이 인자 10은 받는 쪽에서 deliverNum(value)로 넣어줍니다.  넘어온 value를 this.num = value로 넣어줄 수 있습니다.  pass 버튼을 눌러서 이벤트가 발생하면 Root의 num이 10으로 바뀝니다.  이렇게 넘어온 데이터를 appHeader로 전달해 주면 됩니다.  v-bind로 props속성을 넣어줍니다.   화면에서 content의 porpsdata가 0이었다 버튼을 클릭하면 10으로 바뀌는 것을 확인 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;div id=\"app\"&gt;         &lt;app-header v-bind:propsdata=\"num\"&gt;&lt;/app-header&gt;         &lt;app-content v-on:pass=\"deliverNum\"&gt;&lt;/app-content&gt;     &lt;/div&gt;     &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;     &lt;script&gt;         var appHeader = {             template: '&lt;div&gt;header&lt;/div&gt;',             props: ['propsdata']         }         var appContent = {             template: '&lt;div&gt;content&lt;button v-on:click=\"passNum\"&gt;pass&lt;/button&gt;&lt;/div&gt;',             methods: {                 passNum: function() {                     this.$emit('pass', 10)                 }             }         }         new Vue({             el: '#app',             components: {                 'app-header': appHeader,                 'app-content': appContent             },             data: {                 num: 0             },             methods: {                 deliverNum: function(value) {                     this.num = value;                 }             }         })     &lt;/script&gt;  ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner6/",
        "teaser": null
      },{
        "title": "7 - 라우터",
        "excerpt":"7.1 뷰 라우터 소개와 설치   뷰 라우터는 뷰 라이브러리를 이용하여 싱글 페이지 애플리케이션을 구현할 때 사용하는 라이브러리입니다.   라우터 공식 문서 링크   위 링크로 접속하여 Installation에서 상단의 CDN주소를 복사해 줍니다.      https://unpkg.com/vue-router/dist/vue-router.js   파일을 만들어 보며 실습해 봅시다.  뷰 라이브러리와 router.js CDN 주소를 넣어주고 기본 골격을 만들어 봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     new VueRouter({      });      new Vue({         el: '#app',     }); &lt;/script&gt;   7.2 뷰 라우터 인스턴스 연결 및 초기 상태 안내   뷰 라우터를 인스턴스에 동작 시켜 보겠습니다.  VueRouter를 router라는 변수에 넣어주고 Vue인스턴스에 연결해 주고 브라우저에서 뷰 개발자 도구로 확인해 보면 Root에 $router가 잡히는 것을 볼 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var router = new VueRouter({      });      new Vue({         el: '#app',         router: router,     }); &lt;/script&gt;   7.3 routes 속성 설명 및 실습 안내   세팅한 코드로 라우터에 대한 정보를 추가 해 보겠습니다.  첫번째로 routes라는 속성입니다.  이 속성에는 페이지 라우팅 정보가 들어갑니다. (어떤 url로 이동했을때 어떤 페이지가 뿌려질지에 대한 정보가 배열로 담깁니다.)  이 배열에 페이지 라우팅 정보를 담아보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var LoginComponent = {         template: '&lt;div&gt;login&lt;/div&gt;'     }     var MainComponent = {         template: '&lt;div&gt;main&lt;/div&gt;'     }     var router = new VueRouter({         routes: [             {                 // url 이름                 path: '/login',                 // 해당 url에서 표시될 컴포넌트                 component: LoginComponent             },             {                 path: '/main',                 component: MainComponent             }         ]     });      new Vue({         el: '#app',         router: router,     }); &lt;/script&gt;   7.4 라우터가 표시되는 영역 및 router-view 태그 설명   페이지 url이 변경 됐을때 그 url에 따라서 뿌려지는 영역을 router-view라는 태그로 정의할 수 있습니다. 뷰 인스턴스에 라우터 인스턴스를 연결해야 사용할 수 있습니다.  router-view를 연결하고 url에 /login을 입력해 보면 login이라는 내용이 화면에 보여집니다.  login이라는 url로 이동했을때 해당하는 컴포넌트를 router-view라는 태그에 보여준 것 입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;div id=\"app\"&gt;     &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var LoginComponent = {         template: '&lt;div&gt;login&lt;/div&gt;'     }     var MainComponent = {         template: '&lt;div&gt;main&lt;/div&gt;'     }     var router = new VueRouter({         routes: [             {                 // url 이름                 path: '/login',                 // 해당 url에서 표시될 컴포넌트                 component: LoginComponent             },             {                 path: '/main',                 component: MainComponent             }         ]     });      new Vue({         el: '#app',         router: router,     }); &lt;/script&gt;   7.5 링크를 이용한 페이지 이동 및 router-link 태그 설명   화면 이동을 url로 할 수 있지만, 사용자 입장에서는 화면에 제공된 링크를 통해 이동합니다.  이럴때 사용하는 것이 router-link입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 &lt;div id=\"app\"&gt;     &lt;div&gt;         &lt;router-link to=\"/login\"&gt;Login&lt;/router-link&gt;         &lt;router-link to=\"/main\"&gt;Main&lt;/router-link&gt;             &lt;/div&gt;     &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var LoginComponent = {         template: '&lt;div&gt;login&lt;/div&gt;'     }     var MainComponent = {         template: '&lt;div&gt;main&lt;/div&gt;'     }     var router = new VueRouter({         // 페이지의 라우팅 정보         routes: [             {                 // 페이지의 url 이름                 path: '/login',                 // 해당 url에서 표시될 컴포넌트                 component: LoginComponent             },             {                 path: '/main',                 component: MainComponent             }         ]     });      new Vue({         el: '#app',         router: router     }); &lt;/script&gt;   7.6 라우터 정리 및 학습 방향 안내   라우터는 페이지를 이동할때 사용하는 라이브러리입니다.   CDN 방식  1 &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  NPM 방식  1 npm install vue-router   뷰 라우터 등록  뷰 라우터를 설치하고 나면 라우터 인스턴스를 생성하고, 인스턴스에 라우터 인스턴스를 등록합니다.  1 2 3 4 5 6 7 8 9 // 라우터 인스턴스 생성 var router = new VueRouter({     // 라우터 옵션 })  // 인스턴스에 라우터 인스턴스 등록 new Vue ({     router: router })   라우터 옵션  routes : 페이지의 정보들이 들어가는 속성 / component는 무조건 하나이기 때문에 s가 붙지 않음 (덧붙여서 인스턴스나 컴포넌트는 여러개가 들어가기때문에 component에 s가 붙음)   뷰 라우터로 특정 URL에 접근할 때 접근을 막는 방법(ex.로그인 전에는 접근 불가하게..)     네비게이션 가드 참고 링크  ","categories": ["vue-lv1"],
        "tags": ["vue","router"],
        "url": "/vue-lv1/vue-beginner7/",
        "teaser": null
      },{
        "title": "8 - HTTP 통신 라이브러리 axios",
        "excerpt":"8.1 HTTP 라이브러리와 Ajax 그리고 Vue Resource   axios는 vue에서 권고하는 HTTP통신 라이브러리 입니다.   Ajax는 비동기 적인 웹애플리케이션의 제작을 위한 기술입니다.  과거에는 서버에 데이터를 요청하면 서버에서 페이지까지 그려서 사용자의 브라우저로 보냈기 때문에 페이지가 깜박거리고 다시 로딩되는 현상이 있었습니다.   하지만 요즘엔 서버에서 데이터만 보내주고 화면에 그리는건 브라우저에서 하기 때문에 데이터가 바뀐 부분만 화면이 바뀌게 되어서 사용자 경험이 훨씬 좋아졌습니다.      원래 vue.js에서 확인할 수 있는 공식 라이브러리로 vue-resource가 있었는데 vue.js를 만든 Evan You가 이제 더이상 공식 라이브러리로 관리 하지 않겠다고 했습니다.  실제로 구현 하다 보면 샘플들이 있을텐데 이 샘플들이 vue-resource로 되어있는 것들이 많을것입니다.  그 샘플들을 오래 됐을 확률이 크기 때문에 그런 부분들을 인지하고 주의해서 구현하는 것이 좋습니다.    axios에 대해 살펴 보겠습니다.   8.2 axios 소개 및 오픈 소스를 사용하기 전에 알아야 할 것들   뷰에서 권고하는 HTTP통신 라이브러리는 Axios입니다. Promise기반의 HTTP통신 라이브러리이며 상대적으로 다른 HTTP통신 라이브러리들에 비해 문서화가 잘되어 있고 API가 다양합니다.   axios github을 검색하여 들어가봅시다.   오픈소스를 사용할때는 제일 먼저 봐야하는것이 Star수를 확인해야 합니다. 그만큼 많은 사람들이 이걸 확인하고 좋아요를 눌렀다는 의미입니다.  대중적인 인지도를 파악하고나면 두번째로 commits기록과 contriutors 숫자를 확인하는것도 중요합니다.  몇명의 사람들이 이 라이브러리를 수정하고 개선하기 위해 동참하고 있는지, 얼마나 많이 업데이트 되어 왔는지를 확인 할 수 있습니다.  마지막으로 각 폴더와 파일이름 옆에 커밋 이력을 보시면 이 라이브러리가 언제 수정되었는지 커밋 이력들을 통해서 이 라이브러리가 활성화 되어있는지 확인하시면 됩니다.      axio의 특징을 볼텐데 Promise based HTTP client for the browser and node.js라고 쓰여 있습니다.  프로미스란 자바스크립트의 비동기 처리 패턴을 의미합니다.   자바스크립트의 비동기 처리 패턴     callback   promise   promise + generator   async  &amp; await   자바스크립트 비동기 처리와 콜백 함수  자바스크립트 promise 이해하기  자바스크립트 async와 await   이 화면을 내려보시면 실제로 axios가 어떤 브라우저에서 호환이 되는지, 예제, 각각의 api에 대한 설명등이 자세하게 되어있습니다.  이런 부분들 때문에 axios를 사용하는 것이 편합니다.   8.3 axios 실습 및 this 설명   axios를 샘플로 돌려보고 어떤식으로 네트워크요청에 대해서 확인하고 데이터를 뿌리는지 살펴보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             getData: function() {                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response);                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   axios는 CDN으로 연결하였습니다.(github 페이지에서 하단에 installing에 cdn 확인 가능)  여기서 제일 중요한것은 버튼을 클릭했을때 getData라는 메서드를 호출하는 것입니다. 메소드의 axios.get에서 참고하는 url로 이동해보면 사용자정보가 담긴 배열을 볼 수 있습니다.      jsonplaceholder라는 것은 REST API 라는 자바스크립트로 api를 요청할때 테스트해볼 수 있는 사이트입니다.  url로 이동했을때 확인 할 수 있는 데이터는 테스트하면서 기능 구현을 해볼 수 있는 샘플이라고 보면 됩니다.   10개의 유저정보를 받아와서 버튼을 눌렀을때 성공하면 then으로 진입하고 실패하면 catch로 진입합니다.   브라우저 콘솔창에서 확인해보도록 하겠습니다.  get user 버튼을 클릭하면 데이터를 받아옵니다. 서버로 요청이 가고 돌아온 응답입니다.  이중에 가장 필요한 부분은 data라는 속성에 들어있는 사용자 정보입니다.      따라서 data만 콘솔창에 찍어보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             getData: function() {                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response);                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   다시 버튼을 클릭해보면 data가 배열로 넘어옵니다.      받아온 data를 div에 뿌려보겠습니다.  그러려면 data라는 속성을 선언하고 users라는 속성에 빈배열을 넣어줍니다.  그리고 this.users = response.data;를 통해서 받아온 data를 users속성에 넣어줍니다.  여기서 확인할것은 this.users가 과연 data안의 users를 말하는가입니다.  페이지로 돌아가서 확인해봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;      &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     this.users = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;      Root컴포넌트에 users데이터가 빈배열로 들어가있고 버튼을 누르면 콘솔창에 10개의 사용자 정보가 찍히지만 users는 계속 빈배열입니다.   this.users의 this는 axios.get()을 호출하기 전의 this와 다릅니다.   1 2 3 4 5 6 7     getData: function() {         this //1번 this         axios.get(url)             .then(function(response) {                 this.users = response.data; //2번 this             })     }   즉, getData() 에서 바로 호출된 1번 this와 axios.get()이 호출된 후 then 메소드에 의해 비동기적으로 실행된 this는 서로 다른것을 가리킵니다.   getData()의 1번 this는 new Vue()로 생성된 인스턴스 Root컴포넌트를 바라보고, axios.get()으로 호출된 callback function안에서의 2번 this는 비동기적으로 실행되면서 실행컨텍스트가 바뀌어 this가 가리키는 대상도 바뀝니다.   click이벤트로 호출되는 함수도 콜백함수(비동기적으로 실행)이지만 이때는 클릭한 대상(해당 컴포넌트)을 실행컨텍스트의 this에 담아가는 반면, axios.get()처럼 비동기적으로 데이터를 받아온후 콜백함수로 실행되는 function은 해당 function을 실행시킨 주체를 따로 담을게 없어서 window(전역객체)를 실행컨텍스트의 this에 담습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;      &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 console.log(this); //1번 this                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     console.log(this) // 2번 this                     this.users = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   1번 this와 2번 this를 구분해서 콘솔로 찍어서 확인해봅시다.      각각 vue 컴포넌트와 window를 가져오는 것을 볼 수 있습니다.   이에 대한 해결책으로 변수에 this를 먼저 담고, 그 변수를 전달하는 것입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;      &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 // vue 인스턴스를 가리키는 this                 var vm = this;                                  axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     vm = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   화살표함수를 사용하면 변수를 따로 지정하는 대신에 바로 this로 연결 할 수 있습니다.   받아온 사용자 정보를 div에 뿌려보도록 하겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;              &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 // vue 인스턴스를 가리키는 this                 var vm = this;                                  axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     vm = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   8.4 웹 서비스에서의 클라이언트와 서버와의 HTTP 통신 구조      브라우저와 서버의 관계를 살펴보겠습니다.  브라우저에서 HTTP(클라이언트와 서버간의 데이터를 주고받기위한 규칙) 요청을 서버로 보냅니다.  axios.get(‘url’)로 요청을 보냈습니다. 그러면 서버에서는 브라우저로 사용자 데이터를 보냅니다.  이렇게 요청을 보내고 받는것이 HTTP라고 보면 됩니다.   브라우저에서 서버가 어떤식으로 HTTP를 주고받는지 보겠습니다.  브라우저가 서버에 요청을 보냅니다. 그랬을때 서버의 로직을 통해서 DB의 값을 꺼내옵니다.  그 결과물이 서버에서 브라우저로 응답으로 돌아갑니다.      8.5 크롬 개발자 도구 네트워크 패널 보는 방법   크롬 개발자 도구에서 네트워크 패널이 있습니다.    All, XHR, JS, CSS … 등이 있는데 XHR을 통해 비동기 통신에 대해 볼 수 있습니다.  여기에서 get user 버튼을 누르면 HTTP Request가 서버로 날라갑니다.      users를 클릭하면 어떤요청이 서버로 갔고 어떤 응답이 왔는지에 대한 정보들이 뜹니다.  이 패널을 자세히 보면 버그를 잡는데 수월합니다.      첫번째로 Headers엔 General, Response Header, Request Header가 있습니다.  HTTP Header를 의미하는데 여기에는 특정 요청에 대한 정보나 응답에 대한 정보가 담겨있습니다.   General을 보면 Request URL과 Request Method를 보실 수 있습니다. url로 get 요청을 보냈다는 것을 알 수 있습니다.  그리고 status 200을 보면 정상적으로 응답을 받았다는 것을 알 수 있습니다.      Response Headers는 서버에서 어떤 응답을 줬는지에 대한 정보를 담고있습니다.   캐싱이나 etag 등 여러가지 정보들을 담고있습니다.      Request Headers는 브라우저 정보들부터 시작해서 현재 브라우저가 받아줄 수 있는 format이나(Accept) 부가적인 정보들이 들어있고, User Agent는 현재 브라우저에 대한 정보입니다.   axios.get()의 get은 정보를 달라는 요청이기 때문에 Response에는 항상 그 정보가 담겨있습니다.  Preview로 보면 어떤식으로 정보가 담겨 오는지 보기 편합니다.      ","categories": ["vue-lv1"],
        "tags": ["vue","axios"],
        "url": "/vue-lv1/vue-beginner8/",
        "teaser": null
      },{
        "title": "github.io 블로그 시작하기",
        "excerpt":"jekyll 블로그 시작   무료 Jekyll theme 중 가장 많이 사용되고 있는 “minimal-mistakes”를 사용해서 만들기   디자인도 깔끔하고 제작자가 꾸준히 업데이트를 하고있으며, 많이 사용되고 있는 만큼 참고할 자료도 많을 것으로 보인다.   이글의 제목은 github.io 블로그 시작하기 이고, 오늘은 2021-12-03이다. 앞으로 공부하면서 계속해서 정리해서 올려봐야겠다.   ","categories": ["blog"],
        "tags": ["Jekyll","theme"],
        "url": "/blog/firstpost/",
        "teaser": null
      },{
        "title": "마크다운 문법",
        "excerpt":"마크다운 문법에 대하여   제목을 쓸 때는 #을 이용     #h1  ##h2  ###h3  ####h4  #####h5  ######h6    강조는 각각 &lt;em&gt;, &lt;strong&gt;, &lt;del&gt; 사용   html 태그표현  예)     ```html     &lt;div&gt;   &lt;p&gt;Hello, JEKYLL!&lt;/p&gt;  &lt;/div&gt;    ```    결과)          1 2 3 &lt;div&gt;  &lt;p&gt;Hello, JEKYLL!&lt;/p&gt; &lt;/div&gt;   별표시  예)  1 \\*별표이지, 강조가 아닙니다\\*   결과) *별표이지, 강조가 아닙니다*       변수 입력은 `$var = “JEKYLL”;` 이렇게 합니다.    변수 입력은 $var = \"JEKYLL\"; 이렇게 합니다.     자바스크립트          1 2 3 4 function syntaxHighlight(code, lang) {    var foo = 'hi';    var bar = 1234; }    링크  1 2 3 4 5 6 7 8 9 10 11 12 13 14 [GOOGLE](https://google.com) [NAVER](https://naver.com \"title을 입력해주세요\")  문서안에서 [참조링크]를 그대로 사용 할 수 있습니다. [네이버][naver link] [GitHub][github]  [naver link]: https://naver.com [github]: https://github.com [참조링크]: https://google.com \"google로 이동합니다\"  문서 내 꺽쇠 괄호(&lt; &gt;)안의 URL은 자동으로 링크를 사용합니다. 구글 홈페이지: https://google.com 네이버 홈페이지: &lt;https://naver.com&gt;  GOOGLE  NAVER   문서안에서 참조링크를 그대로 사용 할 수 있습니다.  네이버  GitHub   문서 내 꺽쇠 괄호(&lt; &gt;)안의 URL은 자동으로 링크를 사용합니다.   네이버 홈페이지: https://naver.com     이미지  링크와 비슷한데 앞에 !가 붙습니다.  1 2 3 ![logo](/assets/images/logo2.png \"logo 이미지\") 이미지에 링크 추가 [![naver_logo](/assets/images/naver_logo.png)](https://naver.com \"naver로 이동\")    이미지에 링크 추가       코드 강조  숫자 1번키 옆에 `로 감싸주세요.  1 `code`를 강조 할 수 있습니다.  code를 강조 할 수 있습니다.    인용문  1 2 3 4 5 6 7 8 인용문(blockQuote) &gt; 남의 말이나 글에서 직접 또는 간접으로 따온 문장  &gt; 인용문 작성 &gt;&gt; 중첩된 인용문도 만들 수 있다. &gt;&gt;&gt; 중첩1 &gt;&gt;&gt; 중첩2 &gt;&gt;&gt; 중첩3  인용문(blockQuote)     남의 말이나 글에서 직접 또는 간접으로 따온 문장       인용문 작성         중첩된 인용문도 만들 수 있다.             중첩1  중첩2  중첩3            ","categories": ["blog"],
        "tags": ["markdown"],
        "url": "/blog/md/",
        "teaser": null
      },{
        "title": "GitHub 글 쓰기",
        "excerpt":"GitHub 블로그 글 등록하기   첫 글을 등록해보자.   지킬은 정해진 포맷에 맞춰 글을 등록해야 하는데, _posts폴더에 md확장자로 등록한다.   처음에는 _posts폴더가 없으므로 만들어야 한다. _posts폴더를 생성한후 파일명의 형식은 year-month-day-제목.md 로 파일을 생성한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ---  title: \"github.io 블로그 시작하기\"  excerpt: \"GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.\"  last_modified_at: 2021-12-03 categories:      - Blog  tags:      - Jekyll     - theme      - Blog  ---  ## jekyll 블로그 시작   테마는 가장 많이 사용되고 있는 \"minimal-mistakes\"를 사용  디자인도 깔끔하고 제작자가 꾸준히 업데이트를 하고있으며,  많이 사용되고 있는 만큼 참고할 자료도 많을 것으로 보인다.  이글의 제목은 GitHub 글 쓰기 이고, 오늘은 2021-12-03이다. 앞으로 공부하면서 계속해서 정리해서 올려봐야겠다.   이런 형식으로 올리면   이렇게 등록이 된 것을 확인 할 수 있다.   ","categories": ["blog"],
        "tags": ["post"],
        "url": "/blog/post/",
        "teaser": null
      },{
        "title": "인스턴스",
        "excerpt":"인스턴스란?   인스턴스는 클래스나 프로토타입을 사용해 만든다. 즉, 프로퍼티와 메소드를 상속 받는다.   원래의 객체가 가지고 있던 것을 동일하게 사용하면서, 거기에 확장시켜 추가된 개별속성을 가질 수 있다.   예를 들어, “모자”라는 객체의 인스턴스로 “모자1”을 생성했을때 “모자1”은 “파란 모자”가 될 수 있다.   1 2 3 4 5     cap = function(color){         this.color = color;     };     let cap1 = new cap(blue);     let cap2 = new cap(black);   ✅ 추가 설명 떡볶이 레시피를 가지고 떡볶이를 먹으려면 “떡볶이”를 만들어야 한다.  어제 “떡볶이”를 만들고, 오늘 또 “떡볶이”를 만들었다고 가정 했을때 만들어진 “떡볶이”는 [인스턴스]가 된다. 여기서 두개의 떡볶이는 같은 레시피를 보고 만들었지만 동일한 대상은 아니다.   ","categories": ["javascript"],
        "tags": ["instance","primitive"],
        "url": "/javascript/instance/",
        "teaser": null
      },{
        "title": "github jekyll blog codeblock에 line number 추가하기",
        "excerpt":"코드블럭에 line number 추가를 해봅시다.   마크다운에서 코드블럭을 삽입하려면 역따옴표를 세번 넣어서 사용합니다.  코드블럭으로 코드를 삽입하고 좀 더 보기 쉽게 line number를 추가 하고 싶을때 어떻게 할까?   _config.yml 파일을 열고 kramdown을 검색합니다.   kramdown:      highlighter: rouge      syntax_highlighter_opts:          block:              line_numbers: true   위 코드를 추가 합니다.      _config.yml 파일은 수정후 자동 반영이 안되므로 서버를 내렸다가 다시 동작하여야 반영이 됩니다.   ","categories": ["blog"],
        "tags": ["codeblock","custom"],
        "url": "/blog/codeblock-line-number/",
        "teaser": null
      },{
        "title": "DOM",
        "excerpt":"DOM 소개   javascript를 공부하면서 DOM을 빼놓고 이야기 할 수 없다.   DOM이란 무엇인가? 그전에 BOM에 대해서 알아보자.      BOM이란 무엇인가?    브라우저를 바탕으로 웹서비스가 실행이 되는데, 이와 관련된 객체들의 집합을 브라우저객체모델(Browser Object Model)이라고 한다.      웹브라우저와 관련된 객체의 집합   window객체가 최상위 객체   웹브라우저가 제공하는 기능      DOM의 정의(MDN참조)    DOM은 Document Object Model의 약자이다.     HTML, XML 문서의 프로그래밍 인터페이스   문서의 구조화된 표현을 제공하고, 프로그래밍 언어가 DOM구조에 접근할 수 있는 방법을 제공해서 문서구조, 스타일, 내용등을 변경할 수 있게 한다.   웹페이지를 스크립트 또는 프로그래밍 언어들에서 사용되도록 연결해준다.   DOM이 무엇인가…     내가 html에 쓴 파일이 DOM은 아니다. 그러나 브라우저에 의해서 파싱이 된다면 DOM이 된다.   view source에서 보이는것도 DOM이 아니다.   dev Tools(개발자 도구)에서 보여주는 것이 DOM이다.   DOM은 웹페이지의 객체 지향 표현이고, 자바스크립트와 같은 스크립트 언어로 DOM을 수정할수 있다.   ","categories": ["javascript"],
        "tags": ["DOM"],
        "url": "/javascript/dom/",
        "teaser": null
      },{
        "title": "call/apply/bind 함수의 차이점",
        "excerpt":"call/apply/bind 함수의 차이점은?   예제를 보고 확인해보자.      예)    1 2 3 4 5 6 7     const obj = {name:'maru'};     const live = function(city){         console.log(`Hi my name is ${this.name}, I live in ${city}`);     };     live('korea'); // Hi my name is , I live in korea     live.call(obj, 'korea'); // Hi my name is maru, I live in korea     live.apply(obj, ['korea']); // Hi my name is maru, I live in korea   call과 apply는 함수를 호출하는 함수  첫번째 인자인 “obj”로 this를 변경하고 함수를 실행한다.  (apply는 파라미터를 배열로 넣어야 한다.)      예)    1 2 3 4 5 6     const obj = {name:'maru'};     const live = function(city){         console.log(`Hi my name is ${this.name}, I live in ${city}`);     };     const bound = live.bind(obj)     bound('korea'); // Hi my name is maru, I live in korea   bind함수는 함수를 실행하지 않는다.   ","categories": ["javascript"],
        "tags": ["function","call","apply","bind"],
        "url": "/javascript/call-apply-bind/",
        "teaser": null
      },{
        "title": "api",
        "excerpt":"api에 대해 알아보자   “API(Application Progtamming Interface, 응용프로그램 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.” -위키백과   api는 프로그램이 서로 상호작용하는 것을 도와주는 매개체라고 볼 수 있다.  프로그램이 주문하도록 명령을 정리하고, 그 명령을 받아서 응용프로그램과 상호작용하여 요청된 명령에 대한 값을 전달한다.      서버와 데이터베이스의 출입구 역할을 한다.   애플리케이션과 기기가 원활하게 통신하도록 한다.   모든 접속을 표준화 한다.   개발자들이 어플리케이션 코드 작성을 표준화 해서 빠르고 간단히 프로세스 처리가 가능하다.  또한 개발자들간의 협업도 용이해진다.   즉, api는 어떠한 응용프로그램에서 데이터를 주고받기 위한 방법이다.  특정 사이트에서 데이터를 공유할때 어떤 방식으로 요청해야 하는지, 어떤 데이터를 제공 받을수 있는지에 대한 규격들을 말한다.   ","categories": ["javascript"],
        "tags": ["api"],
        "url": "/javascript/api/",
        "teaser": null
      },{
        "title": "호이스팅(Hoisting)",
        "excerpt":"hoisting에 대해 알아보자      자바스크립트에서 호이스팅(Hoisting)이란, 인터프리터가 변수와 함수의 공간을 선언전에 미리 할당 하는 것을 의미한다.    실행컨텍스트의 처리 순서를 살펴보면,     선언 단계(Declaration phase) : 변수, 함수선언문 설정   초기화 단계(Initialization phase) : 변수 이름 바인딩 (값은 undefined로 초기화)   할당 단계(Assignment phase)   위 순서로 처리가 된다.   이때, let변수는 호이스팅 되지 않는다.(사실상 호이스팅은 되지만 안되는것과 비슷하다.) var 변수는 선언단계와 초기화단계가 동시에 진행되어 변수이름을 바인딩하면서 값이 undefined로 초기화되는 반면,  let 변수는 선언단계와 초기화단계가 따로 진행된다.  그래서 실행컨텍스트에 변수가 등록이 되었지만 메모리가 할당이 되어있지 않기 때문에 ReferenceError가 발생한다.   여기서 TDZ가 무엇인지 알고 가자.  TDZ란 “temporal dead zone” 일시적인 사각지대 라고 직역할 수 있다.  TDZ는 스코프의 시작지점 부터 초기화 단계 직전까지의 구간이다.   즉, let변수는 TDZ구간에 의해 메모리가 할당이 되지 않기 때문에 참조에러(ReferenceError)가 발생한다.      예)    1 2 3 4 5     console.log(`스포츠: ${sports}`); // 스포츠: undefined     var sports = '축구';      console.log(`스포츠: ${sports}`); // ReferenceError: sports is not defined     let sports = '축구';  ","categories": ["javascript"],
        "tags": ["hoisting"],
        "url": "/javascript/hoisting/",
        "teaser": null
      },{
        "title": "REST",
        "excerpt":"REST에 대해 알아보자   REST에 대해 알아보기전에 api에 대해 다시 한번 확인해보자.  api에 대한 포스팅이 따로 있지만 여기에서는 비유를 통해 간단히 설명한다.   좋아하는 드라마의 본방사수를 위해서 집에 서둘러 들어와 티비를 켜고 원하는 채널을 틀어야 하는 상황일때 이러한 과정이 필요하다.  티비 리모컨의 전원 버튼을 눌러 티비를 켜고 채널 버튼을 눌러 원하는 채널로 돌려야 한다.  나 &gt; 리모컨 &gt; 티비 이러한 순서로 볼 수 있다.   즉 API는 리모컨 처럼 애플리케이션과 운영체게 사이의 ‘상호작용’을 돕는다.   웹 API의 역할      권한을 가진 사람만 서버와 데이터베이스안의 리소스에 접근이 가능하게 해준다.   모든 요청(request)와 응답(response)를 표준화 해준다.   REST의 구성요소      자원(Resource) : HTTP UIR 를 통한 자원 명시   자원에 대한 행위(Verb) : HTTP Method(post, get put, delete)   자원에 대한 행위의 내용(Representations) : HTTP Message Pay Load   REST API   REST API란 REST의 원리를 따르는 API를 의미한다. 리소스(HTTP URI)로 어떠한 행위(HTTP Method + Pay Load)를 하겠다는 것을 구조적으로 표현하는 방법이다.   REST API의 설계 가이드를 살펴보자.      URI는 명사, 소문자를 사용한다.   마지막에 슬래시를 포함하지 않는다.   언더바 대신 하이픈을 사용한다.   URI에 파일확장자는 포함하지 않는다.   RESTful 이란?   RESTful이란 REST API의 설계 가이드를 올바르게 지킨 시스템을 RESTful 하다고 말할 수 있다. RESTful하게 만들면 그자체로 API의 목적이 무엇인지 명확하게 알 수 있다.  ","categories": ["javascript"],
        "tags": ["api","REST"],
        "url": "/javascript/rest/",
        "teaser": null
      },{
        "title": "Vue에서 Fontawesome 사용하기",
        "excerpt":"Vue에서 Fontawesome 사용하기   폰트어썸 업데이트하면서 부터인지 vue에서 사용하려면 메일로 무료키트 사용 링크를 받아야한다.  fontawsome.com/start로 접속 &gt; 이메일 입력 &gt; 확인, 설정 버튼 클릭 &gt; 폰트어썸 로그인 후 무료키트 링크 카피해서 index.html 헤드에 추가  ","categories": ["vue-lv2"],
        "tags": ["fontawesome"],
        "url": "/vue-lv2/fontawesome/",
        "teaser": null
      },{
        "title": "git branch",
        "excerpt":"git branch 생성하고 사용하는 방법      git init : git 저장소 생성(초기화)   git remote add origin {link} : link에 생성한 레포지토리 url복사해서 넣기   git branch : 깃 브랜치 확인   git branch -v : 마지막 커밋메세지 확인   git branch ‘브랜치명’ : 브랜치 생성   git checkout ‘브랜치명’ : 선택한 브랜치로 이동   git branch -d ‘브랜치명’ : 브랜치 삭제하기   git merge ‘합칠 브랜치명’ : 현재위치한 브랜치에 합칠 브랜치에서 작업한 내용 가져와서 병합   git add . : 변경한 파일을 저장   git commit -m “커밋메세지” : 커밋메세지 입력   git push origin ‘브랜치명’ : 원격저장소 브랜치에 push 하기  ","categories": ["git"],
        "tags": ["branch"],
        "url": "/git/gitbranch/",
        "teaser": null
      },{
        "title": "상단 박스 height 유동적일때 하단 박스 oveflow scroll 시키기(feat. flex)",
        "excerpt":"상단 컨텐츠의 높이값이 유동적으로 바뀌고 하단 박스만 overflow scroll 하는 법   스크롤시 상단 컨텐츠는 고정, 하단 컨텐츠만 overflow-y: auto 시켜야 하는 레이아웃 구현하기   레이아웃 상세 상단 컨텐츠 : 상단 컨텐츠는 내용에 따라서 height값 유동적  하단 컨텐츠 : 리스트를 보여주며 디바이스에서 상단 컨텐츠 height를 뺀 만큼 보이고 overflow 되는 부분은 scroll   코드 보기           1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt;     * {         margin: 0;         padding: 0;     }     .container {         display: flex;         flex-direction: column;         min-height: 100vh;     }     .topBox {         flex: 0;         background: rgb(174, 101, 177);         color: #fff;         padding: 1.2rem      }     .bottomBox {         position: relative;         flex: 1;     }     .scrollBox {         position: absolute;         left: 0; top: 0; right: 0; bottom: 0;         overflow-y: auto;     }     li {         list-style: none;         width: 100%;         height: 150px;         border-bottom: 1px solid #ddd;         align-items: center;         justify-content: center;         display: flex;     }   &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;div class=\"container\"&gt;         &lt;div class=\"topBox\"&gt;헤더 자리&lt;/div&gt;             &lt;div class=\"bottomBox\"&gt;                 &lt;div class=\"scrollBox\"&gt;                     &lt;ul&gt;                         &lt;li&gt;&lt;span&gt;리스트1&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트2&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트3&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트4&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트5&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트6&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트7&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트8&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트9&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트10&lt;/span&gt;&lt;/li&gt;                     &lt;/ul&gt;                 &lt;/div&gt;             &lt;/div&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;      topBox와 bottomBox를 전체 container박스로 묶는다.   bottomBox안에 리스트 박스를 넣는다.   스타일 적용            전체 박스에 display: flex; flex-direction: column; min-height: 100vh;       topBox에 flex: 0;       bottomBox에 position: relative; flex: 1;       리스트 박스에 position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow-y: auto;           적용 예시)        참고 링크   ","categories": ["css"],
        "tags": ["css","flex","overflow","scroll"],
        "url": "/css/flexbox_scroll/",
        "teaser": null
      },{
        "title": "vuex",
        "excerpt":"vuex 소개      복잡한 애플리케이션의 컴포넌트들을 효율적으로 관리하는 vuex 라이브러리   React의 Flux패턴에서 기인함   vue.js 중고급 개발자로 성장하기 위한 필수 관문   Flux란?      MVC 패턴의 복잡한 데이터 흐름 문제를 해결하는 개발 패턴            action : 화면에서 발생하는 이벤트 또는 사용자의 입력       dispatcher : 데이터를 변경하는 방법, 메서드       model : 화면에 표시할 데이터       view : 사용자에게 비춰지는 화면           MVC패턴과 Flux패턴 비교              view : 보고있는 화면       model : 데이터       controller : model과 view 제어                    Flux패턴은 action에서 view까지 단방향으로 일어남 반면 MVC패턴은 model과 view가 서로 데이터를 주고받아서 양방향으로 일어남                            MVC패턴의 문제점              기능 추가 및 변경에 따라 생기는 문제점을 예측할 수 없음.       앱이 복잡해지면서 생기는 업데이트 루프           Flux패턴의 단방향 흐름              데이터의 흐름이 여러 갈래로 나뉘지 않고 단방향으로만 처리           vuex가 왜 필요할까?   복잡한 애플리케이션에서 컴포넌트의 개수가 많아지면 컴포넌트간에 데이터 전달이 어려워진다.      vuex로 해결할 수 있는 문제            MVC 패턴에서 발생하는 구조적 오류       컴포넌트 간 데이터 전달 명시       여러 개의 컴포넌트에서 같은 데이터를 업데이트 할 때 동기화 문제           이벤트 버스로 해결?  어디서 이벤트를 보냈는지 혹은 어디서 이벤트를 받았는지 알기 어려움  1 2 3 4 5 6 7 8 // Login.vue eventBus.$emit('fetch', loginInfo);  // List.vue eventBus.$on('display', data =&gt; this.displayOnScreen(data));  // Chart.vue eventBus.$emit('refreshData', chartData);  컴포넌트 간 데이터 전달이 명시적이지 않음   vuex 컨셉      State : 컴포넌트 간에 공유하는 데이터 data()   View : 데이터를 표시하는 화면 template   Mutations: state값을 변경하는 이벤트 로직, 메서드 methods   Action : 사용자의 입력에 따라 데이터를 변경하는 (비동기 처리 로직을 선언) aysnc methods   흐름 설명 : 화면(view)에서 버튼을 클릭 하면 버튼이 action을 발생시킴 &gt; action이 발동하면 데이터(state)를 변경   vuex 구조   컴포넌트 -&gt; 비동기 로직 -&gt; 동기 로직 -&gt; 상태   action : 비동기 로직  mutations : 동기 로직   자바스크립트 비동기 처리와 콜백함수 참고 링크  ","categories": ["vue-lv2"],
        "tags": ["vuex","store"],
        "url": "/vue-lv2/vuex/",
        "teaser": null
      }]
