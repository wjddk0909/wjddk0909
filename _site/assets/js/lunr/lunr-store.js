var store = [{
        "title": "code splitting",
        "excerpt":"Code Splitting   웹사이트를 만들었는데 첫 로드에 시간이 걸린다면 왜 그럴까?  이유는 햔 페이지만 로드하면 되는 첫 시작 페이지에서 필요하지 않은 여러 페이지(프레임워크를 사용하는 경우 import한 컴포넌트 파일)을 로딩하기 때문   webpack은 이러한 문제점에 대한 해결팩으로 코드 스플리팅을 제공한다.   코드 스플리팅은 웹 사이트를 더 빠르게 운영하는데 도움이 되는 주제이다.  페이지에 필요한 컴포넌트만 로드되고, 원한다면 다른 컴포넌트도 함께 로드할 수 있다. 많은 컴포넌트를 작성하고 여러 경로를 설정(라우팅)해 줘야 하는 대형 프로젝트에서 코드 스플리팅을 사용하면 로드 시간을 단축할 수 있다.   경로 설정에 코드 스플리팅 기능을 적용할 것이기 때문에 라우터가 필요하다.   코드를 분할 하는 방법은 세가지가 있다.     Entry Points : entry 설정을 사용하여 코드를 수동으로 분할   Prevent Duplication : Entry dependencies 또는 SplitChunksPlugin을 사용하여 중복 청크를 제거하고 청크를 분할   Dynamic Imports : 모듈 내에서 인라인 함수 호출을 통해 코드 분할   Dynamic Imports 방법(작성중…)   샘플 코드 만들기   npm install –save-dev @babel/plugin-syntax-dynamic-import  ","categories": ["fe-study"],
        "tags": ["splitting"],
        "url": "/fe-study/fe-code-splitting/",
        "teaser": null
      },{
        "title": "Interceptor/Debounce/throttle",
        "excerpt":"Interceptor/Debounce/throttle   인터셉터는 사용자의 요청을 가로채는 역할(서버에 권한이 있는지 확인하는등) 사용자의 요청이 컨트롤러에 가기 전에 가로채고, 서버의 응답이 사용자에게 가기 전에 가로챈다.   Debounce, throttle 자주 사용 되는 이벤트나 함수 들의 실행되는 빈도를 줄여서, 성능 상의 유리함을 가져오기 위한 개념이다.   debounce(입력주기가 끝나면 출력) : scroll, resize event 이런 이벤트가 끝났을때 한번만 실행되게 하고싶을때 throttle : 일정시간동안 한번만 실행   code)  1 &lt;input id=\"search\" type=\"search\" name=\"search\" value=\"\" /&gt;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var debounce = null; var throttle = null; function keyUpFn(el) {   // normal   console.log('normal', el.target.value, new Date().getTime());   // debounce   clearTimeout(debounce);   debounce = setTimeout(() =&gt; {     console.log(       'debounce',       el.target.value, new Date().getTime());   }, 500);   // throttle   if(!throttle) {     setTimeout(() =&gt; {       console.log('throttle', throttle, new Date().getTime());       throttle = null;     }, 500);   }   throttle = el.target.value; } document.getElementById(\"search\").addEventListener('keyup', keyUpFn); // normal h         1583658583270 // normal he        1583658583582 // normal hel       1583658583878 // normal hell      1583658584182 // throttle hell    1583658584271 // 입력이 끝남 // normal hello     1583658584534 // debounce hello   1583658585036 // throttle hello   1583658585536      Input Search Element 에 Keyup Event Listener 를 등록한다.   normal 에서는, 키보드입력 발생하면, 그 즉시 value 를 출력한다.   throttle 에서는 키보드입력 발생하면, 500ms 후에, 가장 최신 value 를 출력하고, 초기화 하여, 키보드 입력이 끝날때까지 반복한다.   debounce 에서는 키보드 입력이 발생하면, 500ms 동안 기다리다, 그 안에 키보드 입력이 발생하면, 시간을 초기화 하고 다시 기다리다, 가장 최신 value 를 출력한다.   Throttle  여러번 발생하는 이벤트를 일정 시간 동안, 한번만 실행 되도록 만드는 개념이다.  위 예제에서 500ms 동안 이벤트 실행을 막고, 한번만 실행 때문에, 잦은 이벤트 발생을 막아 성능상의 유리함을 가져 올 수 있다.  Debounce 와 다른점은 이벤트 발생 시간 이후에 일정 시간 동안 만을 기다리고, 이벤트를 실행 후 재차 기다린 다는 점이다.   Debounce  가장 마지막 이벤트 만을 실행 되도록 만드는 개념이다.  입력이 끝날때, 가장 마지막 이벤트만을 실행하여, 성능성 유리함을 가져올 수 있다.  Throttle 와 다른점은, 마지막 이벤트에서 일정 시간동안 이벤트가 발생한다면, 또 일정 시간을 기다린다는 점이다.   Throttle 와 Debounce 차이점  Throttle 와 Debounce 의 차이점은 이벤트를 언제 발생 시킬지의 시점 차이이다.  Debounce 는 입력이 끝날때까지 무한적으로 기다리지만, Throttle 는 입력이 시작되면, 일정 주기로 계속 실행한다.  Debounce 의 시간을 짧게 가져간다면, Throttle 와 비슷한 효과가 날 수 있지만, 그럼에도 시점에서 차이가 날 수 있다.   대표적인 예로 자동완성 만들 경우,  일정 주기로 자동으로 완성되는 리스트를 보여주는 것에는  사용자 측면에서 Throttle (검색 되는 경험) 가 유리할 수 있지만,  성능상에서는 Debounce (1번만 호출) 가 훨씬 유리할 수 있다.   ","categories": ["fe-study"],
        "tags": ["interceptor"],
        "url": "/fe-study/fe-interceptor/",
        "teaser": null
      },{
        "title": "아키텍처",
        "excerpt":"아키텍처는 무엇으로 이루어지는가?   아키텍처는 일반적인 정의에 따르면 설계자가 원하는 기능을 구조로 표현하는 고수준 결과물이다.  아키텍처는 의도, 규칙, 구성, 대상으로 이루어진다.      아키텍처는 의도를 가져야 한다.            설계자의 생각을 표현허는 과정인 만큼 아키텍처에는 생각, 의도가 담겨있다.           아키텍처는 규칙을 가져야 한다.            기능을 구조로 맵핑하는 설계 결과물       시스템을 구성하는 요소와 요소간의 관계, 요소들을 포함하는 전체 시스템의 경꼐, 시스템과 환경 간의 관계 등을 포함한다.           대상(결과물)을 가져야 한다.            대상(결과물)은 아키텍처를 기초로 만들어질 최종 산출물을 의미           의도 &gt; (표현) &gt; 규칙 &gt; (구체화) &gt; 구성 &gt; (구현) &gt; 대상/결과물      아키텍처란?  옷을 정리하는 것을 상상해보자. 처음에는 옷이 몇개 없어서 아무데나 두어도 크게 상관이 없다.  하지만 옷이 많아지면 옷걸이가 필요하고 더 많아지면 옷장이 필요해진다.   옷걸이와 옷장이 있고 없고의 차이는?  옷이 제대로 보관되지 않아서 옷이 상할 것이고 원할때 필요한 옷을 찾기가 힘들어진다.  그렇다고 옷장에 막무가내로 넣어두기만 하면 어떨까?  옷장의 첫번째 역할인 보관이라는 목적은 충실했지만 필요한 옷을 쉽게 찾아 꺼낸다는 목적은 잃게 된다.  그러니 보관을 하되 잘 꺼낼 수 있도록 잘 넣어두는 방법을 고려해야 한다.   그러려면 일단 잘 넣어두기 위해서 하지 말아야할 규칙을 정한다.  예를 들어 옷을 아무렇게나 섞어서 두면 불편하다, 양말이 짝이 안맞다, 위아래 세트인 옷을 찾기 힘들다 등등..  이 불편함을 제거하기 위한 규칙을 만든다. 일반적으로 비슷한 것끼리 분류해서 모은다.   이러한 과정에서 패턴이 만들어지면 나중에는 이 패턴에 맞는 목적성을 가진 옷장이 등장한다.  처음에는 단순히 통으로 된 옷장이었다면 상의, 하의를 구분하는 칸이 나뉘어져 있다가 양발을 보관하는 칸이 생기고, 외투나 모자, 가방등 각 용도에 맞는 구조로 만들어진다.   그러면 처음의 옷장에 비해서 세부적인 규칙을 잘 몰라도 옷 정리가 한결 편해진다.      아키텍처란 구조화 된 옷장과 비슷하다. 처음 개발할 때에는 규칙없이 그냥 코드를 만들다 보면 프로젝트의 덩치가 커지고 불편함이 생기고 코드 정리가 안되는 시점이 생긴다. 그러니 처음부터 특정한 규칙을 만들어서 개발하는게 좋다는 것을 깨닫고 규칙을 하나씩 만들어가며 개발을 하다보면 이제 특정 패턴이 만들어진다. 이러한 패턴들을 모두가 이해하고 따를 수 있도록 하는 구조를 아키텍처라고 부른다.    결국 소프트웨어 관점에서 봤을때 지속적으로 관리가 잘 되는 코드를 위해서는 좋은 아키텍처가 필요하다는 의미이다.      비유는 엄밀하게는 같은 이야기는 아니다. 옷은 서로 데이터를 주고 받지 않지만 소프트웨어의 각 모듈들은 서로 데이터를 주고 받아야한다. 그러니 아키텍처를 단순히 분류를 넘어 데이터를 주고 받는 인터페이스 설계가 중요하다.       웹 프론트엔드 아키텍처 아키텍처는 좋은 구조를 만드는것. 좋은 구조의 첫번째 조건은 좋은 분류이다.      옷장에서 상의, 하의, 양말 처럼 서로 비슷한 것 끼리 그리고 섞이면 안되는 것끼리 구분을 하는 것이 중요!    ","categories": ["fe-study"],
        "tags": ["architecture"],
        "url": "/fe-study/fe-modular-architecture/",
        "teaser": null
      },{
        "title": "자바스크립트 모듈화",
        "excerpt":"자바스크립트의 모듈화   자바스크립트는 기본적으로 모듈화 기능이 없었다. .js파일로 여러개 쪼개서 모든 파일을 하나씩 &lt;script&gt;&lt;/script&gt; 태그를 이용하여 불러오는 방법이 있긴 했지만 이 방법에는 문제가 있었다.     파일을 불러들이는 순서가 중요   따로 만든 오브젝트들이 모두 글로벌 변수에 저장   변수의 이름이 겹치면 에러 발생   그래서 다른 사람이 만든 코드 불러들여서 사용하기 복잡   모듈(Module)   프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화한다.  코드의 재활용성을 높이고, 유지보수를 쉽게 할 수 있는 다양한 기법들이 사용된다.  그중의 하나가 코드를 여러개의 파일로 분리하는 것이다. 이를 통해서 얻을 수 있는 효과는 아래와 같다.     자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용(함수의 재사용성과 비슷)   코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.   코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다. (파일로 모듈을 쪼개어 놔서)   필요한 로직(파일)만을 로드해서 메모리 낭비를 줄일 수 있다.   모듈화의 중요성은?  모듈화가 중요한 이유는 코딩 작업이 편리해지고 코드의 유지보수가 편해져서이다.  하나의 .js파일에 모든 코드가 다 들어있으면 그것을 뜯어보고 이해하고 고치는데 시간이 많이 걸린다.  하지만 각 기능에 맞춰서 코드를 나누어서 관리하면 코드를 고치거나 업데이트 할 때 해당 부분만 쉽게 찾아서 작업이 가능하다.   방법은?     export default export할 모듈이 하나 밖에 없을 때 이용   1 2 3 4 var a = function() {     console.log('hello') } export default a;      named export export할 모듈이 여러개 있을 때 이용   1 2 3 4 5 6 7 8 9 10 var a = function() {     console.log('hello'); }  var b = function() {     console.log('bye'); }  export const hi = a; export const bye = b;   위 두가지의 차이점은 어떤 export 방식을 택하느냐에 따라서 모듈을 import 하는 방식이 달라진다.      1번 방법으로 export 했을때 import 방법 import 할때 원하는 이름을 임의로 지정할 수 있다.   1 import ABC from './a.js';  export는 a로 했지만 import할 때는 아무 이름이나 사용이 가능하다.  1 import {default as 원하는 이름} from './a.js';   혹이 이런식으로도 가능하다.      2번 방법으로 export 했을 때 import 방법 import 할 때 이름이 export에서 지정한 이름과 같아야 하고 반드시 {}안에 적어야한다.   1 import { hi, bye } from './a.js';  이렇게 원하는 부분만 골라서 불러 올 수 있다. 만약 모든 모듈을 한꺼번에 불러와야한다면 아래와 같은 방법을 사용한다.   1 2 3 4 5 6 import * as say from './a.js'; // say가 아닌 다른 이름도 가능 (임의로 설정한 이름임)  // 사용은 아래와 같이 say.hi(); // 결과 -&gt; hello  ","categories": ["fe-study"],
        "tags": ["Module"],
        "url": "/fe-study/fe-module/",
        "teaser": null
      },{
        "title": "npm install / --save / --save-dev 차이",
        "excerpt":"그냥 install(add)  npm install / yarn add 단순히 ./node_modeuls폴더에 패키지 설치   –save / -P  npm install --save / yarn add --save --save키워드를 통해 우선 ./node_modules폴더에 패키지 설치  ./package.josn의 dependencies 옵션에 해당 패키지 추가되어 다음 install시 해당 패키지가 자동으로 설치됨   –save-dev / -D  npm install --save-dev / yarn add --save-dev ./package.json의 devDependencies옵션에 해당 패키지 추가  ","categories": ["fe-study"],
        "tags": ["npm","yarn","install"],
        "url": "/fe-study/fe-npm-install/",
        "teaser": null
      },{
        "title": "1 - 개발 환경 설정",
        "excerpt":"1.1 vue 개발 환경 설정      chrome 설치   vs code 설치   node.js LTS 버전 설치   크롬 확장 프로그램 Vue.js devetools 설치   참고 링크     Chrome   vs code   node.js   Vue.js devtools   1.2 수업 소스 코드 안내   깃 업로드 후 추가 예정   1.3 vs code 플러그인 설치     확장버튼 클릭               Vetur   Night Owl   Material Icon Theme   Live Server   ESLint   Prettier   Auto Close Tag  이미지로 첨부한 것 이외에도 추가하면 좋을 확장프로그램 리스트입니다.   Material Icon Theme 적용하는 방법       code &gt; 기본 설정(Preferences) &gt; 파일 아이콘테마(File Icon Theme) 클릭        Material Icon Theme 선택   ","categories": ["vue-lv1"],
        "tags": ["vue","setting"],
        "url": "/vue-lv1/vue-beginner1/",
        "teaser": null
      },{
        "title": "2 - vue.js 소개",
        "excerpt":"2.1 vue는 무엇인가?   MVVM패턴의 뷰모델(ViewModel) 레이어에 해당하는 화면(View)단 라이브러리   View라고 되어 있는 것은 브라우저에서 사용자에게 비춰지는 화면을 의미한다.  즉, 버튼이나 입력박스등이 해당한다.   사용자가 키보드로 입력했을때 이벤트를 중간에 DOM Listener로 view에서 읽게 됩니다. 그런 이벤트를 잡아서 데이터를 바꾸거나 특정 로직에서 실행을 합니다.   자바스크립트의 데이터가 변했을때 Data Bindings를 하게 됩니다. 그리고 Data Bindings를 이용해서 화면에 반영합니다.      2.2 기존 웹 개발 방식(HTML, Javascript)   일반적으로 프레임워크를 쓰지 않고 웹을 개발하는 방법은 HTML, CSS, Javascript를 사용합니다.   1 2 3 4 5 6 7 8 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var str = \"Hello World\";     console.log(div);     div.innerHTML = str; &lt;/script&gt;   이렇게 작성하고 브라우저에서 확인을 하면 브라우저에서 확인 할 수 있습니다.      html은 화면에 나타나는 태그나 돔의 정보를 넣는 것 이고 자바스크립트는 해당 태그나 돔의 내용을 조작하는 것을 알 수 있습니다.   여기에서 str의 값을 바꿀때는 바뀐 문자열의 내용을 다시 넣어줘야 합니다.   1 2 3 4 5 6 7 8 9 10 11 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var str = \"Hello World\";     console.log(div);     div.innerHTML = str;      str = \"Hello World!!!\";     div.innerHTML = str; &lt;/script&gt;   2.3 Reactivity 구현   기존의 개발 방식에서 vue.js의 핵심 기능인 Reactivity를 이용해보겠습니다.   div정보만 받아놓은 상태에서 viewModel이라는 객체를 선언하고  Object.defineProperty()라는 api를 사용해보겠습니다.   Object.defineProperty()가 하는 역할은 객체의 동작을 재정의 하는 api라고 보시면 됩니다.  변수 a에 10을 할당하면 a에 접근 할 수 있습니다. 혹은 a를 20으로 바꿀 수 있습니다. 특정 변수, 객체의 속성 동작을 재정의 하는것이 Object.defineProperty() 입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var viewModel = {};      // Object.defineProperty(대상객체, 객체의 속성, {               // });      Object.defineProperty(viewModel, 'str', {         // 속성의 접근했을 때의 동작을 정의         get: function() {             console.log('접근');         },         // 속성에 값을 할당했을 때의 동작을 정의         set: function(newValue) {             console.log('할당', newValue);         }     }); &lt;/script&gt;   콘솔창에서 확인을 해봅시다.    여기에서 str의 값이 바뀌면 바뀐 값을 화면에 뿌리도록 정의 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var viewModel = {};      Object.defineProperty(viewModel, 'str', {         get: function() {             console.log('접근');         },         set: function(newValue) {             console.log('할당', newValue);             div.innerHTML = newValue;         }     }); &lt;/script&gt;      값을 바꿀 때마다 화면이 바뀌는 것을 확인 할 수 있습니다.  vue의 핵심은 데이터의 변화를 라이브러리에서 감지해서 알아서 화면을 자동으로 그려주는 Reactivity입니다.   2.4 Reactivity 코드 라이브러리화 하기   코드를 라이브러리화 해보겠습니다.  init()이라는 함수안에 Object.defineProperty를 잘라서 넣습니다.  render()함수를 만들어서 div에 텍스트 값을 바꾸는 부분을 옮기고 set에서 render()를 호출해서 새로운 값이 할당 됐을때 render()에 넘겨주도록 합니다.  그리고 최종적으로 즉시실행 함수 안에 넣어줍니다.  즉시실행 함수의 역할은 기본적으로 애플리케이션의 로직에 노출되지 않도록 또다른 유효범위(스코프)에 넣어주는 것입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script&gt;     var div = document.querySelector('#app');     var viewModel = {};      (function() {         function init() {             Object.defineProperty(viewModel, 'str', {                 get: function() {                     console.log('접근');                 },                 set: function(newValue) {                     console.log('할당', newValue);                     render(newValue)                 }             });         }         function render(value) {             div.innerHTML = value;         }         init();     })(); &lt;/script&gt;   2.5 Hello Vue.js와 뷰 개발자 도구   간단하게 뷰로 Hello Vue.js를 화면에 찍어 보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;div id=\"app\"&gt;      &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             message: 'Hello Vue.js'         }     }) &lt;/script&gt;   코드를 브라우저에서 확인 해봅시다.      크롬 개발자 모드에서 vue탭으로 이동후 data &gt; message: “Hello Vue.js”의 내용을 바꾸면 화면에서 바로 반영이 됩니다.   ","categories": ["vue-lv1"],
        "tags": ["vue"],
        "url": "/vue-lv1/vue-beginner2/",
        "teaser": null
      },{
        "title": "3 - 인스턴스",
        "excerpt":"3.1 인스턴스 소개   뷰에서 첫번째로 알아야 할 개념은 인스턴스 입니다. 인스턴스는 뷰로 개발 할때 필수로 생성해야 할 단위입니다.   인스턴스를 생성하고 나면 변수안에 인스턴스의 내용을 담을 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var vm = new Vue({         el: '#app',         data: {             message: 'hi'         }     }); &lt;/script&gt;   vm이라는 변수에 new Vue라고 인스턴스를 생성합니다.  el: ‘#app” &gt; app이라는 아이디를 가진 태그를 찾아서 인스턴스를 붙이겠다 라는 의미입니다.  이렇게 붙이는 순간 vue의 기능과 속성들이 유효해 집니다.   3.2 인스턴스와 생성자 함수   생성자 함수를 만들고 name과 job을 인자로 받아서 정보들을 인스턴스로 찍어낼 수 있습니다.  함수를 선언하면 객체가 생성됩니다.      뷰를 왜 생성자 함수로 찍어내는지 보겠습니다.   Vue라는 생성자 함수를 이용해서 기능을 편하게 쓰게 하고 싶을때, logText()라는 함수를 미리 정의 해놓습니다.  그럴때 vm으로 new Vue()를 생성할 때마다 logText()함수가 들어가 있습니다. 그래서 매번 함수를 정의하는게 아니라 함수를 가져다 사용할 수 있습니다.      3.3 인스턴스 옵션 속성   1 2 3 4 5 6 7 8 new Vue({     el:,     template:,     data:,     methods:,     created:,     watch:, });   1 2 3 4 5 6 7 8 9 10 11 12 var vm = new Vue({     el: '#app',     data: {         message: 'hi'     },     methods: {              },     created: function() {      } });   ","categories": ["vue-lv1"],
        "tags": ["vue"],
        "url": "/vue-lv1/vue-beginner3/",
        "teaser": null
      },{
        "title": "4 - 컴포넌트",
        "excerpt":"4.1 컴포넌트 소개   vue.js의 컴포넌트에 대해서 알아보겠습니다. 컴포넌트는 화면의 영역을 구분하여 개발할 수 있는 뷰의 기능입니다. 컴포넌트 기반으로 화면을 개발하게 되면 코드의 재사용성이 올라가고 빠르게 화면을 만들 수 있습니다.  컴포넌트는 영역을 구분했을 때 컴포넌트간에 관계가 생깁니다.   4.2 컴포넌트 등록 및 실습   인스턴스를 생성하면 개발자 도구에서 Root컴포넌트로 인식합니다.   컴포넌트를 등록하는 가장 간단한 방법은 전역 컴포넌트로 등록하는 방법입니다. 전역 컴포넌트를 등록하고 인스턴스의 영역에 컴포넌트 태그를 넣어주면 됩니다.  (실제 서비스를 할때는 전역컴포넌트를 등록하는 일은 거의 없을것입니다.)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;x &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     // Vue.component('컴포넌트 이름', 컴포넌트 내용);     // 전역 컴포넌트     Vue.component('app-header', {         template: '&lt;h1&gt;Header&lt;/h1&gt;'     });      new Vue({         el: '#app'     }); &lt;/script&gt;   4.3 지역 컴포넌트 등록   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     // Vue.component('컴포넌트 이름', 컴포넌트 내용);     // 전역 컴포넌트     Vue.component('app-header', {         template: '&lt;h1&gt;Header&lt;/h1&gt;'     });      new Vue({         el: '#app',         components: {             // '컴포넌트 이름': 컴포넌트 내용             'app-footer': {                 template: '&lt;footer&gt;footer&lt;/footer&gt;'             }         }     }); &lt;/script&gt;      4.4 전역 컴포넌트와 지역 컴포넌트의 차이점   지역컴포넌트는 하단에 어떤게 등록되어있는지 알 수 있습니다.  서비스를 구분할 때는 지역컴포넌트를 이용해서 아래에 등록해 나갑니다.   전역은 플러그인이나 라이브러리 형태로 전역으로 사용하는 컴포넌트만 전역으로 등록합니다.   4.5 컴포넌트와 인스턴스와의 관계   새로운 인스턴스를 생성하고 div#app2를 만들어서 인스턴스를 연결하고 전역컴포넌트와 #app에 만들었던 지역컴포넌트 태그를 넣어줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/div&gt; &lt;div id=\"app2\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     // Vue.component('컴포넌트 이름', 컴포넌트 내용);     // 전역 컴포넌트     Vue.component('app-header', {         template: '&lt;h1&gt;Header&lt;/h1&gt;'     });      new Vue({         el: '#app',         components: {             // '컴포넌트 이름': 컴포넌트 내용             'app-footer': {                 template: '&lt;footer&gt;footer&lt;/footer&gt;'             }         }     });      new Vue({         el: '#app2'     }) &lt;/script&gt;   화면에서 확인 하면 app-footer컴포넌트는 #app2에 등록한 지역컴포넌트가 아니기 때문에 보이지 않습니다. 지역컴포넌트는 인스턴스를 생성할 때마다 생성해 줘야 합니다.     ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner4/",
        "teaser": null
      },{
        "title": "5 - 컴포넌트 통신 방법) 기본",
        "excerpt":"5.1 컴포넌트 통신   뷰에서 컴포넌트를 등록했을때 관계가 생깁니다.  예를 들어서 아래 그림과 같이 컴포넌트를 나눴을때를 봅시다.      화면에서 연회색으로 되어있는 3개의 부분으로 나눴을때 그안에 진회색으로 컴포넌트를 나눌때마다 그 컴포넌트가 하위(자식)컴포넌트로 위치합니다.   이 관계의 중요한 점은, 규칙이 생긴다는 것입니다.  컴포넌트는 각각 고유한 데이터 유효 범위를 갖습니다. 따라서 컴포넌트 간에 데이터를 주고 받기 위해선 아래와 같은 규칙을 따라야 합니다.         상위에서 하위로는 데이터를 내려줌, 프롭스 속성   하위에서 상위로는 이벤트를 올려줌, 이벤트 발생   5.2 컴포넌트 통신 규칙이 필요한 이유   예를 들어서 헤더, 컨텐트, 푸터 컴포넌트를 등록하고  그리고 그 컴포넌트 밑에 각각 컴포넌트를 하나씩 등록했다고 합시다.      여기에서 만약 헤더에서 로그인폼으로 데이터를 전달하고, 그 정보를 다시 푸터로 보냅니다.  그리고 푸터에서 다시 네비게이션바로 데이터를 보낸 상황을 가정합니다.  이런식으로 특정 컴포넌트의 변화에 따라서 나머지 컴포넌트가 유기적으로 데이터를 주고받았을때 데이터의 방향을 예측하기가 어려워집니다.  데이터가 바뀌었을떄 그로 인한 버그를 추적하기가 어려운게 n방향 통신의 문제점입니다.   컴포넌트 통신방식을 살펴봅시다.      컴포넌트 통신방식은 데이터가 아래로만 내려갑니다.  데이터의 흐름을 추적할 수 있습니다. 데이터는 항상 내려오고 이벤트는 올라갑니다.   5.3 props 속성   app-header컴포넌트를 만들고 data에 메세지를 정의해주면 Root컴포넌트에 message가 생성됩니다.  이 데이터를 aa-header로 내리려면 props를 사용하면 됩니다.  v-bind:프롭스 속성 이름 = “상위 컴포넌트의 데이터 이름”으로 넣어줍니다.  app-header의 기준으로 상위컴포넌트는 root가 되고 그 데이터 이름은 message입니다.  프롭스 속성 이름은 appHeader라는 변수 안에 정의 해주고 그것을 사용하면 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=\"app\"&gt;     &lt;!-- &lt;app-header v-bind:프롭스속성 이름=\"상위 컴포넌트의 데이터 이름\"&gt;&lt;/app-header&gt; --&gt;     &lt;app-header v-bind:propsdata=\"message\"&gt;&lt;/app-header&gt;     &lt;app-content v-bind:propsdata=\"num\"&gt;&lt;/app-content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;h1&gt;header&lt;/h1&gt;',         props: ['propsdata']              }     new Vue({         el: '#app',         components: {             'app-header': appHeader,         },         data: {             message: 'hi',         }     }) &lt;/script&gt;   뷰 개발자 도구로 확인해 보면 app-header에 propsdata로 들어가 있는 걸 볼 수 있습니다.      5.4 props 속성의 특징   props코드를 등록하면 root컴포넌트(상위컴포넌트)의 message값이 바뀌면 그대로 app-header에도 내려가 반영이 됩니다.  데이터바인딩을 이용하여 상위 컴포넌트의 데이터값이 바뀌면 하위 컴포넌트의 프롭스 속성이 반영되면서 화면에 나타나도록 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &lt;div id=\"app\"&gt;     &lt;!-- &lt;app-header v-bind:프롭스속성 이름=\"상위 컴포넌트의 데이터 이름\"&gt;&lt;/app-header&gt; --&gt;     &lt;app-header v-bind:propsdata=\"message\"&gt;&lt;/app-header&gt;     &lt;app-content v-bind:propsdata=\"num\"&gt;&lt;/app-content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;h1&gt;&lt;/h1&gt;',         props: ['propsdata']              }     var appContent = {         template: '&lt;div&gt;&lt;/div&gt;',         props: ['propsdata']     }     new Vue({         el: '#app',         components: {             'app-header': appHeader,             'app-content': appContent         },         data: {             message: 'hi',             num: 10         }     }) &lt;/script&gt;   5.5 event emit   아래에서 위로 통신하는 법은 이벤트를 올립니다.  이벤트에 대해서 실습해 봅시다.   뷰 인스턴스를 하나 생성하고 app-header컴포넌트를 등록하고 템플릿으로 버튼을 하나 만들어 줍니다.  버튼을 클릭했을때 이벤트를 실행하는 방법은 v-on:click으로 할 수 있습니다.   이 버튼을 클릭했을때 root로 이벤트를 보낼겁니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;button v-on:click=\"passEvent\"&gt;Click me&lt;/button&gt;',         methods: {             passEvent: function() {                 this.$emit('pass');             }         }     }     var vm = new Vue({         el: '#app',         components: {             'app-header': appHeader,         },     }) &lt;/script&gt;   이 상태에서 뷰 개발자 도구로 확인하면 버튼 클릭시 pass 이벤트가 발생합니다.   5.6 event emit으로 콘솔 출력하기   $emit은 뷰에서 제공하는 api(기능)인데 이것을 이용해서 pass라는 이벤트를 발생 시켰습니다.  이것을 위에서 받을 수 있게 컴포넌트 태그에서 조작을 해 보겠습니다.  프롭스 등록과 비슷하게 태그에서 올라온 이벤트를 잡아줘야 합니다.  하위에서 발생한 이벤트 이름은 pass이고 상위 컴포넌트 메서드 이름은 logText로 지정해줍니다.  pass라는 이벤트가 아래에서 올라왔을 때 그게 컴포넌트 태그에서 받아서 logText라는 메서드를 실행합니다.   ++ 추가로 content 넣어보기  똑같이 컴포넌트를 추가해주고, addNumber 이벤트를 추가해봅시다.  add버튼을 클릭했을때 this.$emit으로 이벤트를 올려서 위에 있는 data의 num값을 1씩 증가 시켜보겠습니다.  increase라는 하위 컴포넌트에서 발생한 이벤트 이름을 받아서 상위 컴포넌트의 메서드 increaseNumber를 실행시킵니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 &lt;div id=\"app\"&gt;     &lt;p&gt;&lt;/p&gt;     &lt;!-- &lt;app-header v-on:하위컴포넌트에서 발생한 이벤트 이름=\"상위 컴포넌트 메서드 이름\"&gt;&lt;/app-header&gt; --&gt;     &lt;app-header v-on:pass=\"logText\"&gt;&lt;/app-header&gt;     &lt;app-Content v-on:increase=\"increaNumber\"&gt;&lt;/app-Content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;button v-on:click=\"passEvent\"&gt;Click me&lt;/button&gt;',         methods: {             passEvent: function() {                 this.$emit('pass');             }         }     }     var appContent = {         template: '&lt;button v-on:click=\"addNumber\"&gt;add&lt;/button&gt;',         methods: {             addNumber: function() {                 this.$emit('increase')             }         }     }     var vm = new Vue({         el: '#app',         components: {             'app-header': appHeader,             'app-content': appContent         },         methods: {             logText: function() {                 console.log('hi');             },             increaNumber: function() {                 this.num = this.num + 1             }         },         data: {             num: 10         }     }) &lt;/script&gt;   5.7 뷰 인스턴스에서의 this   obj라는 객체를 생성하고 this를 찍으면 obj를 바라봅니다.   1 2 3 4 5 6 var obj = {     num: 10,     getNumber: function() {         console.log(this.num);     } }  따라서 실습해봤던 코드에서 console.log(vm)을 찍으면 뷰에서 생성한 내용들이 담깁니다.  이것을 펼쳐서 보면 data안에 정의했던 num: 10이 바깥레벨로 나와서 바로 보입니다.  따라서 this.num은 data의 num속성을 가리킵니다.     this 관련글 1  this 관련글 2  ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner5/",
        "teaser": null
      },{
        "title": "vue에서 scss 사용하기",
        "excerpt":"vue에서 scss 사용 기본 설정   scss 패키지 설치  node-sass와 sass-loader 설치   yarn add node-sass -D yarn add sass-loader -D   사용법  간단한 설치만으로도 vue-loader에서 기본으로 설정되어있는 webpack 설정 때문에 패키지 설치 후 컴포넌트 내에서 lang속성을 지정해주면 자동으로 Loader를 사용 할 수 있음   1 2 3 4 5 6 // 컴포넌트 내에 lang속성으로 scss 명시 // 스타일 내부 scss 파일 import하는 방법 // 경로에서 @의 경우 /src와 같은 의미 &lt;style lang=\"scss\"&gt;     @import \"@/asstes/scss/파일명\"; &lt;/style&gt;   전역 스타일 및 변수 설정 변수를 담아둔 scss 파일을 매번 컴포넌트에서 불러와 사용하는 것은 효율적이지 않음  따라서 자주 사용하는 변수나 reset스타일, mixin같은 경우 전역 스타일을 설정해서 사용 가능   설정방법  vue.config.js 파일 생성해서 webpack 설정을 추가   1 2 3 4 5 6 7 8 9 10 11 module.exports = {     css: {         loaderOptions: {             sass: {                 additionalData: `                     @import \"@/assets/scss/abstracts/abstracts.scss\";                 `             }         }     } }   1 2 3 4 5 6 7 8 9 //예시 $TEXT_DEFAULT: #333;  //다른컴포넌트 &lt;style lang=\"scss\"&gt;     p {         color: $TEXT_DEFAULT     } &lt;/style&gt;  ","categories": ["vue-study"],
        "tags": ["scss"],
        "url": "/vue-study/fe-vue-scss/",
        "teaser": null
      },{
        "title": "vue.js 프로젝트 구조 : views와 components의 차이",
        "excerpt":"vue.js 프로젝트 구조   views폴더와 components폴더의 차이는  router에서 보여주는 component파일은 views폴더에 넣고, 그 외에는 components폴더에 넣는다.  (폴더 구조는 사실 어떻게 하든 상관없지만, vue cli가 제시하는 예시이다.)   ","categories": ["vue-study"],
        "tags": ["views","components"],
        "url": "/vue-study/fe-vue-views-components/",
        "teaser": null
      },{
        "title": "6 - 컴포넌트 통신 방법) 응용",
        "excerpt":"6.1 같은 컴포넌트 레벨 간의 통신 방법   같은 레벨의 컴포넌트 간의 통신 방법에 대해서 알아 보겠습니다.  Root(인스턴스)에서 appHeader와 appContent라는 컴포넌트를 등록했을때 컨텐트에서 헤더로 10이라는 데이터를 전달해 보겠습니다.      6.2 같은 컴포넌트 레벨 간의 통신 방법 구현   new Vue로 인스턴스를 생성하고 el로 #app에 붙이면 인스턴스가 div태그안에서 유효하게 됩니다.  components라는 속성으로 appHeader와 appContent 컴포넌트를 만들어줍니다.  구조도 처럼 컨텐트에서 헤더로 10을 넘기겠습니다.  content에서 버튼을 넣고 이 버튼을 누르면 신호를 발생 시킬겁니다.  그러면 methods를 정의하고 버튼을 클릭했을때 passNum이라는 이벤트를 발생시키고 함수를 이어줍니다.  this.$emit으로 pass라는 이벤트와 10을 넘겨주고 화면에서 확인하면 뷰 개발자 도구 이벤트탭에서 pass 이벤트가 발생하면서 10이 넘어옵니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 &lt;div id=\"app\"&gt;     &lt;app-header&gt;&lt;/app-header&gt;     &lt;app-content&gt;&lt;/app-content&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     var appHeader = {         template: '&lt;div&gt;header&lt;/div&gt;',     }     var appContent = {         template: '&lt;div&gt;content&lt;button v-on:click=\"passNum\"&gt;pass&lt;/button&gt;&lt;/div&gt;',         methods: {             passNum: function() {                 this.$emit('pass', 10)             }         }     }     new Vue({         el: '#app',         components: {             'app-header': appHeader,             'app-content': appContent         },     }) &lt;/script&gt;      content에서 바로 header로 이벤트를 보낼 수 없기 때문에 content에서 root로 event를 통해서 10을 보내고 root에서 header로 props로 10을 다시 내려야 합니다.      root에서 props를 내리려면 데이터를 선언하여야 합니다.  content에서 passNum이라는 메서드가 실행되면서 this.$emit으로 pass이벤트가 올라왔는데 v-on으로 pass 이벤트를 받을 수 있습니다.  하위 컴포넌트 이벤트를 v-on으로 받아서 상위 컴포넌트 인스턴스에 메서드로 추가한 deliverNum를 연결해 줍니다. pass로 넘어오면서 인자 10도 같이 넘어옵니다. 이 인자 10은 받는 쪽에서 deliverNum(value)로 넣어줍니다.  넘어온 value를 this.num = value로 넣어줄 수 있습니다.  pass 버튼을 눌러서 이벤트가 발생하면 Root의 num이 10으로 바뀝니다.  이렇게 넘어온 데이터를 appHeader로 전달해 주면 됩니다.  v-bind로 props속성을 넣어줍니다.   화면에서 content의 porpsdata가 0이었다 버튼을 클릭하면 10으로 바뀌는 것을 확인 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;div id=\"app\"&gt;         &lt;app-header v-bind:propsdata=\"num\"&gt;&lt;/app-header&gt;         &lt;app-content v-on:pass=\"deliverNum\"&gt;&lt;/app-content&gt;     &lt;/div&gt;     &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;     &lt;script&gt;         var appHeader = {             template: '&lt;div&gt;header&lt;/div&gt;',             props: ['propsdata']         }         var appContent = {             template: '&lt;div&gt;content&lt;button v-on:click=\"passNum\"&gt;pass&lt;/button&gt;&lt;/div&gt;',             methods: {                 passNum: function() {                     this.$emit('pass', 10)                 }             }         }         new Vue({             el: '#app',             components: {                 'app-header': appHeader,                 'app-content': appContent             },             data: {                 num: 0             },             methods: {                 deliverNum: function(value) {                     this.num = value;                 }             }         })     &lt;/script&gt;  ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner6/",
        "teaser": null
      },{
        "title": "7 - 라우터",
        "excerpt":"7.1 뷰 라우터 소개와 설치   뷰 라우터는 뷰 라이브러리를 이용하여 싱글 페이지 애플리케이션을 구현할 때 사용하는 라이브러리입니다.   라우터 공식 문서 링크   위 링크로 접속하여 Installation에서 상단의 CDN주소를 복사해 줍니다.      https://unpkg.com/vue-router/dist/vue-router.js   파일을 만들어 보며 실습해 봅시다.  뷰 라이브러리와 router.js CDN 주소를 넣어주고 기본 골격을 만들어 봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     new VueRouter({      });      new Vue({         el: '#app',     }); &lt;/script&gt;   7.2 뷰 라우터 인스턴스 연결 및 초기 상태 안내   뷰 라우터를 인스턴스에 동작 시켜 보겠습니다.  VueRouter를 router라는 변수에 넣어주고 Vue인스턴스에 연결해 주고 브라우저에서 뷰 개발자 도구로 확인해 보면 Root에 $router가 잡히는 것을 볼 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var router = new VueRouter({      });      new Vue({         el: '#app',         router: router,     }); &lt;/script&gt;   7.3 routes 속성 설명 및 실습 안내   세팅한 코드로 라우터에 대한 정보를 추가 해 보겠습니다.  첫번째로 routes라는 속성입니다.  이 속성에는 페이지 라우팅 정보가 들어갑니다. (어떤 url로 이동했을때 어떤 페이지가 뿌려질지에 대한 정보가 배열로 담깁니다.)  이 배열에 페이지 라우팅 정보를 담아보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var LoginComponent = {         template: '&lt;div&gt;login&lt;/div&gt;'     }     var MainComponent = {         template: '&lt;div&gt;main&lt;/div&gt;'     }     var router = new VueRouter({         routes: [             {                 // url 이름                 path: '/login',                 // 해당 url에서 표시될 컴포넌트                 component: LoginComponent             },             {                 path: '/main',                 component: MainComponent             }         ]     });      new Vue({         el: '#app',         router: router,     }); &lt;/script&gt;   7.4 라우터가 표시되는 영역 및 router-view 태그 설명   페이지 url이 변경 됐을때 그 url에 따라서 뿌려지는 영역을 router-view라는 태그로 정의할 수 있습니다. 뷰 인스턴스에 라우터 인스턴스를 연결해야 사용할 수 있습니다.  router-view를 연결하고 url에 /login을 입력해 보면 login이라는 내용이 화면에 보여집니다.  login이라는 url로 이동했을때 해당하는 컴포넌트를 router-view라는 태그에 보여준 것 입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;div id=\"app\"&gt;     &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var LoginComponent = {         template: '&lt;div&gt;login&lt;/div&gt;'     }     var MainComponent = {         template: '&lt;div&gt;main&lt;/div&gt;'     }     var router = new VueRouter({         routes: [             {                 // url 이름                 path: '/login',                 // 해당 url에서 표시될 컴포넌트                 component: LoginComponent             },             {                 path: '/main',                 component: MainComponent             }         ]     });      new Vue({         el: '#app',         router: router,     }); &lt;/script&gt;   7.5 링크를 이용한 페이지 이동 및 router-link 태그 설명   화면 이동을 url로 할 수 있지만, 사용자 입장에서는 화면에 제공된 링크를 통해 이동합니다.  이럴때 사용하는 것이 router-link입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 &lt;div id=\"app\"&gt;     &lt;div&gt;         &lt;router-link to=\"/login\"&gt;Login&lt;/router-link&gt;         &lt;router-link to=\"/main\"&gt;Main&lt;/router-link&gt;             &lt;/div&gt;     &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  &lt;script&gt;     var LoginComponent = {         template: '&lt;div&gt;login&lt;/div&gt;'     }     var MainComponent = {         template: '&lt;div&gt;main&lt;/div&gt;'     }     var router = new VueRouter({         // 페이지의 라우팅 정보         routes: [             {                 // 페이지의 url 이름                 path: '/login',                 // 해당 url에서 표시될 컴포넌트                 component: LoginComponent             },             {                 path: '/main',                 component: MainComponent             }         ]     });      new Vue({         el: '#app',         router: router     }); &lt;/script&gt;   7.6 라우터 정리 및 학습 방향 안내   라우터는 페이지를 이동할때 사용하는 라이브러리입니다.   CDN 방식  1 &lt;script src=\"https://unpkg.com/vue-router@3.5.3/dist/vue-router.js\"&gt;&lt;/script&gt;  NPM 방식  1 npm install vue-router   뷰 라우터 등록  뷰 라우터를 설치하고 나면 라우터 인스턴스를 생성하고, 인스턴스에 라우터 인스턴스를 등록합니다.  1 2 3 4 5 6 7 8 9 // 라우터 인스턴스 생성 var router = new VueRouter({     // 라우터 옵션 })  // 인스턴스에 라우터 인스턴스 등록 new Vue ({     router: router })   라우터 옵션  routes : 페이지의 정보들이 들어가는 속성 / component는 무조건 하나이기 때문에 s가 붙지 않음 (덧붙여서 인스턴스나 컴포넌트는 여러개가 들어가기때문에 component에 s가 붙음)   뷰 라우터로 특정 URL에 접근할 때 접근을 막는 방법(ex.로그인 전에는 접근 불가하게..)     네비게이션 가드 참고 링크  ","categories": ["vue-lv1"],
        "tags": ["vue","router"],
        "url": "/vue-lv1/vue-beginner7/",
        "teaser": null
      },{
        "title": "8 - HTTP 통신 라이브러리 axios",
        "excerpt":"8.1 HTTP 라이브러리와 Ajax 그리고 Vue Resource   axios는 vue에서 권고하는 HTTP통신 라이브러리 입니다.   Ajax는 비동기 적인 웹애플리케이션의 제작을 위한 기술입니다.  과거에는 서버에 데이터를 요청하면 서버에서 페이지까지 그려서 사용자의 브라우저로 보냈기 때문에 페이지가 깜박거리고 다시 로딩되는 현상이 있었습니다.   하지만 요즘엔 서버에서 데이터만 보내주고 화면에 그리는건 브라우저에서 하기 때문에 데이터가 바뀐 부분만 화면이 바뀌게 되어서 사용자 경험이 훨씬 좋아졌습니다.      원래 vue.js에서 확인할 수 있는 공식 라이브러리로 vue-resource가 있었는데 vue.js를 만든 Evan You가 이제 더이상 공식 라이브러리로 관리 하지 않겠다고 했습니다.  실제로 구현 하다 보면 샘플들이 있을텐데 이 샘플들이 vue-resource로 되어있는 것들이 많을것입니다.  그 샘플들을 오래 됐을 확률이 크기 때문에 그런 부분들을 인지하고 주의해서 구현하는 것이 좋습니다.    axios에 대해 살펴 보겠습니다.   8.2 axios 소개 및 오픈 소스를 사용하기 전에 알아야 할 것들   뷰에서 권고하는 HTTP통신 라이브러리는 Axios입니다. Promise기반의 HTTP통신 라이브러리이며 상대적으로 다른 HTTP통신 라이브러리들에 비해 문서화가 잘되어 있고 API가 다양합니다.   axios github을 검색하여 들어가봅시다.   오픈소스를 사용할때는 제일 먼저 봐야하는것이 Star수를 확인해야 합니다. 그만큼 많은 사람들이 이걸 확인하고 좋아요를 눌렀다는 의미입니다.  대중적인 인지도를 파악하고나면 두번째로 commits기록과 contriutors 숫자를 확인하는것도 중요합니다.  몇명의 사람들이 이 라이브러리를 수정하고 개선하기 위해 동참하고 있는지, 얼마나 많이 업데이트 되어 왔는지를 확인 할 수 있습니다.  마지막으로 각 폴더와 파일이름 옆에 커밋 이력을 보시면 이 라이브러리가 언제 수정되었는지 커밋 이력들을 통해서 이 라이브러리가 활성화 되어있는지 확인하시면 됩니다.      axio의 특징을 볼텐데 Promise based HTTP client for the browser and node.js라고 쓰여 있습니다.  프로미스란 자바스크립트의 비동기 처리 패턴을 의미합니다.   자바스크립트의 비동기 처리 패턴     callback   promise   promise + generator   async  &amp; await   자바스크립트 비동기 처리와 콜백 함수  자바스크립트 promise 이해하기  자바스크립트 async와 await   이 화면을 내려보시면 실제로 axios가 어떤 브라우저에서 호환이 되는지, 예제, 각각의 api에 대한 설명등이 자세하게 되어있습니다.  이런 부분들 때문에 axios를 사용하는 것이 편합니다.   8.3 axios 실습 및 this 설명   axios를 샘플로 돌려보고 어떤식으로 네트워크요청에 대해서 확인하고 데이터를 뿌리는지 살펴보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             getData: function() {                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response);                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   axios는 CDN으로 연결하였습니다.(github 페이지에서 하단에 installing에 cdn 확인 가능)  여기서 제일 중요한것은 버튼을 클릭했을때 getData라는 메서드를 호출하는 것입니다. 메서드의 axios.get에서 참고하는 url로 이동해보면 사용자정보가 담긴 배열을 볼 수 있습니다.      jsonplaceholder라는 것은 REST API 라는 자바스크립트로 api를 요청할때 테스트해볼 수 있는 사이트입니다.  url로 이동했을때 확인 할 수 있는 데이터는 테스트하면서 기능 구현을 해볼 수 있는 샘플이라고 보면 됩니다.   10개의 유저정보를 받아와서 버튼을 눌렀을때 성공하면 then으로 진입하고 실패하면 catch로 진입합니다.   브라우저 콘솔창에서 확인해보도록 하겠습니다.  get user 버튼을 클릭하면 데이터를 받아옵니다. 서버로 요청이 가고 돌아온 응답입니다.  이중에 가장 필요한 부분은 data라는 속성에 들어있는 사용자 정보입니다.      따라서 data만 콘솔창에 찍어보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             getData: function() {                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response);                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   다시 버튼을 클릭해보면 data가 배열로 넘어옵니다.      받아온 data를 div에 뿌려보겠습니다.  그러려면 data라는 속성을 선언하고 users라는 속성에 빈배열을 넣어줍니다.  그리고 this.users = response.data;를 통해서 받아온 data를 users속성에 넣어줍니다.  여기서 확인할것은 this.users가 과연 data안의 users를 말하는가입니다.  페이지로 돌아가서 확인해봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;      &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     this.users = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;      Root컴포넌트에 users데이터가 빈배열로 들어가있고 버튼을 누르면 콘솔창에 10개의 사용자 정보가 찍히지만 users는 계속 빈배열입니다.   this.users의 this는 axios.get()을 호출하기 전의 this와 다릅니다.   1 2 3 4 5 6 7     getData: function() {         this //1번 this         axios.get(url)             .then(function(response) {                 this.users = response.data; //2번 this             })     }   즉, getData() 에서 바로 호출된 1번 this와 axios.get()이 호출된 후 then 메서드에 의해 비동기적으로 실행된 this는 서로 다른것을 가리킵니다.   getData()의 1번 this는 new Vue()로 생성된 인스턴스 Root컴포넌트를 바라보고, axios.get()으로 호출된 callback function안에서의 2번 this는 비동기적으로 실행되면서 실행컨텍스트가 바뀌어 this가 가리키는 대상도 바뀝니다.   click이벤트로 호출되는 함수도 콜백함수(비동기적으로 실행)이지만 이때는 클릭한 대상(해당 컴포넌트)을 실행컨텍스트의 this에 담아가는 반면, axios.get()처럼 비동기적으로 데이터를 받아온후 콜백함수로 실행되는 function은 해당 function을 실행시킨 주체를 따로 담을게 없어서 window(전역객체)를 실행컨텍스트의 this에 담습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;      &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 console.log(this); //1번 this                 axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     console.log(this) // 2번 this                     this.users = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   1번 this와 2번 this를 구분해서 콘솔로 찍어서 확인해봅시다.      각각 vue 컴포넌트와 window를 가져오는 것을 볼 수 있습니다.   이에 대한 해결책으로 변수에 this를 먼저 담고, 그 변수를 전달하는 것입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;      &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 // vue 인스턴스를 가리키는 this                 var vm = this;                                  axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     vm = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   화살표함수를 사용하면 변수를 따로 지정하는 대신에 바로 this로 연결 할 수 있습니다.   받아온 사용자 정보를 div에 뿌려보도록 하겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"getData\"&gt;get user&lt;/button&gt;     &lt;div&gt;              &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             users: []         },         methods: {             getData: function() {                 // vue 인스턴스를 가리키는 this                 var vm = this;                                  axios.get('https://jsonplaceholder.typicode.com/users')                 .then(function (response) {                     console.log(response.data);                     vm = response.data;                 })                 .catch(function (error) {                     console.log(error);                 })             }         }     }) &lt;/script&gt;   8.4 웹 서비스에서의 클라이언트와 서버와의 HTTP 통신 구조      브라우저와 서버의 관계를 살펴보겠습니다.  브라우저에서 HTTP(클라이언트와 서버간의 데이터를 주고받기위한 규칙) 요청을 서버로 보냅니다.  axios.get(‘url’)로 요청을 보냈습니다. 그러면 서버에서는 브라우저로 사용자 데이터를 보냅니다.  이렇게 요청을 보내고 받는것이 HTTP라고 보면 됩니다.   브라우저에서 서버가 어떤식으로 HTTP를 주고받는지 보겠습니다.  브라우저가 서버에 요청을 보냅니다. 그랬을때 서버의 로직을 통해서 DB의 값을 꺼내옵니다.  그 결과물이 서버에서 브라우저로 응답으로 돌아갑니다.      8.5 크롬 개발자 도구 네트워크 패널 보는 방법   크롬 개발자 도구에서 네트워크 패널이 있습니다.    All, XHR, JS, CSS … 등이 있는데 XHR을 통해 비동기 통신에 대해 볼 수 있습니다.  여기에서 get user 버튼을 누르면 HTTP Request가 서버로 날라갑니다.      users를 클릭하면 어떤요청이 서버로 갔고 어떤 응답이 왔는지에 대한 정보들이 뜹니다.  이 패널을 자세히 보면 버그를 잡는데 수월합니다.      첫번째로 Headers엔 General, Response Header, Request Header가 있습니다.  HTTP Header를 의미하는데 여기에는 특정 요청에 대한 정보나 응답에 대한 정보가 담겨있습니다.   General을 보면 Request URL과 Request Method를 보실 수 있습니다. url로 get 요청을 보냈다는 것을 알 수 있습니다.  그리고 status 200을 보면 정상적으로 응답을 받았다는 것을 알 수 있습니다.      Response Headers는 서버에서 어떤 응답을 줬는지에 대한 정보를 담고있습니다.   캐싱이나 etag 등 여러가지 정보들을 담고있습니다.      Request Headers는 브라우저 정보들부터 시작해서 현재 브라우저가 받아줄 수 있는 format이나(Accept) 부가적인 정보들이 들어있고, User Agent는 현재 브라우저에 대한 정보입니다.   axios.get()의 get은 정보를 달라는 요청이기 때문에 Response에는 항상 그 정보가 담겨있습니다.  Preview로 보면 어떤식으로 정보가 담겨 오는지 보기 편합니다.      ","categories": ["vue-lv1"],
        "tags": ["vue","axios"],
        "url": "/vue-lv1/vue-beginner8/",
        "teaser": null
      },{
        "title": "9 - 템플릿 문법 : 기본",
        "excerpt":"9.1 템플릿 문법 소개   뷰의 템플릿 문법이란 뷰로 화면을 조작하는 방법을 의미합니다. 데이터 바인딩과 디렉티브로 나뉩니다.   데이터 바인딩   데이터 바인딩은 뷰 인스턴스에서 정의한 속성들을 화면에 표시하는 방법.  가장 기본적인 방법으로 콧수염 괄호 Mustache Tag 입니다.   1 &lt;div&gt;&lt;/div&gt;   1 2 3 4 5 new Vue({     data: {         message: 'Hello Vue.js'     } })   div태그에 콧수염 괄호를 이용해 뷰 인스턴스의 message 속성을 연결했습니다. 코드를 실행하면 화면에 Hello Vue.js가 출력 됩니다.   디렉티브   뷰로 화면의 요소를 더 쉽게 조작하기 위한 문법입니다.  화면의 조작에서 자주 사용되는 방식들을 모아 디렉티브 형태로 제공하고있습니다. 예를 들어 아래와 같이 특정 속성 값에 때라 화면의 영역을 표시하거나 표시하지 않을 수 있습니다.   1 2 3 &lt;div&gt;     Hello &lt;span v-if=\"show\"&gt;Vue.js&lt;/span&gt; &lt;/div&gt;   1 2 3 4 5 new Vue({     data: {         show: false     } })   위의 코드는 show가 false이기 때문에 Vus.js가 보이지 않습니다.   9.2 데이터 바인딩과 computed 속성   데이터 바인딩에 대해 알아보겠습니다.   html파일을 만들고 기본 코드를 작성하고 인스턴스를 생성하여 el: ‘#app’으로 연결해 줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;div id=\"app\"&gt;      &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             str: 'hi'         }     }) &lt;/script&gt;   브라우저에서 확인해 봅시다.      hi가 찍히는것을 볼 수 있고 data의 str값을 바꾸면 화면에도 바로 반영 되는 것을 확인 할 수 있습니다.      이 값이 연결 되는 구간이 데이터 바인딩이라고 보면 됩니다.   이번에는 num을 넣어서 만들어 보겠습니다.  p태그에 num을 넣고 두번째로 doubleNum을 넣습니다.  num을 정의하고 그 값에 두배를 곱해서 doubleNum을 만들수도 있지만 데이터의 값에 따라서 바뀌는 값을 정의할때 computed를 이용할 수 있습니다.  computed에 doubleNum을 정의하고 this.num(data에 선언했던 num) * 2 를 return합니다.  화면상에 나타나는 doubleNum은 computed속성이고 num이 바뀌었을때 같이 바뀌게 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &lt;div id=\"app\"&gt;     &lt;p&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;   화면에서 확인해보면 num에 10, doubleNum에 20이 들어가 있습니다.      이상태에서 num의 값을 바꾸면 doubleNum의 값도 같이 계산되어서 바뀝니다.      9.3 뷰 디렉티브와 v-bind   뷰 디렉티브에 대해서 보겠습니다. 뷰 디렉티브는 v-가 붙는 특수한 속성들을 말합니다.  첫번째 p태그에 아이디를 id=”abc1234”로 부여하고 데이터로 관리하고 싶을때 인스턴스에 uuid: ‘abc1234’로 정의하고 v-bind로 태그에 연결 할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;div id=\"app\"&gt;     &lt;p v-bind:id=\"uuid\" v-bind:class=\"name\"&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,             uuid: 'abc1234',             name: 'text-blue'         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;        Root에 uuid가 정의 되어있고 p태그에 id가 부여된것을 볼 수 있습니다.   9.4 클래스 바인딩, v-if, v-show   동일한 방법으로 class도 연결할 수 있습니다.   또 유용한 디렉티브들을 확인해 보겠습니다.  v-if를 이용해 로그인 여부에 따라 보이는 태그를 만들어 봅시다.   처음에는 loading이 true라서 Loading…태그가 보이고 loading의 체크박스를 해제해서 false로 만들면 v-else의 태그가 보이게 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 &lt;div id=\"app\"&gt;     &lt;p v-bind:id=\"uuid\" v-bind:class=\"name\"&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt;     &lt;div v-if=\"loading\"&gt;         Loading...     &lt;/div&gt;     &lt;div v-else&gt;         test user has been logged in     &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,             uuid: 'abc1234',             name: 'text-blue',             loading: true,         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;        다음으로 v-show를 보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 &lt;div id=\"app\"&gt;     &lt;p v-bind:id=\"uuid\" v-bind:class=\"name\"&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt;     &lt;div v-if=\"loading\"&gt;         Loading...     &lt;/div&gt;     &lt;div v-else&gt;         test user has been logged in     &lt;/div&gt;     &lt;div v-show=\"loading\"&gt;         Loading...     &lt;/div&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,             uuid: 'abc1234',             name: 'text-blue',             loading: true,         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;   if와 show둘다 loading이 true인 상태에서는 보여집니다.      체크를 풀어서 false가 되면 보이지 않는데 여기서 요소검사를 해보면,      v-if는 v-if속성이 선언된 div태그를 DOM에서 제거해버리고 v-show는 css적으로 display:none으로 육안상 보이지않게만 합니다.   9.5 모르는 문법이 나왔을 때 공식 문서를 보고 해결하는 방법   인풋 박스를 만들고 입력된 값을 p태그에 출력해봅시다.   먼저 인풋 박스를 만들고 그 밑에 p태그를 만듭니다. 일반적으로 document.querySelector로 input에 접근했었습니다.  그러나 이번에는 Vue에서 제공하는 방법을 이용해 보겠습니다.  인풋에 입력하는 내용을 아래 p태그에 써주고 싶지만 그 기능을 모르는 상황일때는 Vue.js 공식문서에서 찾아볼 수 있습니다.      여기서 form input binding으로 가봅시다.  v-model이라는 것을 알려줍니다. 조금 더 내려보면 예시 코드가 있습니다.      input에 v-model로 message를 넣었고 콧수염괄호로 message를 뿌리는 걸로 봐서는 data라는 것을 추측할 수 있습니다. v-model에 message라는 것을 정의 할 수 있게 data에 message 속성을 빈문자열로 추가하고 input에 v-model로 message를 연결해 줍니다.   그리고 이것을 화면에 바로 보일 수 있도록 p태그에 콧수염 괄호로 넣어줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;div id=\"app\"&gt;     &lt;p v-bind:id=\"uuid\" v-bind:class=\"name\"&gt;&lt;/p&gt;     &lt;p&gt;&lt;/p&gt;     &lt;div v-if=\"loading\"&gt;         Loading...     &lt;/div&gt;     &lt;div v-else&gt;         test user has been logged in     &lt;/div&gt;     &lt;div v-show=\"loading\"&gt;         Loading...     &lt;/div&gt;     &lt;input type=\"text\" v-model=\"message\"&gt;     &lt;p&gt;&lt;/p&gt; &lt;/div&gt;  &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,             uuid: 'abc1234',             name: 'text-blue',             loading: true,             message: '',         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         }     }) &lt;/script&gt;   9.6 methods 속성과 v-on 디렉티브를 이용한 키보드, 마우스 이벤트 처리 방법   메서드와 메서드를 이용한 이벤트 핸들링에 대해 알아보겠습니다.   버튼을 만들고 버튼을 클릭했을때 이벤트를 처리하는것을 보겠습니다.  v-on:click=”메서드이름” 버튼을 클릭하면 메서드이름이 실행됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"logText\"&gt;click me&lt;/button&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             logText: function() {                 console.log('clicked');             }         }     }) &lt;/script&gt;   화면에서 확인하고 버튼을 클릭하면 콘솔창에 clicked가 찍힙니다.      여기에서 추가로 인풋을 넣고 인풋에서 키보드 입력으로 이벤트를 실행해보겠습니다.  v-on:keyup=\"메서드이름\" keyup은 키보드가 눌렸다가 올라오면 메서드가 실행됩니다.  v-on:keyup.enter=\"메서드이름\" 으로 엔터를 눌렀을때 메서드를 실행 시킬 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;div id=\"app\"&gt;     &lt;button v-on:click=\"logText\"&gt;click me&lt;/button&gt;     &lt;input type=\"text\" v-on:keyup.enter=\"logText\"&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         methods: {             logText: function() {                 console.log('clicked');             }         }     }) &lt;/script&gt;  ","categories": ["vue-lv1"],
        "tags": ["vue","template syntax"],
        "url": "/vue-lv1/vue-beginner9/",
        "teaser": null
      },{
        "title": "github.io 블로그 minimal-mistake 사이드 카테고리 만들기",
        "excerpt":"사이드바 카테고리 만들기   왼쪽 사이드바 카테고리 만드는 방법   1) 카테고리 모아두기     pages폴더안에 categories폴더 생성후 category-css, category-javascript 등 카테고리 별로 파일을 생성   title, permalink, 하단 assign posts 수정   archive-single.html에서 카테고리, 태그를 모으는 역할을 하지만 커스텀을 위해 archive-single2.html를 따로 만듦      2) 사이드바로 띄우기     _include폴더에 nav_list_main만들기(확장자 없이)   ul 복사해서 category명과 href경로와 제목 수정  ","categories": ["blog"],
        "tags": ["Jekyll","category","sidebar"],
        "url": "/blog/category/",
        "teaser": null
      },{
        "title": "github.io 블로그 시작하기",
        "excerpt":"jekyll 블로그 시작   무료 Jekyll theme 중 가장 많이 사용되고 있는 “minimal-mistakes”를 사용해서 만들기   디자인도 깔끔하고 제작자가 꾸준히 업데이트를 하고있으며, 많이 사용되고 있는 만큼 참고할 자료도 많을 것으로 보인다.   이글의 제목은 github.io 블로그 시작하기 이고, 오늘은 2021-12-03이다. 앞으로 공부하면서 계속해서 정리해서 올려봐야겠다.   ","categories": ["blog"],
        "tags": ["Jekyll","theme"],
        "url": "/blog/firstpost/",
        "teaser": null
      },{
        "title": "마크다운 문법",
        "excerpt":"마크다운 문법에 대하여   제목을 쓸 때는 #을 이용     #h1  ##h2  ###h3  ####h4  #####h5  ######h6    강조는 각각 &lt;em&gt;, &lt;strong&gt;, &lt;del&gt; 사용   html 태그표현  예)     ```html     &lt;div&gt;   &lt;p&gt;Hello, JEKYLL!&lt;/p&gt;  &lt;/div&gt;    ```    결과)          1 2 3 &lt;div&gt;  &lt;p&gt;Hello, JEKYLL!&lt;/p&gt; &lt;/div&gt;   별표시  예)  1 \\*별표이지, 강조가 아닙니다\\*   결과) *별표이지, 강조가 아닙니다*       변수 입력은 `$var = “JEKYLL”;` 이렇게 합니다.    변수 입력은 $var = \"JEKYLL\"; 이렇게 합니다.     자바스크립트          1 2 3 4 function syntaxHighlight(code, lang) {    var foo = 'hi';    var bar = 1234; }    링크  1 2 3 4 5 6 7 8 9 10 11 12 13 14 [GOOGLE](https://google.com) [NAVER](https://naver.com \"title을 입력해주세요\")  문서안에서 [참조링크]를 그대로 사용 할 수 있습니다. [네이버][naver link] [GitHub][github]  [naver link]: https://naver.com [github]: https://github.com [참조링크]: https://google.com \"google로 이동합니다\"  문서 내 꺽쇠 괄호(&lt; &gt;)안의 URL은 자동으로 링크를 사용합니다. 구글 홈페이지: https://google.com 네이버 홈페이지: &lt;https://naver.com&gt;  GOOGLE  NAVER   문서안에서 참조링크를 그대로 사용 할 수 있습니다.  네이버  GitHub   문서 내 꺽쇠 괄호(&lt; &gt;)안의 URL은 자동으로 링크를 사용합니다.   네이버 홈페이지: https://naver.com     이미지  링크와 비슷한데 앞에 !가 붙습니다.  1 2 3 ![logo](/assets/images/logo2.png \"logo 이미지\") 이미지에 링크 추가 [![naver_logo](/assets/images/naver_logo.png)](https://naver.com \"naver로 이동\")    이미지에 링크 추가       코드 강조  숫자 1번키 옆에 `로 감싸주세요.  1 `code`를 강조 할 수 있습니다.  code를 강조 할 수 있습니다.    인용문  1 2 3 4 5 6 7 8 인용문(blockQuote) &gt; 남의 말이나 글에서 직접 또는 간접으로 따온 문장  &gt; 인용문 작성 &gt;&gt; 중첩된 인용문도 만들 수 있다. &gt;&gt;&gt; 중첩1 &gt;&gt;&gt; 중첩2 &gt;&gt;&gt; 중첩3  인용문(blockQuote)     남의 말이나 글에서 직접 또는 간접으로 따온 문장       인용문 작성         중첩된 인용문도 만들 수 있다.             중첩1  중첩2  중첩3            ","categories": ["blog"],
        "tags": ["markdown"],
        "url": "/blog/md/",
        "teaser": null
      },{
        "title": "GitHub 글 쓰기",
        "excerpt":"GitHub 블로그 글 등록하기   첫 글을 등록해보자.   지킬은 정해진 포맷에 맞춰 글을 등록해야 하는데, _posts폴더에 md확장자로 등록한다.   처음에는 _posts폴더가 없으므로 만들어야 한다. _posts폴더를 생성한후 파일명의 형식은 year-month-day-제목.md 로 파일을 생성한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ---  title: \"github.io 블로그 시작하기\"  excerpt: \"GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.\"  last_modified_at: 2021-12-03 categories:      - Blog  tags:      - Jekyll     - theme      - Blog  ---  ## jekyll 블로그 시작   테마는 가장 많이 사용되고 있는 \"minimal-mistakes\"를 사용  디자인도 깔끔하고 제작자가 꾸준히 업데이트를 하고있으며,  많이 사용되고 있는 만큼 참고할 자료도 많을 것으로 보인다.  이글의 제목은 GitHub 글 쓰기 이고, 오늘은 2021-12-03이다. 앞으로 공부하면서 계속해서 정리해서 올려봐야겠다.   이런 형식으로 올리면   이렇게 등록이 된 것을 확인 할 수 있다.   ","categories": ["blog"],
        "tags": ["post"],
        "url": "/blog/post/",
        "teaser": null
      },{
        "title": "공부할 것 들",
        "excerpt":"공부해야 할 것들      vue2   vue3   webpack   vite   javascript   typescript   functional programming   jest (or mocha) test code   vite: 웹팩을 대체하는 속도 빠른 번들링툴 (요즘 뜨는 툴)   제스트: 태스트 코드 작성할때 사용하는 라이브러리  ","categories": ["etc"],
        "tags": ["study","skill"],
        "url": "/etc/study/",
        "teaser": null
      },{
        "title": "10 - 템플릿 문법 : 실전",
        "excerpt":"10.1 watch 속성   인스턴스를 생성하고 num속성을 추가합니다.  이 num을 button을 클릭했을때 1씩 증가 시켜보겠습니다.   메서드에 addNum을 정의하고 버튼에 v-on:click으로 연결해줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &lt;div id=\"app\"&gt;          &lt;button v-on:click=\"addNum\"&gt;increase&lt;/button&gt; &lt;/div&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,         },         methods: {             addNum: function() {                 this.num = this.num + 1;             }         }     }) &lt;/script&gt;   화면에서 버튼을 누르면 누를때마다 숫자가 증가합니다.  여기에 추가로 증가할때마다 콘솔을 찍어보겠습니다.  그러면 data의 변화에 따라서 특정 로직을 실행하는 watch를 이용해보겠습니다.  메서드에 logText를 추가해주고 이것을 watch에 num이 변화했을때 logText를 실행하도록 연결해줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 &lt;div id=\"app\"&gt;          &lt;button v-on:click=\"addNum\"&gt;increase&lt;/button&gt; &lt;/div&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10,         },         watch: {             num: function() {                 this.logText();                }         },         methods: {             addNum: function() {                 this.num = this.num + 1;             },             logText: function() {                 console.log('changed');             }         }     }) &lt;/script&gt;   화면에서 확인해보면 버튼을 누를때마다 콘솔창이 찍힙니다.      10.2 watch 속성 vs computed 속성   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &lt;div id=\"app\"&gt;      &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt;     new Vue({         el: '#app',         data: {             num: 10         },         computed: {             doubleNum: function() {                 return this.num * 2;             }         },         watch: {             num: function(newValue) {                 this.fetchUserByNumber(newValue);             }         },         methods: {             fetchUserByNumber: function(num) {                 console.log(num);             }         }     }) &lt;/script&gt;      data의 num에 10이라는 값이 할당되어 있습니다.   computed에는 doubleNum이라는 함수가 정의되어 있고, 이 함수는 data의 num이라는 속성에 두배의 값을 return합니다.  자연스럽게 vue 내부적으로 계속 계산을 하는 속성이라고 생각하면 됩니다.  기본적으로 data의 의존성(위 doubleNum로직이 실행될 때, 기준이 되는 값이 data의 num값)을 가지고 이 값이 변할 때 마다 computed의 doubleNum이 실행되고 계산됩니다.   watch는 computed와 굉장히 비슷한 느낌인데 watch의 경우도 data의 num이 바뀌었을 때 특정 로직을 실행하기 때문에 computed와 차이가 없어 보입니다.   computed  computed같은 경우는 단순한 값에 대한 계산, 특히 validation vue라이브러리가 있는데 그 내부적으로 구현되어 있는 것들이 computed 속성으로 되어있습니다.  단순한 텍스트 입력을 받아서 거기에 대한 값을 계산하는 것은 computed를 많이 사용합니다.   watch  watch같은 경우는 실제로 무거운 로직들, 매번 실행되기엔 부담스러운 로직입니다.  예를 들어서 data의 num값이 수정되었을 때 this.fetchUserByNumber()가 실행되도록 했는데 브라우저에서 num 값을 증가 시키면 콘솔창에 11이 찍힙니다.      이 부분이 watch에 설정한 함수입니다.   watch의 함수들은 기본적으로 두가지 인자를 받습니다.     첫번째 newValue : 갱신된 값   두번째 oldValue : 이전값      watch는 계속 값의 변화를 추적하고 있기 때문에 이전값과 갱신된 값을 인자로 받습니다.   그래서 새로 갱신된 값을 fetchUserByNumber의 인자로 넘기고 이 함수에서 인자값을 받아서 콘솔에 찍은겁니다.   공식문서 결론      공식문서에서도 웬만하면 computed를 사용하고 watch보다는 computed가 대부분의 케이스에 적합하다고 되어있습니다.  실제로 서비스를 구현할때도 computed로 충분히 가능한데 watch를 사용하면 코드가 지저분해지고 computed가 이미 캐싱이나 이런 내부적인 튜닝이 많이 되어있기때문에 computed를 통해서 값들을 계산하는 것을 추천드립니다.   10.3 computed 속성을 이용한 클래스 코드 작성 방법   computed를 이용한 직관적인 코드 작성과 클래스 바인딩에 대해 알아보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt;     &lt;style&gt;         .warning {             color: red;         }     &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id=\"app\"&gt;         &lt;p v-bind:class=\"errorTextColor\"&gt;Hello&lt;/p&gt;     &lt;/div&gt;     &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt;     &lt;script&gt;         new Vue({             el: '#app',             data: {                 // cname: 'blue-text',                 isError: false             },             computed: {                 errorTextColor: function() {                     return this.isError ? 'warning' : null                 }             }         })     &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;   이렇게 코드를 작성하면 템플릿상에서 { warning: isError }를 넣을 필요 없이 인스턴스안에 깔끔하게 정리 할 수 있습니다.   ","categories": ["vue-lv1"],
        "tags": ["vue","template syntax"],
        "url": "/vue-lv1/vue-beginner10/",
        "teaser": null
      },{
        "title": "11 - 프로젝트 생성 도구 Vue CLI",
        "excerpt":"11.1 최신 Vue CLI 소개   구글에서 vue cli를 검색하면 공식사이트로 들어갈 수 있습니다.   Vue CLI 공식 사이트 링크   CLI란 명령어를 통한 특정 액션을 실행하는 도구입니다.   Get Started를 누르고    Installation을 클릭하고 조금만 내리면 실행 명령어가 보입니다. 이 실행명령어를 이용해서 설치를 진행 할 것입니다.     그 전에 확인 해야 할 것이, 지금까지 vscode에서 live server를 통해서 코드를 브라우저에서 확인했는데 앞으로는 터미널을 이용하겠습니다.   우선 vscode에서 터미널 창을 켜고      node -v 명령어로 노드버전을 확인합니다. 10.대 이상 LTS버전으로 설치해주세요. 두번째로 npm -v 로 npm 버전도 확인하세요. 6.대 버전 이상이면 됩니다.   Vue CLI 공식 사이트에서 확인한 npm install -g @vue/cli 명령어로 Vue CLI를 설치합니다.  (강의에서는 3.x 버전을 설치 하였는데 현재는 5.x 버전)   11.2 Vue CLI 도구 설치할 때 문제점 해결 방법   npm 명령어로 CLI를 설치 중에 에러가 발생하는 경우가 있을것입니다. 이 에러 케이스에 대해서 얘기해보면, 대부분 permision 에러가 뜰것입니다.  이 에러는 npm install로 설치할때 라이브러리가 위치하는 폴더에 쓰기 권한이 없어서 그렇습니다.  이럴때는 sudo를 앞에 붙여서 sudo npm install -g @vue/cli로 설치해주시면 됩니다.      mac과 window의 설치 루트는 위와 같습니다.   11.3 CLI 2.x와 3.x의 차이점 / 프로젝트 생성 및 서버 실행   CLI의 버전 차이에 대해서 알아보겠습니다.   프로젝트를 생성할때  [Vue CLI 2.x]의 경우  vue init ‘프로젝트 템플릿 유형’ ‘프로젝트 폴더 위치’  vue init webpack-simple ‘프로젝트 폴더 위치’   [Vue CLI 3.x]의 경우  vue create ‘프로젝트 폴더 위치’   이런 명령어의 차이가 있습니다.   프로젝트를 생성 해보겠습니다.   vue creat vue-cli로 생성 해봅시다.      여기에서 Vue 2를 선택해주세요.      use yarn / use npm 선택이 나오는데 편한 명령어를 선택하시면 됩니다. 생성이 완료 되면 cd vue-cli로 폴더 이동해서 yarn serve (또는 npm run serve)로 서버를 실행합니다.      실행하면 포트번호 8080으로 로컬서버로 접근 할 수 있게 됩니다.   url로 이동해서 브라우저에서 화면을 확인해 보면 아래와 같은 화면을 확인 할 수 있습니다.      11.4 CLI로 생성한 프로젝트 폴더 구조 확인 및 main.js 파일 설명   vue create명령어로 생성된 vue-cli폴더를 들어가봅시다.  npm run serve 또는 yarn serve는 package.json 파일의 serve에 정의된 명령어를 실행 합니다.   index.html  이때 실행되는 파일은 public 폴더의 index.html를 살펴봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &lt;!DOCTYPE html&gt; &lt;html lang=\"\"&gt;   &lt;head&gt;     &lt;meta charset=\"utf-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;     &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt;     &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;noscript&gt;       &lt;strong&gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;     &lt;/noscript&gt;     &lt;div id=\"app\"&gt;&lt;/div&gt;     &lt;!-- built files will be auto injected --&gt;   &lt;/body&gt; &lt;/html&gt;   이 파일 안에는 app이라는 id를 가진 태그가 있는데, 그 아래의 주석은 빌드된 파일들이 자동으로 추가된다라는 의미입니다.      src폴더 밑에 정의해 놓은 main.js, App.vue등 여러 파일들을 합쳐서 최소한의 파일로 변환해서 추가해 주는 것입니다.(이것을 webpack이 해줌)   main.js   main.js 파일을 살펴봅시다.   1 2 3 4 5 6 7 8 import Vue from 'vue' import App from './App.vue'  Vue.config.productionTip = false  new Vue({   render: h =&gt; h(App), }).$mount('#app')   여기에서 new Vue({...}).$mount('#app')를 다시 써보면  기존에 하던 인스턴스 생성 코드와 동일합니다.   1 2 3 4 5 6 new Vue({ }).$mount('#app')  new Vue({ \tel: '#app', })   여기에서 다시 작성 해보겠습니다.  기존의 코드에서 render만 추가된 형태입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 import Vue from 'vue' import App from './App.vue'  Vue.config.productionTip = false  new Vue({   render: h =&gt; h(App), }).$mount('#app')  new Vue({     el: '#app',     render: h=&gt; h(App), })   render의 역할은 App이라는 컴포넌트, 즉 위의 import한 파일을 불러와서 집어넣고 랜더링 했다고 이해하시면 될 것 같습니다.   App이라는 컴포넌트를 살펴보겠습니다.  import App from './App.vue 코드 대신에 아래와 같이 작성 해 봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import Vue from 'vue' // import App from './App.vue'  Vue.config.productionTip = false  var App = {     template: '&lt;div&gt;app&lt;/div&gt;' }  new Vue({   render: h =&gt; h(App),   components: { // components의 역할과 render 역할이 동일       'app': App   } }).$mount('#app')   위 코드는 지금까지 기초 공부를 하면서 많이 봤던 코드입니다.  변수 App을 정의하고 인스턴스에 components속성에 정의 했었습니다.  components와 render의 역할이 동일합니다.   11.5 싱글 파일 컴포넌트 소개 및 여태까지 배운 내용 적용하는 방법   .vue로 파일을 생성해봅니다.  vue파일에서 vue를 입력하고 엔터를 치면 싱글 파일 컴포넌트 코드가 자동완성 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;template&gt; &lt;!-- html --&gt; &lt;/template&gt;  &lt;script&gt; export default { // javascript } &lt;/script&gt;  &lt;style&gt; /* css */ &lt;/style&gt;   이전에 배웠던 방식으로 코드를 보면  1 2 3 4 5 6 7 8 var appHeader = {   template: '&lt;div&gt;header&lt;/div&gt;',   methods: {     addNum: function() {      }   } }   여기에서 template의 &lt;div&gt;headet&lt;/div&gt;가 &lt;template&gt;안에 들어가게 되고,  methods는 &lt;script&gt;안에 위치하게 됩니다.  인스턴스 옵션이 들어가는 겁니다.   11.6 App.vue와 HelloWorld.vue 설명   App.vue를 살펴보면 &lt;HelloWordl&gt;로 컴포넌트를 등록했습니다.  1 2 3 4 5 components: {     HelloWorld,     'hello-world': HelloWorld,       // 위 두개는 같은 의미입니다.     }   컴포넌트 내용을 들고와서 components에 등록해서 사용하는 것을 확인 할 수 있습니다.   ","categories": ["vue-lv1"],
        "tags": ["vue","cli"],
        "url": "/vue-lv1/vue-beginner11/",
        "teaser": null
      },{
        "title": "12 - 싱글 파일 컴포넌트",
        "excerpt":"12.1 싱글 파일 컴포넌트에 배운 내용 적용하여 개발 시작하기   cli로 생성한 프로젝트에서 어떤식으로 개발을 시작해야 하는지 살펴보겠습니다.   파일을 정리해보겠습니다.  우선 HelloWorld.vue를 삭제합니다.   App.vue도 전체를 지우고 저장한 후에 vue를 입력해서 자동완성을 합니다.  template에서 div태그를 만들어줍니다.  여기서 주의할 점은 가장 상위 태그는 하나여야한다는 것입니다.   1 2 3 4 5 6 7 8 &lt;template&gt;     &lt;div&gt;          &lt;/div&gt;     &lt;div&gt;          &lt;/div&gt; &lt;/template&gt;   이런식으로 최상단에 태그가 여러개가 나열되면 에러가 뜹니다.   1 2 3 4 5 6 7 8 9 10 &lt;template&gt;     &lt;div&gt;         &lt;div&gt;                  &lt;/div&gt;         &lt;div&gt;                  &lt;/div&gt;     &lt;/div&gt; &lt;/template&gt;   이렇게 최상단에는 하나의 태그로 묶어주고 그 안에서 여러개의 태그를 넣어야 합니다. template안에 Root는 한개 요소여야합니다.   div안에 app이라고 입력하고 화면을 확인해봅시다.      화면에서 app이 뜨는것을 볼 수 있고 vue의 Root에 컴포넌트가 뜹니다.   이번에는 app대신 hi라는 텍스트를 vue data에서 정의를 하고 데이터 바인딩으로 엮어보겠습니다.      script부분에 data:{}를 입력하면 빨간줄이 가는것이 보입니다.  여태까지는 new Vue({})안에 data를 선언해서 했는데 cli를 통해서 .vue파일에서는 여러개의 컴포넌트에서 동일한 값을 참조하면 안됩니다.   1 2 3 4 5 6 7 export default {     data: function() {         return {             str: 'hi'         }     } }   이렇게 함수를 연결하고 return을 새객체를 반환해주는 형식으로 사용해야합니다.   12.2 싱글 파일 컴포넌트 체계에서 컴포넌트 등록하기   App.vue파일에서 별도의 컴포넌트를 등록해서 그 컴포넌트로 하위 컴포넌트의 props와 event를 주고받아보겠습니다.  src 폴더밑에 components안에 AppHeader.vue를 생성합니다.   AppHeader.vue에 코드를 작성합니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;template&gt;     &lt;header&gt;         &lt;h1&gt;Header&lt;/h1&gt;     &lt;/header&gt; &lt;/template&gt;  &lt;script&gt; export default {      }; &lt;/script&gt;  &lt;style lang=\"scss\" scoped&gt;  &lt;/style&gt;   그리고 App.vue로 돌아와서 컴포넌트를 등록해봅시다.  script 안에 import를 이용해서 불러옵니다.   컴포넌트를 등록할때는 components로 등록합니다.  등록한 컴포넌트는 template안에서 불러옵니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 &lt;template&gt;   &lt;div&gt;     &lt;app-header&gt;&lt;/app-header&gt;   &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; import AppHeader from './components/AppHeader.vue' // new Vue({ //   data: { //     str: 'hi' //   } // })  export default {   data: function() {     return {       str: 'hi'     };   },   components: {     'app-header': AppHeader   } }; &lt;/script&gt;  &lt;style lang=\"scss\" scoped&gt;  &lt;/style&gt;   12.2 싱글 파일 컴포넌트에서 props 속성 사용하는 방법  ","categories": ["vue-lv1"],
        "tags": ["vue","component"],
        "url": "/vue-lv1/vue-beginner12/",
        "teaser": null
      },{
        "title": "인스턴스",
        "excerpt":"인스턴스란?   인스턴스는 클래스나 프로토타입을 사용해 만든다. 즉, 프로퍼티와 메서드를 상속 받는다.   원래의 객체가 가지고 있던 것을 동일하게 사용하면서, 거기에 확장시켜 추가된 개별속성을 가질 수 있다.   예를 들어, “모자”라는 객체의 인스턴스로 “모자1”을 생성했을때 “모자1”은 “파란 모자”가 될 수 있다.   1 2 3 4 5     cap = function(color){         this.color = color;     };     let cap1 = new cap(blue);     let cap2 = new cap(black);   ✅ 추가 설명 떡볶이 레시피를 가지고 떡볶이를 먹으려면 “떡볶이”를 만들어야 한다.  어제 “떡볶이”를 만들고, 오늘 또 “떡볶이”를 만들었다고 가정 했을때 만들어진 “떡볶이”는 [인스턴스]가 된다. 여기서 두개의 떡볶이는 같은 레시피를 보고 만들었지만 동일한 대상은 아니다.   ","categories": ["javascript"],
        "tags": ["instance","primitive"],
        "url": "/javascript/instance/",
        "teaser": null
      },{
        "title": "맥북 키보드에서 원화 표시 기호(₩) 대신 백쿼트(`) 표시되게 하기",
        "excerpt":"맥북 키보드 설정 팁      맥북에서 한글 입력상태에서 백쿼트를 사용하려면 option + ₩(백쿼트) 키를 눌러야한다.  매번 이렇게 입력하려니 불편해서 설정해 두는 방법을 찾아보았다.   맥북에서 터미널 창을 열어준다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Library에 KeyBindings 폴더 생성 cd ~/Library mkdir KeyBindings  // KeyBindings로 들어가서 DefaultkeyBinding.dict 파일 생성 cd KeyBindings touch DefaultkeyBinding.dict  // Vim(Text Editor)로 파일 열고 i(입력) 전환 vi DefaultkeyBinding i  // 아래의 { ~ }코드를 복사해서 {     \"₩\" = (\"insertText:\", \"`\"); }  // esc + :wq :wq   이렇게 입력하고 재부팅해주면 한글 입력상태에서 백쿼트 사용이 된다.   *** 원래의 상태로 돌아가려면 rm DefaultkeyBinding.dict  ","categories": ["tips"],
        "tags": ["mac","keyboard"],
        "url": "/tips/mac-keybinding/",
        "teaser": null
      },{
        "title": "github jekyll blog codeblock에 line number 추가하기",
        "excerpt":"코드블럭에 line number 추가를 해봅시다.   마크다운에서 코드블럭을 삽입하려면 역따옴표를 세번 넣어서 사용합니다.  코드블럭으로 코드를 삽입하고 좀 더 보기 쉽게 line number를 추가 하고 싶을때 어떻게 할까?   _config.yml 파일을 열고 kramdown을 검색합니다.   kramdown:      highlighter: rouge      syntax_highlighter_opts:          block:              line_numbers: true   위 코드를 추가 합니다.      _config.yml 파일은 수정후 자동 반영이 안되므로 서버를 내렸다가 다시 동작하여야 반영이 됩니다.   ","categories": ["blog"],
        "tags": ["codeblock","custom"],
        "url": "/blog/codeblock-line-number/",
        "teaser": null
      },{
        "title": "1 - Todo App - 프로젝트 소개 및 구성",
        "excerpt":"개발환경 설정 및 깃헙 리포지토리 클론      vscode 설치    플러그인 설치 vetur, 'tslint(문법오류나 api쫓아가기 유용함)   node.js   Vue.js devtools   git   1.1 뷰 CLI로 프로젝트 생성하기   1 2 3 npm i -g @vue/cli # or yarn global add @vue/cli  cli를 설치하고 vue create 프로젝트이름 명령어를 사용한다.  vue2를 선택하고 세팅하도록 하겠다.      프로젝트가 생성되고 나면 생성한 폴더 안으로 cd 폴더명으로 이동해서 npm run serve or yarn serve로 로컬서버로 실행해서 브라우저에서 확인할 수 있습니다.   App.vue 파일을 살펴보면 HelloWorld라는 컴포넌트를 import를 통해서 가져오는 것을 볼 수 있습니다.   1.2 프로젝트 소 및 컴포넌트 설계 방법   Todo App을 만들어 볼 계획입니다.   구성은 Root 밑에 4개의 컴포넌트로 구성 되어있습니다.      TodoHeader : 앱의 타이틀이 들어간 컴포넌트   TodoInput : 할 일을 입력하는 입력창이 있는 컴포넌트   TodoList : 입력한 내용을 리스트로 뿌려주고 각 리스트를 삭제하고, 체크 기능이 들어간 컴포넌트   TodoFooter : 전체 리스트를 다 없애주는 버튼이 들어가있는 컴포넌트   간단한 예제이지만 event올리기, props 내리기 같은 데이터 통신에 대해 다루고 있기 때문에 공부하기 좋은 예제입니다.   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate1/",
        "teaser": null
      },{
        "title": "2 - Todo App - 프로젝트 구현",
        "excerpt":"2.1 컴포넌트 생성 및 등록하기   컴포넌트를 설계에 맞게 생성하겠습니다.   components 폴더 안에 TodoHeader.vue, TodoInput.vue, TodoList.vue, TodoFooter.vue 파일을 만들고 자동완성으로 기본태그 입력하고 각 파일 template의 div태그 안에 구분해줄 단어들을 아래 예시처럼 입력해서 저장합니다.   1 2 3 4 5 6 7 8 9 10 11 &lt;template&gt;     &lt;div&gt;         Header     &lt;/div&gt; &lt;/template&gt; ... &lt;template&gt;     &lt;div&gt;         Input     &lt;/div&gt; &lt;/template&gt;   App.vue 파일을 열고 필요없는 내용을 다 지워서 정리해줍니다.  그리고 생성한 컴포넌트들을 import로 가져와서 연결하고 template에 넣어줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 &lt;template&gt;   &lt;div id=\"app\"&gt;     &lt;TodoHeader&gt;&lt;/TodoHeader&gt;     &lt;TodoInput&gt;&lt;/TodoInput&gt;     &lt;TodoList&gt;&lt;/TodoList&gt;     &lt;TodoFooter&gt;&lt;/TodoFooter&gt;   &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; import TodoHeader from './components/TodoHeader.vue' import TodoInput from './components/TodoInput.vue' import TodoList from './components/TodoList.vue' import TodoFooter from './components/TodoFooter.vue'  export default {   components: {     'TodoHeader': TodoHeader,     'TodoInput': TodoInput,     'TodoList': TodoList,     'TodoFooter': TodoFooter,   } } &lt;/script&gt;      2.2 파비콘, 아이콘, 폰트, 반응형 태그 설정하기   모바일 웹에서도 잘 보이도록 반응형 태그를 추가하고 아이콘이나 파비콘을 추가하겠습니다.   크롬창에서 meta viewport를 검색해서 복사해서 public 폴더안에 index.html meta태그 영역에 붙여넣습니다.  다음으로 파비콘도 추가합니다. 크롬에서 favicon generator 사이트에서 원하는 이미지로 파비콘을 생성하면 링크도 같이 생성 되니 그걸 복붙하면 됩니다.  (cli로 생성시 자동으로 들어가있어서 따로 추가 할 필요 없는듯)   마지막으로 awesome아이콘을 추가합니다.   폰트어썸 업데이트하면서 부터인지 vue에서 사용하려면 메일로 무료키트 사용 링크를 받아야한다.  fontawsome.com/start로 접속 &gt; 이메일 입력 &gt; 확인, 설정 버튼 클릭 &gt; 폰트어썸 로그인 후 무료키트 링크 카피해서 index.html 헤드에 추가      구글 폰트도 미리 설정하겠습니다.   크롬에서 google font를 검색해서 접속한 후 ubuntu를 검색합니다.  원하는 weight를 선택해서 생성된 링크를 index.html에 추가합니다.      1 2 3 4 5 6 7 8  &lt;head&gt;     &lt;meta charset=\"utf-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;     &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt;     &lt;link href=\"https://fonts.googleapis.com/css2?family=Ubuntu&amp;display=swap\" rel=\"stylesheet\"&gt;     &lt;title&gt;To do App&lt;/title&gt;   &lt;/head&gt;   2.3 TodoHeader 컴포넌트 구현   header는 header태그 안에 h1태그를 이용해서 정체성을 나타내겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 &lt;template&gt;     &lt;header&gt;         &lt;h1&gt;To Do it!&lt;/h1&gt;     &lt;/header&gt; &lt;/template&gt;  &lt;script&gt; export default { }; &lt;/script&gt;  &lt;style scoped&gt; h1 {     color: #2f3b52;     font-weight: 900;     margin: 2.5rem 0 1.5rem; } &lt;/style&gt;   App.vue에도 스타일을 넣어줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 body {   text-align: center;   background-color: #F6F6F8; } input {   border-style: groove;   width: 200px; } button {   border-style: groove; } .shadow {   box-shadow: 5px 10px 10px rgba(0, 0, 0, 0.03) }   2.4 TodoInput 컴포넌트의 할 일 저장 기능 구현   두번째 컴포넌트를 작성하겠습니다.   인풋박스를 만들어서 텍스트를 입력하면 그 값을 로컬스토리지에 저장합니다.  우선 인풋박스를 만들어 줍시다. 여기에 입력된 값을 스크립트에서 인식하려면 v-model이라는 디렉티브를 사용합니다.  v-model의 역할을 인풋에 입력된 텍스트 값을 동적으로 바로 뷰 인스턴스 안에 매핑을 합니다.  v-mode을 사용하는 방법은 data에 newTodoItem이라고 이름 지어주고 v-model에 연결해줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &lt;template&gt;     &lt;div&gt;         &lt;input type=\"text\" v-model=\"newTodoItem\"&gt;     &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; export default {     data: function() {         return {             newTodoItem: \"\"         }     } }; &lt;/script&gt;   이렇게 연결하고 화면에서 어떻게 반영되는지 보면, TodoInput컴포넌트 data쪽에 newTodoItem이 생기고 인풋박스에 텍스트를 입력하면 newTodoItem의 내용도 바뀌는 것을 볼 수 있습니다.    이어서 v-model에 있는 값을 들고와야합니다.  아래에 버튼을 만들고 v-on:click으로 클릭했을때 동작할 메서드명을 넣어주고 script에 메서드를 정의해줍니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 &lt;template&gt;     &lt;div&gt;         &lt;input type=\"text\" v-model=\"newTodoItem\"&gt;         &lt;button v-on:click=\"addTodo\"&gt;add&lt;/button&gt;     &lt;/div&gt; &lt;/template&gt;  &lt;script&gt; export default {     data: function() {         return {             newTodoItem: \"\"         }     },     methods: {         addTodo: function() {             console.log(this.newTodoItem)         }     } }; &lt;/script&gt;   여기서 this는 TodoInput컴포넌트를 가리키고 그 안의 newTodoItem을 가져옵니다.  화면에서 인풋에 텍스트를 입력하고 add버튼을 눌러보면, 콘솔창에 입력값을 가져와서 출력하는 것을 볼 수 있습니다.      여기서 한가지 기능을 추가해서 버튼을 클릭하면 인풋박스를 비우도록 해봅시다.   1 2 3 4 addTodo: function() {     console.log(this.newTodoItem);     this.newTodoItem = ''; }      addTodo메서드 저장하는 로직 추가   localStorage.setItem(‘key’, ‘value’)로 추가            diff check            2.5 TodoInput 컴포넌트 코드 정리 및 UI스타일링      this.clearInput(); // 같은 인스턴스안에 있는 메서드라서 this로 접근 가능            diff check            2.6 TodoInput 컴포넌트의 할 일 목록 표시 기능 구현      created(인스턴스가 생성되자마자 호출되는 라이프사이클 훅), mounted, update, destroy   for문으로 localStorage를 가져옴            diff check            2.7 TodoList 컴포넌트 할 일 삭제 기능 구현      localStorage.removeItem(todoItem); // key랑 value를 똑같이 넣어놔서 todoItem으로 지우면 됨   this.todoItems.splice(index, 1); // localStorage를 지우고 배열도 지워줘야 브라우저에 반영됨 splice -&gt; index번째에서 1개 지움            diff check            2.8 TodoList 컴포넌트의 할 일 완료 기능 구현      var obj = {completed: false, item: this.newTodoItem}; // item : text값, completed : boolean값을 넣어서 객체에 저장   obj를 stringify 않고 넣으면 할일을 추가했을때 localStorage에서 확인하면 key에는 잘 들어가는데 value에 [object Object]로 들어가서 객체 안에 어떤값이 들어있는지 확인 불가능   stringify : 객체를 string으로 변환해서 넣기때문에 객체 안에 어떤값이 있는지 확인 가능   v-bind:class=”{checkBtnCompleted: todoItem.completed}” -&gt; v-bind로 엮어서 class값을 동적으로 바꿔줌   todoList에 뿌릴떄는 TodoInput에서 stringify로 변환해서 넣은 값을 다시 객체로 변환(JSON.parse)해서 가져옴            diff check            2.9 TodoFooter 컴포넌트 구현      localStorage.clear(); // localStorage 지우는 api            diff check           ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate2/",
        "teaser": null
      },{
        "title": "3 - Todo App - 애플리케이션 구조 개선하기",
        "excerpt":"3.1 현재 앱 구조의 문제점 진단 및 개선된 앱 구조 소개      localStorage.clear();            localStorage 지우는 api           이렇게 작성하면(삭제 뿐만 아니라 todoInput쪽 할일 추가 부분도) localStorage에서는 지워지지만(추가되지만 브라우저는 새로고침해야 반영) TodoList컴포넌트와 분리되어 있기 때문에 list에는 영향이 없다.   그래서 하위 컴포넌트(todoFooter, todoInput)에서는 event로 상위(App)에 보내고 상위에서는 해당 내용을 props로 내려줍니다.      diff check    3.2 [리팩토링] 할 일 목록 표시 기능   App.vue     하위로 props 내리기            v-bind:내려보낼 프롭스 속성 이름=”현재위치의 컴포넌트 데이터 속성”           TodoList.vue     props: [‘propsdata’],   App.vue에서 v-bind:propsdata=”todoItems”로 내려준 프롭스 속성 이름 propsdata      diff check    3.3 [리팩토링] 할 일 추가 기능   App.vue     하위에서 올린 이벤트버스 받기            v-on:하위 컴포넌트에서 발생시킨 이벤트 이름=”현재 컴포넌트의 메서드 명”           하위 TodoInput에서 추가 버튼 addTodo메서드가 실행되면 $emit으로 App.vue로 addTodoItem을 올려 주고 인자로 this.newTodoItem을 보낸다. 그러면 App.vue에서는 addTodoItem에 연결된 현재 컴포넌트의 메서드 addOneItem을 실행한다.   TodoInput에서 newTodoItem을 인자로 받아왔으니 여기에도 todoItem으로 인자를 넣어줌   TodoInput.vue     this.$emit(‘이벤트이름’, 인자1, 인자2 …)   addTodo가 실행되면 addTodoItem을 발생시켜서 상위 컴포넌트로 올려준다.      diff check    3.4 [리팩토링] 할 일 삭제 기능   App.vue     localStorage.removeItem(todoItem.item);            removeItem(todoItem); 으로 삭제하면 객체를 지우는거라서 localStorage에서 삭제가 안됨 todoItem.item으로 삭제해줘야 함           TodoList.vue     removeItem을 실행해서 todoItem, index 인자를 보낸다.      diff check    3.5 [리팩토링] 할 일 완료 기능   App.vue     localStorage.removeItem(todoItem.item);            removeItem(todoItem); 으로 삭제하면 객체를 지우는거라서 localStorage에서 삭제가 안됨 todoItem.item으로 삭제해줘야 함           기존 complete toggle시키는 부분 문제점   todoItem.completed = !todoItem.completed;            todoItems라는 배열을 todoList에 propsdata가 props로 내려가서 props로 받아서 그걸로 접근하는 형태인데, 여기서 이벤트버스로 todoItem을 넘겨줬음. 즉, props에서 접근된 데이터를 다시 위로 올림, 다시 올려서 바꾸는 것은 좋지 않은 패턴(안티패턴), 이것보다는 App.vue라는 파일이 컨테이너의 성격을 가지고 있기 때문에 todoItems에 접근해서 조작하는 것이 좋음       this.todoItems[index].completed = !this.todoItems[index].completed;              diff check    3.6 [리팩토링] 할 일 모두 삭제 기능   App.vue     v-on:clearAll=”clearAllItems”   this.todoItems = [] -&gt; 빈배열로 만들어서 브라우저에서도 삭제되도록      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate3/",
        "teaser": null
      },{
        "title": "4 - Todo App - 사용자 경험 개선",
        "excerpt":"4.1 모달 컴포넌트 등록   TodoInput.vue     vuejs.org 공식 사이트 Learn &gt; examples에서 Modal Component 참고   components: ModalBox: ModalBox      diff check    4.2 모달 컴포넌트의 slot 소개   TodoInput.vue     slot : 특정 컴포넌트의 일부 ui들을 재사용 할 수 있음   ModalBox.vue에서 default로 넣어둔 부분을 여기에서 커스텀 할 수 있음      diff check    4.3 slot 및 모달 컴포넌트 기능 구현   TodoInput.vue     v-on:click=”” -&gt; 축약형 @click=””      diff check    4.4 트랜지션 소개 및 구현      vuejs.org 공식문서 사이트엣 Transition Animation &gt; List Transition 참고   v-enter : 처음 active가 시작됐을때   v-enter-to : 시작되고 끝날때 상태   v-leave : 이펙트가 나오기 직전   v-leave-to : 이펙트가 끝난 시점   일반적으로 v-enter-to와 v-leave 같이 쓰고, v-enter와 v-leave-to 같이 씀      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate4/",
        "teaser": null
      },{
        "title": "5 - ES6 for Vue.js - const & let",
        "excerpt":"ES6 배경과 Babel 소개   es6(ECMAScript 2015)     2015년은 ES5(2009년)이래로 진행한 첫 메이저 업데이트가 승인된 해   최신 Front-End Framework인 React, Angular, Vue에서 권고하는 언어 형식   ES5에 비해 문법이 간결해져서 익숙해지면 코딩을 훨씬 편하게 할 수 있음   Babel     구 버전 브라우저 중에서는 ES6의 기능을 지원하지 않는 브라우저가 있으므로 tranpiling이 필요   ES6의 문법을 각 브라우저의 호환 가능한 ES5로 변환하는 컴파일러   5.1 const &amp; let 소개      블록 단위 {} 로 변수의 범위 제한   const : 한번 선언한 값에 대해서 변경 불가능(상수개념)   let : 한번 선언한 값에 대해서 다시 선언할 수 없음   5.2 [ES5의 주요 특징]변수 스코프와 호이스팅   변수의 Scope     기존의 ES5는 {}에 상관없이 스코프가 설정됨   1 2 3 4 5 6 var sum = 0; for (var i = 1; i &lt;= 5; i++) {     sum = sum + i; } console.log(sum); // 15 console.log(i) // 6   for문을 벗어나도 i에 접근이 가능   Hoisting     함수나 변수를 해석기가 가장 상단으로 끌어올림   js 해석기는 코드의 라인 순서와 관계 없이 함수선언식과 변수를 위한 메모리 공간을 먼저 확보한다.   함수표현문과 const, let 은 호이스팅이 일어나지 않는다.   5.3 const와 let 추가 설명 및 정리      {}단위로 변수의 범위가 제한   1 2 3 4 5 6 let sum = 0; for (let i = 1; i &lt;= 5; i++) {     sum = sum + i; } console.log(sum); // 15 console.log(i) // Uncaught ReferenceError: i is not defined   for문이 끝나면 i에 접근 불가      const로 지정한 값 변경 불가능   객체나 배열의 내부는 변경할 수 있다.   1 2 3 4 5 6 7 const a = {}; a.num = 10; console.log(a); // {num:10}  const b = []; b.push(20); console.log(b); // [20]   5.4 [리팩토링] const와 let      var -&gt; const, let으로 변환      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate5/",
        "teaser": null
      },{
        "title": "6 - ES6 for Vue.js - 화살표 함수",
        "excerpt":"6.1 화살표 함수 소개 및 설명      함수를 정의할 때 function이라는 키워드를 사용하지 않고 =&gt; 로 대체   흔히 사용하는 콜백 함수의 문법을 간결화   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // ES5 함수 정의 방식 var sum = function(a, b) {     return a + b; };   // ES6 함수 정의 방식 var sum = (a, b) =&gt; {     return a + b; }  sum(10, 20);  // ES5 var arr = [\"a\", \"b\", \"c\"]; arr.forEach(function(value) {     console.log(value); // a, b, c });  // ES6 var arr = [\"a\", \"b\", \"c\"]; arr.forEach(value =&gt; console,log(value)); // a, b, c   Babel 온라인 에디터 링크  ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate6/",
        "teaser": null
      },{
        "title": "7 - ES6 for Vue.js - Enhanced Object Literals",
        "excerpt":"7.1 속성 메서드의 축약 특징 설명   향상된 객체 리터럴     객체의 속성을 메서드로 사용할 때 function 예약어를 생략 가능   1 2 3 4 5 6 7 8 9 10 11 var dictionary = {     words: 100,     // ES5     lookup: function() {         console.log(\"find words\");     },     // ES6     lookup() {         console.log(\"finde words\");     } }   7.2 [리팩토링] 속성 메서드의 축약 특징 리팩토링      diff check    7.3 속성명의 축약 특징 설명      객체의 속성명과 값 명이 동일할 떄 아래와 같이 축약 가능   1 2 3 4 5 var figures = 10; var dictionary = {     // figures: figures,     figures }   7.4 [리팩토링] 속성명의 축약 특징 리팩토링      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate7/",
        "teaser": null
      },{
        "title": "8 - ES6 for Vue.js - Modules",
        "excerpt":"8.1 Modules   자바스크립트 모듈화 방법     자바스크립트 모듈 로더 라이브러리(AMD, Commons JS)기능을 js 언어 자체에서 지원   호출되기 전까지는 코드 실행과 동작을 하지 않는 특징이 있음   1 2 3 4 5 6 7 8 9 // libs/math.js export function sum(x, y) {     return x + y; } export var pi = 3.141593;  // main.js import { sum } from 'libs/math.js'; sum(1, 2);   자바스크립트는 모듈화 방법이 없었기 때문에 모듈 로더 라이브러리를 사용함   모듈 : 특정기능을 수행하는 한 단위, 묶음 모듈화 이유 : 재사용성이 뛰어난 기능을 묶어서 다시 가져다 쓰기 위해서   Vue.js에서 가장 많이 보이는 export default   1 2 3 4 5 6 7 8 9 10 11 12 13 14 // util.js export default function(x) {     return console.log(x); }  // main.js import util from 'util.js'; console.log(util); // function (x) { return console.log(x); } util('hi');  // app.js import log from 'util.js'; console.log(log); log('hi');  ","categories": ["vue-lv2"],
        "tags": ["vue"],
        "url": "/vue-lv2/vue-intermediate8/",
        "teaser": null
      },{
        "title": "9 - Vuex - 소개",
        "excerpt":"9.1 Vuex 소개   Vuex - 상태 관리 라이브러리      복잡한 애플리케이션의 컴포넌트들을 효율적으로 관리하는 Vuex라이브러리 소개   Vuex 라이브러리의 등장 배경인 Flux 패턴 소개   Vuex 라입러리의 주요 속성인 state, getters, mutations, actions 학습   Vuex를 더 쉽게 코딩할 수 있는 방법인 Helper 기능 소개   Vuex로 프로젝트를 구조화하는 방법과 모듈 구조화 방법 소개   React에서는 Flux 패턴으로 복잡한 앱에서 야기되는 관리 문제점을 해결 하고 있어서 Vuex에 도입했다.   9.2 Flux와 MVC 패턴 소개 및 Flux 등장 배경   Vuex란?     복잡하고 많은 컴포넌트의 데이터를 관리하기 위한 상태 관리 패턴이자 라이브러리   React의 Flux패턴에서 기인   Flux란?     MVC패턴의 복잡한 데이터 흐름 문제(페이스북같이 복잡한 컴포넌트에서 하나의 데이터가 바뀌었을때 다른 컴포넌트에서 추적하기가 어려움)를 해결하는 개발 패턴   Action -&gt; Dispatcher -&gt; Model -&gt; View  Action에서 View까지 항상 한방향으로 흐름(unidirectional data flow)      action : 화면에서 발생하는 이벤트 또는 사용자의 입력   dispatcher : 데이터를 표시하는 방법, 메서드(모델(data)을 바꾸기 위한 역할)   model : 화면에 표시할 데이터   view : 사용자에게 비춰지는 화면(action을 호출해서 계속해서 단방향으로 이동)   사용자가 화면에서 클릭같은 조작(action)을 하면 메서드가 발생해서 데이터를 변경(dispatcher) 하면 store(model)가 변경이 되고 그것이 화면(view)에 반영이 되고 다시 화면에서 action을 호출함   프롭스가 내려갈것이고 하위에서 올릴때는 이벤트로 올린다 등의 예측이 가능함   +MVC패턴 : Controller -&gt; Model &lt;-&gt; View (양방향)  ㄴ view : 화면 / Model : 데이터 / Controller : view와 model을 제어   9.3 Vuex가 필요한 이유, Vuex 컨셉, Vuex 구조      복잡한 애플리케이션에서 컴포넌트의 개수가 많아지면 컴포넌트 간에 데이터 전달이 어려워진다.   하위에서 루트로 보낼때 이밴트버스로 해결할 수 있지만 어디서 이벤트를 보냈는지 알기 어려움(컴포넌트 간 데이터 전달이 명시적이지 않음)   Vuex로 해결할 수 있는 문제     MVC패턴에서 발생하는 구조적 오류   컴포넌트 간 데이터 전달 명시   여러 개의 컴포넌트에서 같은 데이터를 업데이트 할 때 동기화 문제   Vuex 컨셉     State : 컴포넌트 간에 공유하는 데이터 data() - 데이터프로퍼티라고 보면 됨   View : 데이터를 표시하는 화면 template - template속성   Action : 사용자의 입력에 따라 데이터를 변경하는 methods - 메서드   화면(template)에서 버튼을 클릭하면 버튼은 v-on:click=”addTodo”를 발생시키는데 이게 action, action이 data를 변경하는데 이 data가 state   Vuex 구조  컴포넌트 -&gt; 비동기 로직 -&gt; 동기 로직 -&gt; 상태   컴포넌트에서 비동기로직(actions)에서 처리하고(setTimeout, apiCall등) 데이터는 바꾸지 않고 데이터를 바꿀 수 있는 mutations를 콜하고 mutations(동기 로직)만 state를 바꿈  ","categories": ["vue-lv2"],
        "tags": ["vue","vuex","store"],
        "url": "/vue-lv2/vue-intermediate9/",
        "teaser": null
      },{
        "title": "DOM",
        "excerpt":"DOM 소개   javascript를 공부하면서 DOM을 빼놓고 이야기 할 수 없다.   DOM이란 무엇인가? 그전에 BOM에 대해서 알아보자.      BOM이란 무엇인가?    브라우저를 바탕으로 웹서비스가 실행이 되는데, 이와 관련된 객체들의 집합을 브라우저객체모델(Browser Object Model)이라고 한다.      웹브라우저와 관련된 객체의 집합   window객체가 최상위 객체   웹브라우저가 제공하는 기능      DOM의 정의(MDN참조)    DOM은 Document Object Model의 약자이다.     HTML, XML 문서의 프로그래밍 인터페이스   문서의 구조화된 표현을 제공하고, 프로그래밍 언어가 DOM구조에 접근할 수 있는 방법을 제공해서 문서구조, 스타일, 내용등을 변경할 수 있게 한다.   웹페이지를 스크립트 또는 프로그래밍 언어들에서 사용되도록 연결해준다.   DOM이 무엇인가…     내가 html에 쓴 파일이 DOM은 아니다. 그러나 브라우저에 의해서 파싱이 된다면 DOM이 된다.   view source에서 보이는것도 DOM이 아니다.   dev Tools(개발자 도구)에서 보여주는 것이 DOM이다.   DOM은 웹페이지의 객체 지향 표현이고, 자바스크립트와 같은 스크립트 언어로 DOM을 수정할수 있다.   ","categories": ["javascript"],
        "tags": ["DOM"],
        "url": "/javascript/dom/",
        "teaser": null
      },{
        "title": "10 - Vuex - 주요 기술 요소",
        "excerpt":"10.1 Vuex 설치 및 등록   Vuex 설치하기 vuejs 공식 문서   NPM  1 2 // npm install vuex@next --save // 공식문서에 써있는 걸로 설치하면 Vue3를 기준으로 설치 되므로 코어 라이브러리는 버전을 명시해줘야함 npm i vuex@3.4.0   Yarn  1 2 // yarn add vuex@next --save yarn add vuex@3.4.0 // yarn을 사용하면 yarn으로 설치해야 함   components 폴더랑 같은 레벨에 stor 폴더 만들기      diff check    10.2 state와 getters 소개   Vuexa 기술 요소     state : 여러 컴포넌트에 공유되는 데이터 data   getters : 연산된 state 값을 접근하는 속성 computed   mutations : state 값을 변경하는 이벤트 로직, 메서드 methods   actions : 비동기 처리 로직을 선언하는 메서드 async methods   State란?     여러 컴포넌트 간에 공유할 데이터 - 상태   1 2 3 4 5 6 7 8 9 // vue data: {     message: 'Hello Vue.js' }  // vuex state: {     message: 'Hello vue.js }  1 2 3 4 5 6 7 8  &lt;!-- Vue --&gt; &lt;p&gt;{{ message }}&lt;/p&gt;   &lt;!-- Vuex --&gt; &lt;p&gt;{{ this.$store.state.message }}&lt;/p&gt;    getters란?     state 값을 접근하는 속성이자 computed() 처럼 미리 연산된 값을 접근하는 속성   1 2 3 4 5 6 7 8 9 10 11 12 // store.js state: {     num: 10 }, getters: {     getNumber(state) {         return state.num;     },     doubleNumber(state) {         return state.num * 2;     } }  1 2 3 4  &lt;p&gt;{{ this.$store.getters.getNumber }}&lt;/p&gt; &lt;p&gt;{{ this.$store.getters.doubleNumber }}&lt;/p&gt;    10.3 [리팩토링] state 속성 적용   store.js     const storage 변수를 설정하고 fetch() 함수에 기존 App.vue에서 created로 가져오던 localStorage에 담긴 배열을 뿌려주는 로직을 옮기기   state에서 todoItems: storage.fetch()로 todoItems에 storage변수의 fetch() 함수 연결   TodoList.vue v-for=\"(todoItem, index) in propsdata\" propsdata에서 반복문을 돌리던 것을 v-for=\"(todoItem, index) in this.$store.state.todoItems로 수정      diff check    10.4 mutations와 commit() 형식 소개   mutations란?     state의 값을 변경할 수 있는 유일한 방법이자 메서드   뮤테이션은 commit() 으로 동작시킨다.   1 2 3 4 5 6 7 8 9 10 // store.js state: { num: 10 }, mutations: {     printNumbers(state) {         return state.num     },     sumNumbers(state, anotherNum) {         return state.num + anotherNum;     } }  1 2 this.$store.commit('printNumbers'); this.$store.commit('sumNumbers', 20);   mutations의 commit() 형식     state를 변경하기 위해 mutations를 동작시킬 때 인자(payload)를 전달할 수 있음   1 2 3 4 5 6 7 8 // store.js state: { storeNum: 10 }, mutations: {     modifyState(state, payload) {         console.log(payload.str)         return state.storeNum += payload.num;     } }  1 2 3 4 this.$store.commit('modifyState' {     str: 'passed from payload',     num: 20 });   두번째 인자로 값을 넘길 수 있음, 여러개를 보낼때는 객체형태로 보내면 된다.   10.5 [리팩토링&amp;퀴즈] mutations 적용 및 퀴즈 안내   Store.js     App.vue의 methods에 있던 addOneItem을 store.js의 mutations로 옮기기   addOneItem의 첫번째 인자로 state에 접근하기 위해서 state 넣기   TodoInput.vue에서 입력된 값을 this.newTodoItem에 넣어서 보내는데 이것을 받기 위해서 두번째 인자에 todoItem 넣기   TodoInput.vue     기존에 $emit으로 넘기던 이벤트를 this.$store.commit('addOneItem', this.newTodoItem);로 store의 mutations 동작시킴      diff check    10.6 [리팩토링&amp;퀴즈] mutations 퀴즈 풀이 및 할 일 지우기 기능 구현      removeOneItem은 두번째 인자를 여러개를 받아야해서 객체 형태로 보내기   TodoList.vue에 const obj = {todoItem, index}로 변수에 객체로 넣어주고 store.js에서 두번째 인자로 payload를 넣어주고 안에서 payload.todoItem 으로 접근   매번 객체를 변수에 담아주기가 번거로우니 바로 commit()의 두번째 인자에 this.$store.commit('removeOneItem', {todoItem, index}); 객체를 넣어줌   10.7 [리팩토링] mutations로 할 일 추가, 완료, 모두 삭제 구현      App.vue 필요없는 부분 정리      diff check    10.8 왜 mutations로 상태를 변경해야 하는가?      여러 개의 컴포넌트에서 아래와 같이 state 값을 변경하는 경우 어느 컴포넌트에서 해당 state를 변경했는지 추적하기 어렵다.   1 2 3 methods: {     increaseCounter() { this.$store.state.counter++;} }      특정 시점에 어떤 컴포넌트가 state를 접근하여 변경한 건지 확인하기 어렵기 때문   따라서, 뷰의 반응성을 거스르지 않게 명시적으로 상태 변화를 수행. 반응성, 디버깅, 테스팅 혜택   state는 여러개의 컴포넌트에서 공유하고 있기 때문에 특정 컴포넌트에서 변경했을때 추적을 해야한다. 10개의 컴포넌트에서 변경한다고 했을때 어느시점에 어느 컴포넌트에서 변경했는지 알기가 어려움, mutations를 거쳐야 뷰 개발자 도구에서 추적이 가능하다.(어떻게…?)   10.9 actions 소개 및 예제   actions란?     비동기 처리 로직을 선언하는 메서드, 비동기 로직을 담당하는 mutations   데이터 요청, Promise, ES6 async와 같은 비동기 처리는 모두 actions에 선언      Promise 이해하기 자바스크립트 비동기 처리 이해하기    1 2 3 4 5 6 7 8 9 10 11 12 13 14 // store.js state: {     num: 10 }, mutations: {     doubleNumber(state) {         state.num * 2;     } }, actions: {     delayDoubleNumber(context) { // context로 store의 메서드와 속성 접근         context.commit('doubleNumber');     } }  1 2 // App.vue this.$store.dispatch('delayDoubleNumber');   actions 비동기 코드 예제1   1 2 3 4 5 6 7 8 9 10 11 // store.js mutations: {     addCounter(state) {         state.counter++     }, }, actions: {     delayedAddCounter(context) {         setTimeout(() =&gt; context.commit('addCounter'), 2000);     } }  1 2 3 4 5 6 // App.vue methods: {     incrementCounter() {         this.$store.dispatch('delayedAddCounter');     } }      mutations는 commit이라는 api로 호출하고 actions는 dispatch라는 api로 호출   actions 비동기 코드 예제2   1 2 3 4 5 6 7 8 9 10 11 12 // store.js mutations: {     setData(state, fetchedData) {         state.product = fetchedData     }, }, actions: {     fetchProductData(context) {         return axios.get('https://domain.com/products/1')                     .then(response =&gt; context.commit('setData', response));     } }  1 2 3 4 5 6 // App,vue methods: {     getProduct() {         this.$store.dispatch('fetchProductData');     } }      getProduct()메서드를 실행하면 actions의 fetchProductData를 실행   axios가 get이라는 http 요청을 서버에 보낸다.   받아오면 then이라는 Promise 콜백으로 응답을 받아서 응답을 setData() mutations를 실행해서 응답을 인자로 넘긴다.   mutations에서 state의 product에 접근해 서버에서 받아온 응답값(response)을 fetchedData에 넣어준다.   10.10 왜 actions에 비동기 로직을 선언해야 하는가?      언제 어느 컴포넌트에서 해당 state를 호출하고, 변경했는지 확인하기가 어려움            여러개의 컴포넌트에서 mutations로 시간차를 두고 state를 변경하면 값의 변화를 추적하기 어렵기 때문에 mutations 속성에는 동기 처리 로직만 넣어야 한다.          ","categories": ["vue-lv2"],
        "tags": ["vue","vuex","store"],
        "url": "/vue-lv2/vue-intermediate10/",
        "teaser": null
      },{
        "title": "11 - Vuex - 헬퍼 함수",
        "excerpt":"11.1 헬퍼 함수 및 ES6 Spread 연산자 소개   각 속성들을 더 쉽게 사용하는 방법 - Helper   store에 있는 아래 4가지 속성들을 간편하게 코딩하는 방법     state -&gt; mapState   getters -&gt; mapGetters   mutations -&gt; mapMutations   actions -&gt; mapActions   헬퍼의 사용법     헬퍼를 사용하고자 하는 vue 파일에서 해당 헬퍼를 로딩   1 2 3 4 5 6 7 8 9 10 // App.vue import { mapState } from 'vuex' import { mapGetters } from 'vuex' import { mapMutations } from 'vuex' import { mapActions } from 'vuex'  export default {     computed() { ...mapState(['num']), ...mapGetters(['countedNum']) },     methods: { ...mapMutations(['clickBtn']), ...mapActions(['asyncClickBtn']) } }   11.2 mapState, mapGetters 소개 및 ES6 Spread 연산자 쓰는 이유   mapState     Vuex에 선언한 state 속성을 뷰 컴포넌트에 더 쉽게 연결해주는 헬퍼   1 2 3 4 5 6 7 8 9 10 11 12 // App.vue import { mapState } from 'vuex'  computed() {     ...mapState(['num'])     // num() { return this.$store.state.num; } }  // store.js state: {     num: 10 }  1 2 &lt;!-- &lt;p&gt;{{ this.$store.state.num }}&lt;/p&gt; --&gt; &lt;p&gt;{{ this.num }}&lt;/p&gt;   mapGetters     Vuex에 선언한 getters 속성을 뷰 컴포넌트에 더 쉽게 연결해주는 헬퍼   1 2 3 4 5 6 7 8 9 10 11 12 13 // App.vue import { mapGetters } from 'vuex'  computed() {      ...mapGetters(['reverseMessgae'])  }  // store.js getters: {     reversMessage(state) {         return state.msg.split('').reverse().join('');     } }  1 2 &lt;!-- &lt;p&gt;{{ this.$store.getters.reversMessage }}&lt;/p&gt; --&gt; &lt;p&gt;{{ this.reversMessage }}&lt;/p&gt;   11.3 [리팩토링] getters와 mapGetters 적용하기   store.js     getters에 storedTodoItems변수 지정하고 state의 todoItmes에 접근   TodoList.vue     computed에 todoItmes() 메서드에 this.$store.getters.storedTodoItems; 리턴 시켜주기      diff check       diff check    11.4 mapMutations, mapActions 소개 및 헬퍼의 유연한 문법   mapMutations     Vuex에 선언한 mutations 속성을 뷰 컴포넌트에 더 쉽게 연결해주는 헬퍼   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // App.vue import { mapMutations } from 'vuex'  methods: {     ...mapMutations(['clickBtn']),     authLogin() {},     displayTable() {} }  // store.js mutations: {     clickBtn(state) {         alert(state.msg);     } }  1 &lt;button @click=\"clickBtn\"&gt;popup message&lt;/button&gt;   mapActions     Vuex에 선언한 actions 속성을 뷰 컴포넌트에 더 쉽게 연결해주는 헬퍼   1 2 3 4 5 6 7 8 9 10 11 12 13 // App.vue import { mapActions } from 'vuex'  methods: {     ...mapActions(['delayClickBtn']), }  // store.js actions: {     delayClickBtn(context) {         setTimeout(() =&gt; context.commit('clickBtn'), 2000);     } }  1 &lt;button @click=\"delayClickBtn\"&gt;delay popup message&lt;/button&gt;   헬퍼의 유연한 문법     Vuex에 선언한 속성을 그대로 컴포넌트에 연결하는 문법     1 2 3 4 5 // 배열 리터럴 ...mapMutations([   'clickBtn', // 'clickBtn': clickBtn   'addNumber' // addNumber(인자) ])           Vuex에 선언한 속성을 컴포넌트의 특정 메서드에다가 연결하는 문법     1 2 3 ...mapMutations({   popupMsg: 'clickBtn' // 컴포넌트 메서드 명: Store의 뮤테이션 명 })           11.5 [리팩토링 &amp; 퀴즈] mapMutations 적용 및 퀴즈      헬퍼 함수들은 인자를 선언하지 않아도 함수를 호출하는 시점에 인자를 넘기면 그대로 가져온다.      diff check    11.6 [리팩토링 &amp; 퀴즈] mapMutations 퀴즈 풀이      diff check    11.7 헬퍼 함수가 주는 간편함      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue","vuex","store","helper"],
        "url": "/vue-lv2/vue-intermediate11/",
        "teaser": null
      },{
        "title": "12 - Vuex - 프로젝트 구조화 및 모듈화",
        "excerpt":"12.1 스토어 속성 모듈화 방법   프로젝트 구조화와 모듈화 방법1   아래와 같은 store 구조를 어떻게 모듈화 할 수 있을까?   1 2 3 4 5 6 7 8 9 10 // store.js import Vue from 'vue' import Vuex from 'vuex'  export const store = new Vuex.Store({     state: {},     getters: {},     mutations: {},     actions: {} })   힌트! Vuex.Store({})의 속성을 모듈로 연결 모듈이라고 하면 각각의 속성의 내용들을 별도의 파일로 분리해서 파일들을 불러와서 담아주기      ES6의 Import &amp; Export를 이용하며 속성별로 모듈화   1 2 3 4 5 6 7 8 9 10 11 12 import Vue from 'vue' import Vuex from 'vuex' import * as getters from 'store/getters.js' import * as mutations from 'store/mutations.js' import * as actions from 'store/actions.js'  export const store = new Vuex.Store({     state: {},     getters: getters,     mutations: mutations,     actions: actions })      diff check    12.2 스토어 모듈화 방법   프로젝트 구조화와 모듈화 방법2     앱이 비대해져서 1개의 store로는 관리가 힘들 때 modules 속성 사용   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // store.js import Vue from 'vue' import Vuex from 'vuex' import todo from 'models/todo.js'  export const store = new Vuex.Store({     modules: {         moduleA: todo, // 모듈 명칭 : 모듈 파일명         todo // todo: todo     } });  // todo.js const state = {} const getters = {} const mutations = {} const actions = {}      diff check   ","categories": ["vue-lv2"],
        "tags": ["vue","vuex","store","module"],
        "url": "/vue-lv2/vue-intermediate12/",
        "teaser": null
      },{
        "title": "call/apply/bind 함수의 차이점",
        "excerpt":"call/apply/bind 함수의 차이점은?   예제를 보고 확인해보자.      예)    1 2 3 4 5 6 7     const obj = {name:'maru'};     const live = function(city){         console.log(`Hi my name is ${this.name}, I live in ${city}`);     };     live('korea'); // Hi my name is , I live in korea     live.call(obj, 'korea'); // Hi my name is maru, I live in korea     live.apply(obj, ['korea']); // Hi my name is maru, I live in korea   call과 apply는 함수를 호출하는 함수  첫번째 인자인 “obj”로 this를 변경하고 함수를 실행한다.  (apply는 파라미터를 배열로 넣어야 한다.)      예)    1 2 3 4 5 6     const obj = {name:'maru'};     const live = function(city){         console.log(`Hi my name is ${this.name}, I live in ${city}`);     };     const bound = live.bind(obj)     bound('korea'); // Hi my name is maru, I live in korea   bind함수는 함수를 실행하지 않는다.   ","categories": ["javascript"],
        "tags": ["function","call","apply","bind"],
        "url": "/javascript/call-apply-bind/",
        "teaser": null
      },{
        "title": "api",
        "excerpt":"api에 대해 알아보자   “API(Application Progtamming Interface, 응용프로그램 프로그래밍 인터페이스)는 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.” -위키백과   api는 프로그램이 서로 상호작용하는 것을 도와주는 매개체라고 볼 수 있다.  프로그램이 주문하도록 명령을 정리하고, 그 명령을 받아서 응용프로그램과 상호작용하여 요청된 명령에 대한 값을 전달한다.      서버와 데이터베이스의 출입구 역할을 한다.   애플리케이션과 기기가 원활하게 통신하도록 한다.   모든 접속을 표준화 한다.   개발자들이 어플리케이션 코드 작성을 표준화 해서 빠르고 간단히 프로세스 처리가 가능하다.  또한 개발자들간의 협업도 용이해진다.   즉, api는 어떠한 응용프로그램에서 데이터를 주고받기 위한 방법이다.  특정 사이트에서 데이터를 공유할때 어떤 방식으로 요청해야 하는지, 어떤 데이터를 제공 받을수 있는지에 대한 규격들을 말한다.   ","categories": ["javascript"],
        "tags": ["api"],
        "url": "/javascript/api/",
        "teaser": null
      },{
        "title": "호이스팅(Hoisting)",
        "excerpt":"hoisting에 대해 알아보자      자바스크립트에서 호이스팅(Hoisting)이란, 인터프리터가 변수와 함수의 공간을 선언전에 미리 할당 하는 것을 의미한다.    실행컨텍스트의 처리 순서를 살펴보면,     선언 단계(Declaration phase) : 변수, 함수선언문 설정   초기화 단계(Initialization phase) : 변수 이름 바인딩 (값은 undefined로 초기화)   할당 단계(Assignment phase)   위 순서로 처리가 된다.   이때, let변수는 호이스팅 되지 않는다.(사실상 호이스팅은 되지만 안되는것과 비슷하다.) var 변수는 선언단계와 초기화단계가 동시에 진행되어 변수이름을 바인딩하면서 값이 undefined로 초기화되는 반면,  let 변수는 선언단계와 초기화단계가 따로 진행된다.  그래서 실행컨텍스트에 변수가 등록이 되었지만 메모리가 할당이 되어있지 않기 때문에 ReferenceError가 발생한다.   여기서 TDZ가 무엇인지 알고 가자.  TDZ란 “temporal dead zone” 일시적인 사각지대 라고 직역할 수 있다.  TDZ는 스코프의 시작지점 부터 초기화 단계 직전까지의 구간이다.   즉, let변수는 TDZ구간에 의해 메모리가 할당이 되지 않기 때문에 참조에러(ReferenceError)가 발생한다.      예)    1 2 3 4 5     console.log(`스포츠: ${sports}`); // 스포츠: undefined     var sports = '축구';      console.log(`스포츠: ${sports}`); // ReferenceError: sports is not defined     let sports = '축구';  ","categories": ["javascript"],
        "tags": ["hoisting"],
        "url": "/javascript/hoisting/",
        "teaser": null
      },{
        "title": "REST",
        "excerpt":"REST에 대해 알아보자   REST에 대해 알아보기전에 api에 대해 다시 한번 확인해보자.  api에 대한 포스팅이 따로 있지만 여기에서는 비유를 통해 간단히 설명한다.   좋아하는 드라마의 본방사수를 위해서 집에 서둘러 들어와 티비를 켜고 원하는 채널을 틀어야 하는 상황일때 이러한 과정이 필요하다.  티비 리모컨의 전원 버튼을 눌러 티비를 켜고 채널 버튼을 눌러 원하는 채널로 돌려야 한다.  나 &gt; 리모컨 &gt; 티비 이러한 순서로 볼 수 있다.   즉 API는 리모컨 처럼 애플리케이션과 운영체게 사이의 ‘상호작용’을 돕는다.   웹 API의 역할      권한을 가진 사람만 서버와 데이터베이스안의 리소스에 접근이 가능하게 해준다.   모든 요청(request)와 응답(response)를 표준화 해준다.   REST의 구성요소      자원(Resource) : HTTP UIR 를 통한 자원 명시   자원에 대한 행위(Verb) : HTTP Method(post, get put, delete)   자원에 대한 행위의 내용(Representations) : HTTP Message Pay Load   REST API   REST API란 REST의 원리를 따르는 API를 의미한다. 리소스(HTTP URI)로 어떠한 행위(HTTP Method + Pay Load)를 하겠다는 것을 구조적으로 표현하는 방법이다.   REST API의 설계 가이드를 살펴보자.      URI는 명사, 소문자를 사용한다.   마지막에 슬래시를 포함하지 않는다.   언더바 대신 하이픈을 사용한다.   URI에 파일확장자는 포함하지 않는다.   RESTful 이란?   RESTful이란 REST API의 설계 가이드를 올바르게 지킨 시스템을 RESTful 하다고 말할 수 있다. RESTful하게 만들면 그자체로 API의 목적이 무엇인지 명확하게 알 수 있다.  ","categories": ["javascript"],
        "tags": ["api","REST"],
        "url": "/javascript/rest/",
        "teaser": null
      },{
        "title": "Vue에서 Fontawesome 사용하기",
        "excerpt":"Vue에서 Fontawesome 사용하기   폰트어썸 업데이트하면서 부터인지 vue에서 사용하려면 메일로 무료키트 사용 링크를 받아야한다.  fontawsome.com/start로 접속 &gt; 이메일 입력 &gt; 확인, 설정 버튼 클릭 &gt; 폰트어썸 로그인 후 무료키트 링크 카피해서 index.html 헤드에 추가  ","categories": ["vue-lv2"],
        "tags": ["fontawesome"],
        "url": "/vue-lv2/fontawesome/",
        "teaser": null
      },{
        "title": "git commit 메세지 수정",
        "excerpt":"마지막 commit 메세지 수정하기      git commit –amend -m “바꿀 메세지”  or  git commit –amend  까지 입력후 vi 에서 i(수정모드)로 변경하고 수정 후 esc 누르고 :wq로 저장    이전 commit 메세지 수정하기   rebase 명령어를 사용  rebase 명령어는 branch의 base를 다시 설정하여 master브랜치와 merge commit생성을 방지하여 깔끔한 커밋을 남길 수 있도록 도와주는 명령어      git rebase -i HEAD~3    rebase에서 -i 옵션을 주면 rebase명령을  대화형으로 수행하여 여러 커밋들의 순서를 바꾸거나 커밋 히스토리를 변경 또는 삭제할 때 사용  HEAD~3 은 최근 커밋 메시지중 3개만 불러온다는 뜻   입혁하면 최근 커밋 메시지 3개를 불러오는데      pick 커밋번호 커밋메시지    형식으로 출력   이때 수정하고 싶은 commit 내역의 pick을 reword로 바꾸고 :wq로 저장 종료  종료가 되면 선택한 commit 메시지에 대한 화면이 다시 터미널에 호출  위와 동일하게 vi 에서 i(수정모드)로 변경하고 수정 후 esc 누르고 :wq로 저장   원격에 이미 Push 했을 때   commit이 이미 원격에 push 되었다면 커밋 메시지를 수정하고      git push origin master(혹은 브랜치명) -f    로 강제 덮어씌우기   *** 개인 레포지토리나 개인 브랜치가 아닌 협업 마스터 브랜치에는 위험할 수 있음  ","categories": ["git"],
        "tags": ["commit"],
        "url": "/git/git-commit-edit/",
        "teaser": null
      },{
        "title": "git branch",
        "excerpt":"git branch 생성하고 사용하는 방법      git init : git 저장소 생성(초기화)   git remote add origin {link} : link에 생성한 레포지토리 url복사해서 넣기   git branch : 깃 브랜치 확인   git branch -v : 마지막 커밋메세지 확인   git branch ‘브랜치명’ : 브랜치 생성   git checkout ‘브랜치명’ : 선택한 브랜치로 이동   git branch -d ‘브랜치명’ : 브랜치 삭제하기   git merge ‘합칠 브랜치명’ : 현재위치한 브랜치에 합칠 브랜치에서 작업한 내용 가져와서 병합   git add . : 변경한 파일을 저장   git commit -m “커밋메세지” : 커밋메세지 입력   git push origin ‘브랜치명’ : 원격저장소 브랜치에 push 하기  ","categories": ["git"],
        "tags": ["branch"],
        "url": "/git/gitbranch/",
        "teaser": null
      },{
        "title": "flex에 대해서",
        "excerpt":"flex에 대한 정리   ","categories": ["css"],
        "tags": ["css","flex","grow","shirink"],
        "url": "/css/flex/",
        "teaser": null
      },{
        "title": "상단 박스 height 유동적일때 하단 박스 oveflow scroll 시키기(feat. flex)",
        "excerpt":"상단 컨텐츠의 높이값이 유동적으로 바뀌고 하단 박스만 overflow scroll 하는 법   스크롤시 상단 컨텐츠는 고정, 하단 컨텐츠만 overflow-y: auto 시켜야 하는 레이아웃 구현하기   레이아웃 상세 상단 컨텐츠 : 상단 컨텐츠는 내용에 따라서 height값 유동적  하단 컨텐츠 : 리스트를 보여주며 디바이스에서 상단 컨텐츠 height를 뺀 만큼 보이고 overflow 되는 부분은 scroll   코드 보기           1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;     &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;     &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;style&gt;     * {         margin: 0;         padding: 0;     }     .container {         display: flex;         flex-direction: column;         min-height: 100vh;     }     .topBox {         flex: 0;         background: rgb(174, 101, 177);         color: #fff;         padding: 1.2rem      }     .bottomBox {         position: relative;         flex: 1;     }     .scrollBox {         position: absolute;         left: 0; top: 0; right: 0; bottom: 0;         overflow-y: auto;     }     li {         list-style: none;         width: 100%;         height: 150px;         border-bottom: 1px solid #ddd;         align-items: center;         justify-content: center;         display: flex;     }   &lt;/style&gt; &lt;/head&gt; &lt;body&gt;     &lt;div class=\"container\"&gt;         &lt;div class=\"topBox\"&gt;헤더 자리&lt;/div&gt;             &lt;div class=\"bottomBox\"&gt;                 &lt;div class=\"scrollBox\"&gt;                     &lt;ul&gt;                         &lt;li&gt;&lt;span&gt;리스트1&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트2&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트3&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트4&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트5&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트6&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트7&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트8&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트9&lt;/span&gt;&lt;/li&gt;                         &lt;li&gt;&lt;span&gt;리스트10&lt;/span&gt;&lt;/li&gt;                     &lt;/ul&gt;                 &lt;/div&gt;             &lt;/div&gt;         &lt;/div&gt;     &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;      topBox와 bottomBox를 전체 container박스로 묶는다.   bottomBox안에 리스트 박스를 넣는다.   스타일 적용            전체 박스에 display: flex; flex-direction: column; min-height: 100vh;       topBox에 flex: 0;       bottomBox에 position: relative; flex: 1;       리스트 박스에 position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow-y: auto;           적용 예시)        참고 링크   ","categories": ["css"],
        "tags": ["css","flex","overflow","scroll"],
        "url": "/css/flexbox_scroll/",
        "teaser": null
      },{
        "title": "vuex",
        "excerpt":"vuex 소개      복잡한 애플리케이션의 컴포넌트들을 효율적으로 관리하는 vuex 라이브러리   React의 Flux패턴에서 기인함   vue.js 중고급 개발자로 성장하기 위한 필수 관문   Flux란?      MVC 패턴의 복잡한 데이터 흐름 문제를 해결하는 개발 패턴            action : 화면에서 발생하는 이벤트 또는 사용자의 입력       dispatcher : 데이터를 변경하는 방법, 메서드       model : 화면에 표시할 데이터       view : 사용자에게 비춰지는 화면           MVC패턴과 Flux패턴 비교              view : 보고있는 화면       model : 데이터       controller : model과 view 제어                    Flux패턴은 action에서 view까지 단방향으로 일어남 반면 MVC패턴은 model과 view가 서로 데이터를 주고받아서 양방향으로 일어남                            MVC패턴의 문제점              기능 추가 및 변경에 따라 생기는 문제점을 예측할 수 없음.       앱이 복잡해지면서 생기는 업데이트 루프           Flux패턴의 단방향 흐름              데이터의 흐름이 여러 갈래로 나뉘지 않고 단방향으로만 처리           vuex가 왜 필요할까?   복잡한 애플리케이션에서 컴포넌트의 개수가 많아지면 컴포넌트간에 데이터 전달이 어려워진다.      vuex로 해결할 수 있는 문제            MVC 패턴에서 발생하는 구조적 오류       컴포넌트 간 데이터 전달 명시       여러 개의 컴포넌트에서 같은 데이터를 업데이트 할 때 동기화 문제           이벤트 버스로 해결?  어디서 이벤트를 보냈는지 혹은 어디서 이벤트를 받았는지 알기 어려움  1 2 3 4 5 6 7 8 // Login.vue eventBus.$emit('fetch', loginInfo);  // List.vue eventBus.$on('display', data =&gt; this.displayOnScreen(data));  // Chart.vue eventBus.$emit('refreshData', chartData);  컴포넌트 간 데이터 전달이 명시적이지 않음   vuex 컨셉      State : 컴포넌트 간에 공유하는 데이터 data()   View : 데이터를 표시하는 화면 template   Mutations: state값을 변경하는 이벤트 로직, 메서드 methods   Action : 사용자의 입력에 따라 데이터를 변경하는 (비동기 처리 로직을 선언) aysnc methods   흐름 설명 : 화면(view)에서 버튼을 클릭 하면 버튼이 action을 발생시킴 &gt; action이 발동하면 데이터(state)를 변경   vuex 구조   컴포넌트 -&gt; 비동기 로직 -&gt; 동기 로직 -&gt; 상태   action : 비동기 로직  mutations : 동기 로직   자바스크립트 비동기 처리와 콜백함수 참고 링크  ","categories": ["vue-lv2"],
        "tags": ["vuex","store"],
        "url": "/vue-lv2/vuex/",
        "teaser": null
      },{
        "title": "1 - 소개 및 설계",
        "excerpt":"1.1 소개 및 설계   해커뉴스 사이트 제작  해커뉴스 공식사이트   API를 호출해서 화면에 표시하고 링크 연결하거나 정보등 페이지로 넘어가게 제작 해커뉴스 API 문서   1.2 애플리케이션 라우터 설계   사이트 설계 : 기획서를 토대로 컴포넌트 기반으로 설계를 해야함 news, ask, jobs 라는 리스트를 표시하는 페이지 3개를 라우터로 설계  각 페이지에서 리스트를 클릭했을때 넘어가는 뷰 페이지와 사용자 정보를 보여주는 페이지까지 총 다섯개   1.3 비공개 리포지토리 소개 및 뷰 cli 설명   vue create 프로젝트폴더이름   1.4 Vue CLI 2.x vs Vue CLI 3.x   vue CLI 사이트 webpack-simple 템플릿 깃헙 주소   명령어     2.x : vue init ‘프로젝트 템플릿 이름’ ‘파일위치’ vue init webpack-simple new-project   3.x : vue create ‘프로젝트 이름’ vue create new-project   웹팩 설정 파일     2.x : 노출 O   3.x : 노출 X 웹팩이 복잡하기 때문에 그 설정 파일을 사용자들에게 노출시키지않고 라이브러리 내부에서 알아서 처리하겠다 라는 것.  2점대에서 웹팩에 대한 이해도가 높으면 어떤걸 설정해야될 때, webpack.config.js에 바로 옵션들을 추가하는식으로 했지만,  3점대 이상에서는 웹팩 설정을 추가해야될 때, 별도의 내용들을 추가해야됨. 그 내용들을 vue cli 사이트 가서 webpack을 검색해보면 추가 설정 관련 설명이 나옴     1 2 3 4 5 6 7 8 // vue.config.js module.exports = { configureWebpack: {   plugins: [     new MyAwesomeWebpackPlugin()   ] } }          위와 같이 configureWebpack이라는 설정들을 추가해서 plugins라던지 기타 설정들을 추가할 수 있다.       프로젝트 구성     2.x : 깃헙의 템플릿 다운로드            vuejs-templates       vuejs-templates/webpack-simple 템플릿 다운로드를 통해 정해진 템플릿을 사용한다.           3.x : 플러그인 기반으로 기능 추가 vue plugin이라는 강력한 기능을 사용  이 기능을 이용해서 원하는 기능들 (라우터, Vuex …) 플러그인 형식으로 추가할 수 있도록 뷰에서 제공.   ES6 이해도     2.x : 필요 X   3.x : 필요 O   ","categories": ["vue-lv3"],
        "tags": ["vue"],
        "url": "/vue-lv3/vue-advanced1/",
        "teaser": null
      },{
        "title": "2 - 프로젝트 셋업",
        "excerpt":"2.1 Vue CLI로 프로젝트 생성 및 ESLint 로그 확인   vue create vue-news로 프로젝트 생성   Vue 2선택후 완료 되면 폴더 경로 들어가서 서버 실행하기   2.2 ESLint 도구 소개와 사용해야 하는 이유?   ESLint : javascript 문법 검사기(보조도구) javascript에서 ;(세미콜론)을 찍지 않더라도 자바스크립트 해석기에서는 마지막에 세미콜론을 넣어줌  여기서 ESLint는 세미콜론을 찍게 유도함  예를들어서   1 2 3 4 5 6 7 // 이런식이면 문제 없지만 if(a === 10){   console.log('a는 10'); }  // 자바스크립트 해석기가 어디서 세미콜론을 찍어야 할지 모를때 if(a === 10) console.log('a는 10') b() c()   ","categories": ["vue-lv3"],
        "tags": ["vue"],
        "url": "/vue-lv3/vue-advanced2/",
        "teaser": null
      },{
        "title": "3 - 라우터 기본",
        "excerpt":"3.1 라우터 설치 및 라우터 구현   yarn add vue-router@3.2.0로 설치하기(vue2는 vue-router3 버전사용, vue3는 vue-router4 버전사용)   package.json의 dependencies에 추가됨(배포할때도 포함 되어야 하는 라이브러리들)   라우터 설정을 main.js에 할 수도 있지만, main.js는 기본적으로 애플리케이션의 설정들(플러그인, 라이브러리, 구조들을 파악)의 청사진으로 보면 됨  그래서 라우터는 따로 폴더를 빼줌   3.2 router-view를 이용한 라우팅 컴포넌트 표시   App.vue에 &lt;router-view&gt;&lt;/router-view&gt;로 라우터 컴포넌트 보여줌      diff check    3.3 redirect 속성과 router-link   첫 화면에서 빈화면이 나오는데 redirect속성으로 원하는 라우터로 연결 가능  라우터 이동 링크 버튼도 추가   컴포넌트 등록할때는 스크립트단에서는 단어마다 첫글자 대문자로 연결  컴포넌트를 태그에서 등록할때는 단어사이에 하이픈으로 연결      diff check    3.4 ToolBar의 라우터 링크 스타일링   vue cli scss 설정      diff check    3.5 라우터 폴더 작명 팁과 라우터 mode 안내   mode: ‘history’, // 해쉬값 제거      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","router"],
        "url": "/vue-lv3/vue-advanced3/",
        "teaser": null
      },{
        "title": "4 - API 구현",
        "excerpt":"4.1 axios를 이용한 api 호출   해커뉴스 api      views 폴더에는 페이지 라우팅에 관련된 정보들만 들어가는게 좋다.   설계가 바뀌거나 할때 유연하게 대처하려면 데이터를 불러온다던지 비즈니스 로직들은 별도의 컴포넌트로 등록하는게 좋다.   우선 views안에 바로 넣고 나중에 수정할 예정      diff check    4.2 axios의 api 함수 구조화 방법 및 실습 안내      라이브러리를 각각의 파일에서 불러와야하고, 공통된 로직들이 계속 파일마다 불러와야 하는데 공통화시켜서 사용   data를 요청할때는 created나 beforeMount에서 많이 함 - 마운트 되고나서 데이터를 요청하면 데이터를 받아와서 데이터 배열에 넣으면 뷰의 리액티비티 시스템때문에 화면이 다시 그려짐   return axios.get = return new Promise가 같은 말이고 이것은 promise가 떨어진다는건데 -&gt; 뒤에 .then()을 연결할 수 있다는 뜻   api/index.js     정의한 함수를 다른데서 import로 쓸 수 있도록 export해줘야 함      diff check    4.3 자바스크립트 this 4가지와 화살표 함수의 this   this 가장 최상단에는 window가 있는데 콘솔창에 this를 그냥 찍어보면 window를 가리킨다.  함수안에 console.log(this)를 선언하고 함수를 실행하면 window를 가리킨다. 기본적으로 this는 전역을 향한다.  1 2 3 4 5 function sum(a, b) {     console.log(this); // 전역을 가리킴     return a + b; } sum(10, 20) // window객체와, 30이 찍힘   생성자 함수로 인스턴스를 생성했을 때는  1 2 3 4 5 function Vue(el) {     console.log(this); // 함수 자체를 가리킴     this.el = el; } new Vue('#app'); // Vue{}, Vue{el: '#app'} 이 찍힘   비동기 처리에서의 this     호출 전에는 VueComponent   호출 후에는 undefined   기본적으로 비동기 호출 자체는 호출되는 시점에서 기존에 있었던 this를 벗어난 새로운 this가 생김  그래서 함수밖과 함수안의 this가 다르기 때문에 함수 밖에서 변수에 this를 담아서 바인딩 해줘야 한다.  그러나 화살표 함수를 사용하면 this가 호출되는 위치의 this를 가져온다.      diff check    4.4 자바스크립트 비동기 처리(1) - Callback   Callback 어떤 특정 함수나 기능이 종료되는 시점에 실행 되는 함수  자바스크립트는 함수를 인자로 넘길 수 있는데 인자로 전달되는 함수를 보통 콜백함수라고 표현      diff check    4.5 자바스크립트 비동기 처리(2) - Promise   새로운 비동기 처리 패턴 promise      프로미스 쉽게 이해하기      diff check    ","categories": ["vue-lv3"],
        "tags": ["vue","api","axios","arrow function","비동기처리"],
        "url": "/vue-lv3/vue-advanced4/",
        "teaser": null
      },{
        "title": "5 - 스토어 구현",
        "excerpt":"5.1 Vuex 설치 및 Vuex가 적용된 앱 구조 소개      vuex를 적용해서 api에서 바로 불러오는게 아니고 vuex의 state에 api를 담아서 화면에 표시   yarn add vuex@3.4.0로 vuex 라이브러리 설치   5.2 Vuex 모듈화 및 state 적용      store폴더 생성후 그안에 작성   vuex는 플러그인 형태로 제공 되기 때문에 Vue.use(Vuex);로 사용   vuex는 상태관리 라이브러리이다. 상태라는 것은 여러 컴포넌트간에 공유되는 데이터 속성   NewsView가 users라는 데이터를 다른 컴포넌트에 아직 공유하고 있지 않은 상태인데 만약 다른 컴포넌트에서 users를 뿌려줘야 하는 상황이라면 공유해서 사용해야 한다.      diff check    5.3 NewsView에 actions와 mutations 적용      비동기 호출은 전부 action에서 하고 받아온 데이터를 mutations를 통해서 state에 넣어주게 구분되어 있다.   actions에서 비동기 호출을 하고 첫번째 인자로 context를 주면 mutations에 접근 할 수 있다.   context.commit(‘SET_NEWS’, response.data)   mutations에서는 첫번째 인자로 state를 넣어주고 두번째 인자에는 actions에서 넘겨준 response.data값이 들어간다.   컴포넌트에서 actions에 접근은 dispatch로 한다.      diff check    5.4 JobView에 스토어 적용      Destructuring 사용해서 넣어보기   Dstructuring 설명      diff check    5.5 map 헬퍼 함수를 이용한 AskView 풀이      mapState와 mapGetters는 computed 속성에서 사용   this.$store.state.ask; 이렇게 가져오는것은 더 길어지면 파악하기 힘들기 때문에 헬퍼 함수를 사용하면 편함      diff check    5.6 스토어 속성 모듈화      프로젝트가 커질 수록 store가 길어지니까 모듈화해서 나눠놓는게 좋다.      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","store","vuex"],
        "url": "/vue-lv3/vue-advanced5/",
        "teaser": null
      },{
        "title": "6 - 라우터 실전",
        "excerpt":"6.1 동적 라우트 매칭 원리 및 적용   Dynamic Route Matching     파라미터에 값을 넘겨주고 그 정보를 가지고 페이지를 이동한다.   router에 UserView.vue 컴포넌트 추가   아이디를 클릭했을때 그 값을 어떻게 넘겨서 각 회원 상세페이지를 보여줄까..? path에 /user/:id   router-link를 사용한다.      diff check    6.2 라우터 params을 이용한 User 상세 페이지 구현   news라우트에서 user 이름 클릭시 user 정보 상세페이지 구현     동적라우트 매칭으로 params를 받아왔고 그것을 이용해서 api를 호출   UserView.vue에서 user정보 가져오는 api를 호출 할 수도 있지만 스토어를 사용      api/index.js &gt; fetchUserInfo에 user정보 가져오는 로직 넣기   NewsView에서 클릭한 user이름으로 /user/${item.user} router-link를 통해서 이동   router/index.js에 라우트 등록해주기   UserView에서는 $route안의 params.id값을 const userName에 넣어주고 this.$store.dispatch를 통해서 actions에 있는 FETCH_USER에 접근하고 두번째 인자로 클릭한 username을 넘겨준다.   actions(비동기처리)에서 context를 첫번째 인자로 넘겨서 mutations에 접근할 수 있도록 하고 UserView에서 넘겨받은 username을 받도록 두번째 인자에 name을 넣어준다.   user정보 가져오는 함수 fetchUserInfo를 실행하고 인자로 name을 넘겨준다.   commit으로 SET_USER를 실행한다.   mutations에서 state에 접근해서 user에 비동기로 받아온 데이터를 넣어서 state를 바꾼다.   UserView에서 화면에 데이터를 뿌려준다.      diff check    6.3 질문 상세 페이지 실습 풀이 및 오류 디버깅      ItemView.vue 생성하고 router/index.js에 라우트 등록   AskView.vue에 router-link등록하기 &gt; /item/${item.id}   ItemView에 created에서 itemId 변수에 this.$route.params.id를 넣어준다.(콘솔로 itemId를 찍어봐서 잘 들어오는지 확인해보기)   actions에 FETCH_ITEM 선언하고 이 액션을 호출했을때 불러올 api함수(fetchItemInfo)를 api/index.js에 선언해준다.   api에 선언한 함수(fetchItemInfo)를 acions상단에 import해주고 FETCH_ITEM안에 실행시켜준다.   ItemView에서 created 됐을때 dispatch로 actions의 FETCH_ITEM에 연결해서 api를 호출하도록 하고, 두번째 인자로 params.id를 넣은 변수 itemId를 넣어준다.   다시 actions의 FETCH_ITEM에 ItemView에서 넘겨준 itemId를 여기서는 id(두번째 인자)로 받는다.   actions에 실행한 api함수(fetchItemInfo)가 프로미스 객체이므로 then, catch문을 받을 수 있다.   then에서 commit으로 SET_ITEM(mutations)을 연결한다.   mutations에서 SET_ITEM을 선언하고 첫번째 인자로 state를 넣고 actions에서 비동기처리로 데이터를 data에 받아와서 mutations의 두번째 인자에 item이라고 정의해서 넣어준다.   mutations에서 두번째 인자로 item을 넣었는데 이를 받아줄 item을 store/index.js의 state에서 정의 하지 않았으므로 가서 정의해준다.      diff check    6.4 질문 상세 페이지 스타일링 및 v-html 디렉티브 사용법 소개   불러온 데이터를 화면에 표시      화면에 뿌려주는 항목들을 mapGetters 헬퍼함수를 이용해서 뿌리기   mapGetters를 import한다.   store/index.js에 getter추가   ItemView로 돌아와서 computed 속성에 …mapGetters([‘fetchedItem’]) 정의하고 템플릿영역에서 fetchedItem으로 뿌려줌   content부분이 html태그를 그대로 들고와서 화면에 태그가 노출됨 &gt; v-html=”fetchedItem.content”   v-html API 문서   v-html과 데이터 바인딩 차이점 문서      diff check    6.5 라우터 트랜지션   특정 링크로 이동할때 바로 화면이 바뀌는데 뷰 내부적으로 제공하는 트랜지션 api로 부드러운 화면 전환하기     라우터 트랜지션 문서   뷰 트랜지션 문서   라우터 뷰를 트랜지션 태그로 감싸면 트랜지션 이펙트 사용 가능      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","router"],
        "url": "/vue-lv3/vue-advanced6/",
        "teaser": null
      },{
        "title": "7 - 리스트 아이템 컴포넌트 공통화",
        "excerpt":"7.1 컴포넌트 공통화 리팩토링      각 view페이지 스타일링      diff check    7.2 공통 컴포넌트 ListItem 제작 및 실습 안내      components폴더에 ListItem.vue파일 생성 : 각각의 페이지 컴포넌트가 들고있는 데이터 패치와 스타일링등을 다 들고옴   NewsView.vue에 ListItem.vue import해서 컴포넌트로 넣어줌      diff check    7.3 공통 컴포넌트 구현(1) - 페이지별 데이터 분기      라우터에 있는 정보들로 분기처리 가능      diff check   ","categories": ["vue-lv3"],
        "tags": ["vue","공통화"],
        "url": "/vue-lv3/vue-advanced7/",
        "teaser": null
      }]
